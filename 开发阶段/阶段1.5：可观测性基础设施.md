## 阶段 1.5：可观测性基础设施 (0.5周)

> **目标**：在复杂业务逻辑开发前建立可观测性基座，实现分布式追踪、异常捕获、调试工具
>
> **启动流程**：扩展 Phase 1（基础设施），在 Phase 3 延迟初始化中注册追踪组件

> **⚠️ 设计原则**：
> - 追踪系统绝不能阻塞业务系统（可观测性第一原则）
> - 采用内存缓冲 + 定时刷新 + aiosqlite 方案，利用现有 qasync 架构
> - 上下文穿透通过 contextvars + LangGraph config["configurable"] 实现
> - 可视化更新通过 EventBus 事件驱动，不轮询数据库

> **⚠️ 与现有架构的关系**：
> - 复用阶段一的 qasync 融合事件循环，不引入独立线程
> - 复用阶段一的 EventBus 进行事件广播
> - 与阶段三的 LLM 调用、阶段六的工具执行深度集成

---

### 1.5.0 可观测性架构概览

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        可观测性基础设施架构                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐     │
│  │ TracingContext  │───▶│ TracingLogger   │───▶│ TracingStore    │     │
│  │ (contextvars)   │    │ (内存缓冲)       │    │ (aiosqlite)     │     │
│  └─────────────────┘    └────────┬────────┘    └─────────────────┘     │
│          │                       │                      │               │
│          │                       │ EventBus             │               │
│          ▼                       ▼                      ▼               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      DevToolsPanel (UI)                          │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │   │
│  │  │ Trace Tree  │  │ Span Detail │  │ Performance │              │   │
│  │  │ View        │  │ View        │  │ Metrics     │              │   │
│  │  └─────────────┘  └─────────────┘  └─────────────┘              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```


### 1.5.1 追踪模块目录结构

```
shared/tracing/
├── __init__.py
├── tracing_types.py          # 数据类型定义（SpanRecord、TraceStatus 等）
├── tracing_context.py        # 上下文管理（contextvars 封装）
├── tracing_logger.py         # 追踪日志记录器（内存缓冲 + 定时刷新）
├── tracing_store.py          # SQLite 存储（aiosqlite 异步写入）
├── safe_async_slot.py        # qasync 异常捕获装饰器
└── tracing_events.py         # 追踪相关事件定义

presentation/panels/
└── devtools_panel.py         # 调试工具面板
```

---

### 1.5.2 追踪数据类型 (`shared/tracing/tracing_types.py`)

- [ ] **职责**：定义追踪系统的核心数据类型，与业务逻辑解耦
- [ ] **核心数据类**：
  ```python
  @dataclass
  class SpanRecord:
      """单个追踪 Span 记录"""
      trace_id: str           # 追踪 ID（整个请求链路）
      span_id: str            # Span ID（当前操作）
      parent_span_id: Optional[str]  # 父 Span ID
      operation_name: str     # 操作名称（如 "llm_call", "tool_execute"）
      service_name: str       # 服务名称（如 "llm_executor", "simulation_service"）
      start_time: float       # 开始时间戳（time.time()）
      end_time: Optional[float]  # 结束时间戳
      status: TraceStatus     # 状态（RUNNING, SUCCESS, ERROR, CANCELLED）
      inputs: Optional[Dict[str, Any]]   # 输入参数（JSON 序列化）
      outputs: Optional[Dict[str, Any]]  # 输出结果（JSON 序列化）
      error_message: Optional[str]       # 错误信息
      error_traceback: Optional[str]     # 完整错误堆栈（异常时记录）
      metadata: Optional[Dict[str, Any]] # 额外元数据
      
      def to_tuple(self) -> tuple:
          """转换为 SQLite 插入元组"""
          ...
      
      def duration_ms(self) -> Optional[float]:
          """计算耗时（毫秒）"""
          ...
  ```
- [ ] **状态枚举**：
  ```python
  class TraceStatus(Enum):
      RUNNING = "running"
      SUCCESS = "success"
      ERROR = "error"
      CANCELLED = "cancelled"
  ```
- [ ] **Span 类型常量**：
  ```python
  class SpanType:
      LLM_CALL = "llm_call"           # LLM API 调用
      TOOL_EXECUTE = "tool_execute"   # 工具执行
      SIMULATION = "simulation"       # 仿真任务
      RAG_SEARCH = "rag_search"       # RAG 检索
      GRAPH_NODE = "graph_node"       # LangGraph 节点
      USER_INPUT = "user_input"       # 用户输入
      CONTEXT_BUILD = "context_build" # 上下文构建
      AGENTIC_LOOP = "agentic_loop"   # Agentic Loop 循环
      AGENTIC_LLM_ITER = "agentic_llm_iter"  # Agentic Loop 内的 LLM 迭代
      AGENTIC_TOOL = "agentic_tool"   # Agentic Loop 内的工具执行
  ```
- [ ] **被调用方**：`tracing_context.py`、`tracing_logger.py`、`tracing_store.py`

---

### 1.5.3 追踪上下文管理 (`shared/tracing/tracing_context.py`)

> **设计说明**：使用 Python 的 `contextvars` 模块实现协程安全的上下文传递，解决 PyQt 信号边界和 LangGraph 节点边界的上下文穿透问题。

- [ ] **职责**：管理追踪上下文的创建、传递、恢复
- [ ] **核心类**：`TracingContext`
- [ ] **上下文变量定义**：
  ```python
  _current_trace_id: ContextVar[Optional[str]] = ContextVar('trace_id', default=None)
  _current_span_id: ContextVar[Optional[str]] = ContextVar('span_id', default=None)
  _current_span_stack: ContextVar[List[str]] = ContextVar('span_stack', default_factory=list)
  ```

- [ ] **核心功能**：
  - `start_trace(operation_name)` - 开始新的追踪链路，生成 trace_id
  - `start_span(operation_name, service_name)` - 开始新的 Span，自动关联父 Span
  - `start_span_with_parent(operation_name, service_name, parent_span_id)` - 显式指定父 Span（用于并行执行）
  - `end_span(status, outputs, error)` - 结束当前 Span
  - `get_current_trace_id()` - 获取当前 trace_id
  - `get_current_span_id()` - 获取当前 span_id
  - `get_context_for_langgraph()` - 导出上下文到 LangGraph config
  - `restore_from_langgraph(config)` - 从 LangGraph config 恢复上下文
  - `restore_from_graph_state(state)` - 从 GraphState 恢复上下文（用于 interrupt/resume）
- [ ] **上下文管理器支持**：
  ```python
  async with TracingContext.span("llm_call", "llm_executor") as span:
      result = await llm_client.chat(messages)
      span.set_output({"response": result})
  ```
- [ ] **异常时完整堆栈记录**：
  ```python
  except Exception as e:
      span_ctx.finish(
          TraceStatus.ERROR, 
          error_message=str(e),
          error_traceback=traceback.format_exc()
      )
      raise
  ```
- [ ] **LangGraph 边界穿透**：
  - 问题：LangGraph 节点执行是独立的协程调用，contextvars 不会自动传递
  - 解决：在 `config["configurable"]` 中传递 `trace_id` 和 `parent_span_id`
  - 节点入口处调用 `TracingContext.restore_from_langgraph(config)` 恢复上下文
  ```python
  # 调用 graph.ainvoke 时
  config = {
      "configurable": {
          "thread_id": thread_id,
          "trace_id": TracingContext.get_current_trace_id(),
          "parent_span_id": TracingContext.get_current_span_id(),
      }
  }
  result = await graph.ainvoke(state, config)
  
  # 节点内部
  async def my_node(state: GraphState, config: RunnableConfig):
      TracingContext.restore_from_langgraph(config)
      async with TracingContext.span("my_node", "graph"):
          # 节点逻辑
          ...
  ```
- [ ] **PyQt 信号边界说明**：
  - 本项目采用 qasync 单一事件循环架构，所有 UI 操作都在主线程
  - pyqtSignal 本身不会丢失 contextvars（同线程内）
  - 真正需要处理的是 `QMetaObject.invokeMethod` 跨线程调用时的上下文传递
  - 解决：在跨线程调用前导出上下文，调用后恢复
- [ ] **ID 生成策略**：
  - trace_id：`f"trace_{uuid.uuid4().hex[:16]}"`
  - span_id：`f"span_{uuid.uuid4().hex[:12]}"`
- [ ] **被调用方**：`tracing_logger.py`、`llm_executor.py`、LangGraph 节点、`AgenticLoopController`

---

### 1.5.3.1 追踪上下文持久化（GraphState 集成）

> **设计说明**：解决 LangGraph interrupt/resume 后追踪链路断裂的问题。当 `user_checkpoint_node` 暂停执行后，用户点击"继续"恢复时，contextvars 会丢失。通过将追踪上下文持久化到 GraphState，确保恢复后的执行链路与之前保持连续。

- [ ] **职责**：在 GraphState 中持久化追踪上下文，支持跨 interrupt/resume 的链路连续性
- [ ] **GraphState 追踪字段**（在阶段七 7.2.1 定义）：
  - `_trace_id: str` - 当前追踪链路 ID
  - `_last_span_id: str` - 最后一个 Span ID（用于恢复后的父子关系）
  - `_trace_checkpoint_count: int` - 追踪检查点计数（用于 UI 显示跨 checkpoint 标记）
- [ ] **保存时机**：
  - 在 `user_checkpoint_node` 调用 `interrupt()` 前保存
  - 在任何可能导致图暂停的节点前保存
- [ ] **恢复时机**：
  - 在 `action_node` 等恢复后执行的节点入口处恢复
  - 恢复后创建的 Span 自动关联到之前的 trace_id
- [ ] **恢复方法**：
  ```python
  @classmethod
  def restore_from_graph_state(cls, state: Dict[str, Any]) -> bool:
      """从 GraphState 恢复追踪上下文，返回是否成功恢复"""
      trace_id = state.get("_trace_id")
      last_span_id = state.get("_last_span_id")
      
      if trace_id:
          _current_trace_id.set(trace_id)
          if last_span_id:
              _current_span_id.set(last_span_id)
              _span_stack.set([last_span_id])
          return True
      return False
  ```
- [ ] **导出方法**：
  ```python
  @classmethod
  def export_to_graph_state(cls) -> Dict[str, Any]:
      """导出追踪上下文到 GraphState 字段"""
      return {
          "_trace_id": _current_trace_id.get(),
          "_last_span_id": _current_span_id.get(),
      }
  ```
- [ ] **跨 checkpoint 标记**：
  - 恢复后创建的第一个 Span 添加 `metadata["resumed_from_checkpoint"] = True`
  - DevToolsPanel 根据此标记显示特殊图标（如虚线连接）
- [ ] **被调用方**：`user_checkpoint_node`、`action_node`、`undo_node`

---

### 1.5.3.2 并行执行的追踪安全

> **设计说明**：Agentic Loop 支持并行执行多个工具（`asyncio.gather`）。虽然 Python 3.7+ 的 contextvars 在 gather 中会为每个子任务复制上下文，但为了追踪的明确性和可调试性，建议显式传递父 Span ID。

- [ ] **职责**：确保并行执行时追踪的父子关系正确
- [ ] **显式父 Span 传递**：
  ```python
  async def _execute_tools_parallel(self, tool_calls: List[dict]) -> List[dict]:
      """并行执行工具，显式传递父 span_id"""
      parent_span_id = TracingContext.get_current_span_id()
      
      async def execute_with_tracing(tc: dict) -> dict:
          async with TracingContext.span_with_parent(
              f"tool_{tc['function']['name']}", 
              "tool_executor",
              parent_span_id=parent_span_id
          ) as span:
              span.set_input(tc['function']['arguments'])
              result = await self._execute_single_tool(tc)
              span.set_output({"success": result.get("success")})
              return result
      
      return await asyncio.gather(*[execute_with_tracing(tc) for tc in tool_calls])
  ```
- [ ] **span_with_parent 方法**：
  ```python
  @classmethod
  @asynccontextmanager
  async def span_with_parent(
      cls,
      operation_name: str,
      service_name: str,
      parent_span_id: str,
      inputs: Optional[Dict[str, Any]] = None,
  ):
      """创建指定父 Span 的子 Span（用于并行执行）"""
      trace_id = _current_trace_id.get()
      span_id = _generate_span_id()
      
      record = SpanRecord(
          trace_id=trace_id,
          span_id=span_id,
          parent_span_id=parent_span_id,  # 显式指定
          operation_name=operation_name,
          service_name=service_name,
          inputs=inputs,
      )
      # ... 其余逻辑同 span()
  ```
- [ ] **并发写入安全**：
  - `TracingStore.insert_spans()` 使用 aiosqlite，协程安全
  - span_id 使用 UUID 生成，不会冲突
  - 内存缓冲区使用 `threading.Lock` 保护
- [ ] **被调用方**：`AgenticLoopController._execute_tools_parallel()`

---

### 1.5.4 追踪日志记录器 (`shared/tracing/tracing_logger.py`)

> **设计说明**：采用内存缓冲 + 定时刷新 + aiosqlite 方案，确保追踪写入不阻塞业务逻辑。
> 这是对 Gemini 建议的简化实现：采纳"异步化 + 批量写入"核心思想，但用更简单的方案替代独立 QThread。

- [ ] **职责**：接收 Span 记录，缓冲后批量写入存储
- [ ] **核心类**：`TracingLogger`
- [ ] **初始化顺序**：Phase 3 延迟初始化，依赖 EventBus、TracingStore

- [ ] **内存缓冲层设计**：
  ```python
  class TracingLogger:
      def __init__(self):
          self._buffer: List[SpanRecord] = []
          self._buffer_lock = threading.Lock()  # 保护 buffer 的轻量锁
          self._flush_interval_ms = 500         # 刷新间隔
          self._max_buffer_size = 100           # 缓冲区上限
          self._flush_timer: Optional[QTimer] = None
          self._store: Optional[TracingStore] = None
  ```
- [ ] **核心功能**：
  - `record_span(span)` - 记录 Span（微秒级耗时，仅追加到缓冲区）
  - `_flush_buffer()` - 异步批量写入 SQLite
  - `_start_flush_timer()` - 启动定时刷新（EVENT_INIT_COMPLETE 后）
  - `shutdown()` - 优雅关闭（最后一次刷新）
- [ ] **写入流程**：
  ```python
  def record_span(self, span: SpanRecord):
      """主线程调用，微秒级耗时"""
      with self._buffer_lock:
          self._buffer.append(span)
          # 缓冲区满时立即触发异步刷新
          if len(self._buffer) >= self._max_buffer_size:
              asyncio.create_task(self._flush_buffer())
  
  async def _flush_buffer(self):
      """异步批量写入 SQLite"""
      with self._buffer_lock:
          if not self._buffer:
              return
          batch = self._buffer.copy()
          self._buffer.clear()
      
      # aiosqlite 批量写入（不阻塞事件循环）
      await self._store.insert_spans(batch)
      
      # 发布事件通知 UI 更新
      EventBus.publish(TracingEvents.SPANS_FLUSHED, {"count": len(batch)})
  ```
- [ ] **定时刷新机制**：
  ```python
  def _start_flush_timer(self):
      """在 EVENT_INIT_COMPLETE 后启动"""
      self._flush_timer = QTimer()
      self._flush_timer.timeout.connect(
          lambda: asyncio.create_task(self._flush_buffer())
      )
      self._flush_timer.start(self._flush_interval_ms)
  ```
- [ ] **优雅关闭**：
  ```python
  async def shutdown(self):
      """应用关闭时调用"""
      if self._flush_timer:
          self._flush_timer.stop()
      await self._flush_buffer()  # 最后一次刷新
  ```
- [ ] **为什么不用独立 QThread**：
  - 已有 qasync 融合循环：aiosqlite 的异步写入不会阻塞 UI
  - 复杂度成本：独立线程需要处理线程安全的 Queue、线程生命周期、优雅关闭、异常传播
  - 调试困难：多线程的追踪系统本身就难以追踪
  - 并发量不需要：桌面应用的追踪日志量级，内存缓冲 + 定时刷新完全够用
- [ ] **被调用方**：`TracingContext`（Span 结束时）、`bootstrap.py`（初始化和关闭）

---

### 1.5.5 SQLite 追踪存储 (`shared/tracing/tracing_store.py`)

- [ ] **职责**：管理追踪数据的持久化存储和查询
- [ ] **核心类**：`TracingStore`
- [ ] **存储位置**：`~/.circuit_design_ai/traces.sqlite3`（全局，跨项目）
- [ ] **表结构设计**：
  ```sql
  -- 主表：Span 记录
  CREATE TABLE IF NOT EXISTS spans (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      trace_id TEXT NOT NULL,
      span_id TEXT NOT NULL UNIQUE,
      parent_span_id TEXT,
      operation_name TEXT NOT NULL,
      service_name TEXT NOT NULL,
      start_time REAL NOT NULL,
      end_time REAL,
      status TEXT NOT NULL,
      error_message TEXT,
      error_traceback TEXT,  -- 完整错误堆栈
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      
      -- 索引优化查询
      FOREIGN KEY (parent_span_id) REFERENCES spans(span_id)
  );
  
  CREATE INDEX IF NOT EXISTS idx_spans_trace_id ON spans(trace_id);
  CREATE INDEX IF NOT EXISTS idx_spans_parent_span_id ON spans(parent_span_id);  -- 用于查询子 Span
  CREATE INDEX IF NOT EXISTS idx_spans_start_time ON spans(start_time);
  CREATE INDEX IF NOT EXISTS idx_spans_status ON spans(status);
  
  -- 分离表：Span 输入输出（避免主表 JSON 查询困难）
  CREATE TABLE IF NOT EXISTS span_data (
      span_id TEXT PRIMARY KEY,
      inputs TEXT,    -- JSON 序列化
      outputs TEXT,   -- JSON 序列化
      metadata TEXT,  -- JSON 序列化
      
      FOREIGN KEY (span_id) REFERENCES spans(span_id)
  );
  ```

- [ ] **核心功能**：
  - `initialize()` - 初始化数据库连接和表结构
  - `insert_spans(spans)` - 批量插入 Span 记录
  - `update_span(span_id, updates)` - 更新 Span 状态
  - `get_trace(trace_id)` - 获取完整追踪链路
  - `get_child_spans(parent_span_id)` - 获取指定 Span 的所有子 Span（用于展开 Sub-Spans）
  - `get_span_tree(span_id)` - 递归获取 Span 及其所有后代（用于 DevToolsPanel 展开）
  - `get_recent_traces(limit, offset)` - 获取最近的追踪记录
  - `get_spans_by_status(status)` - 按状态查询 Span
  - `cleanup_old_traces(days)` - 清理过期数据
  - `close()` - 关闭数据库连接
- [ ] **子 Span 查询实现**：
  ```python
  async def get_child_spans(self, parent_span_id: str) -> List[SpanRecord]:
      """获取指定 Span 的直接子 Span"""
      async with aiosqlite.connect(self._db_path) as db:
          cursor = await db.execute(
              """SELECT * FROM spans WHERE parent_span_id = ? 
                 ORDER BY start_time ASC""",
              (parent_span_id,)
          )
          rows = await cursor.fetchall()
          return [SpanRecord.from_row(row) for row in rows]
  
  async def get_span_tree(self, span_id: str) -> Dict[str, Any]:
      """递归获取 Span 树结构（用于 UI 展开）"""
      span = await self.get_span(span_id)
      children = await self.get_child_spans(span_id)
      return {
          "span": span,
          "children": [await self.get_span_tree(c.span_id) for c in children]
      }
  ```
- [ ] **批量插入实现**：
  ```python
  async def insert_spans(self, spans: List[SpanRecord]):
      """批量插入 Span 记录"""
      async with aiosqlite.connect(self._db_path) as db:
          # 插入主表
          await db.executemany(
              """INSERT INTO spans 
                 (trace_id, span_id, parent_span_id, operation_name, 
                  service_name, start_time, end_time, status, error_message, error_traceback)
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
              [span.to_main_tuple() for span in spans]
          )
          # 插入数据表
          await db.executemany(
              """INSERT INTO span_data (span_id, inputs, outputs, metadata)
                 VALUES (?, ?, ?, ?)""",
              [span.to_data_tuple() for span in spans]
          )
          await db.commit()
  ```
- [ ] **数据清理策略**：
  - 默认保留 7 天的追踪数据
  - 应用启动时自动清理过期数据
  - 提供手动清理接口
- [ ] **查询优化**：
  - 使用索引加速 trace_id 和时间范围查询
  - 分页查询避免一次加载过多数据
  - 输入输出数据按需加载（不在列表查询中返回）
- [ ] **被调用方**：`TracingLogger`（写入）、`DevToolsPanel`（查询）

---

### 1.5.6 追踪事件定义 (`shared/tracing/tracing_events.py`)

- [ ] **职责**：定义追踪系统相关的 EventBus 事件
- [ ] **事件常量**：
  ```python
  class TracingEvents:
      """追踪系统事件定义"""
      
      # Span 生命周期事件
      SPAN_STARTED = "tracing.span_started"      # Span 开始
      SPAN_ENDED = "tracing.span_ended"          # Span 结束
      
      # 批量刷新事件
      SPANS_FLUSHED = "tracing.spans_flushed"    # 批量写入完成
      
      # 追踪链路事件
      TRACE_STARTED = "tracing.trace_started"    # 新追踪链路开始
      TRACE_COMPLETED = "tracing.trace_completed" # 追踪链路完成
      
      # 错误事件
      SPAN_ERROR = "tracing.span_error"          # Span 执行出错
  ```
- [ ] **事件数据结构**：
  - `SPAN_STARTED`：`{"trace_id", "span_id", "operation_name", "service_name"}`
  - `SPAN_ENDED`：`{"trace_id", "span_id", "status", "duration_ms"}`
  - `SPANS_FLUSHED`：`{"count"}`
  - `SPAN_ERROR`：`{"trace_id", "span_id", "error_message"}`
- [ ] **被调用方**：`TracingLogger`（发布）、`DevToolsPanel`（订阅）

---

### 1.5.7 qasync 异常捕获装饰器 (`shared/tracing/safe_async_slot.py`)

> **设计说明**：qasync 的 `@asyncSlot()` 装饰器在协程抛出异常时会静默失败。
> `@safe_async_slot` 装饰器与 `@asyncSlot` 配合使用，捕获异常并记录到追踪系统。

- [ ] **职责**：增强 qasync 的异常捕获能力，确保异步槽函数的异常被正确处理
- [ ] **核心装饰器**：
  ```python
  def safe_async_slot(*args):
      """
      与 @asyncSlot 配合使用的异常捕获装饰器
      
      使用方式：
      @asyncSlot()
      @safe_async_slot()
      async def on_button_clicked(self):
          await some_async_operation()
      """
      def decorator(func):
          @functools.wraps(func)
          async def wrapper(*args, **kwargs):
              try:
                  return await func(*args, **kwargs)
              except asyncio.CancelledError:
                  # 任务取消不视为错误
                  logger.debug(f"Async slot {func.__name__} was cancelled")
                  raise
              except Exception as e:
                  # 记录到追踪系统
                  TracingContext.record_error(func.__name__, e)
                  # 记录到日志
                  logger.exception(f"Error in async slot {func.__name__}: {e}")
                  # 发布错误事件
                  EventBus.publish(EVENT_ASYNC_SLOT_ERROR, {
                      "function": func.__name__,
                      "error": str(e),
                      "traceback": traceback.format_exc()
                  })
                  # 根据配置决定是否重新抛出
                  if ConfigManager.get("debug.reraise_async_errors", False):
                      raise
          return wrapper
      
      # 支持 @safe_async_slot 和 @safe_async_slot() 两种用法
      if len(args) == 1 and callable(args[0]):
          return decorator(args[0])
      return decorator
  ```

- [ ] **使用示例**：
  ```python
  from qasync import asyncSlot
  from shared.tracing import safe_async_slot
  
  class ConversationPanel(QWidget):
      @asyncSlot()
      @safe_async_slot()
      async def on_send_clicked(self):
          """发送消息按钮点击处理"""
          message = self.input_area.get_text()
          await self._send_message(message)
  ```
- [ ] **与 @asyncSlot 的关系**：
  - `@asyncSlot()` 负责将协程正确调度到 qasync 事件循环
  - `@safe_async_slot()` 负责捕获异常并记录
  - 两者配合使用，顺序为：`@asyncSlot()` 在外，`@safe_async_slot()` 在内
- [ ] **异常处理策略**：
  - `asyncio.CancelledError`：正常取消，仅记录 debug 日志，重新抛出
  - 其他异常：记录到追踪系统和日志，发布错误事件，根据配置决定是否重新抛出
- [ ] **被调用方**：所有使用 `@asyncSlot()` 的 UI 组件

---

### 1.5.8 调试工具面板 (`presentation/panels/devtools_panel.py`)

> **设计说明**：提供可视化的追踪查看器，帮助开发者调试 LLM 调用、工具执行、工作流节点等。
> 通过 EventBus 订阅追踪事件实时更新，不轮询数据库。

- [ ] **职责**：可视化展示追踪数据，辅助调试和性能分析
- [ ] **位置**：右栏标签页之一（与"对话"、"信息"、"元器件"并列）
- [ ] **核心类**：`DevToolsPanel(QWidget)`
- [ ] **UI 布局**：
  ```
  ┌─────────────────────────────────────────────────────────┐
  │ [刷新] [清除] [导出]                    [过滤: ▼ 全部]  │
  ├─────────────────────────────────────────────────────────┤
  │ ┌─────────────────────┐ ┌─────────────────────────────┐ │
  │ │ Trace 列表          │ │ Span 详情                   │ │
  │ │                     │ │                             │ │
  │ │ ▼ trace_abc123      │ │ Operation: llm_call         │ │
  │ │   ├─ llm_call       │ │ Service: llm_executor       │ │
  │ │   │  └─ context_... │ │ Duration: 1234ms            │ │
  │ │   └─ tool_execute   │ │ Status: ✓ success           │ │
  │ │                     │ │                             │ │
  │ │ ▼ trace_def456      │ │ Inputs:                     │ │
  │ │   └─ simulation     │ │ { "messages": [...] }       │ │
  │ │                     │ │                             │ │
  │ │                     │ │ Outputs:                    │ │
  │ │                     │ │ { "response": "..." }       │ │
  │ └─────────────────────┘ └─────────────────────────────┘ │
  ├─────────────────────────────────────────────────────────┤
  │ 性能统计: LLM 平均 1.2s | 工具 平均 0.3s | 错误率 2%    │
  └─────────────────────────────────────────────────────────┘
  ```
- [ ] **核心功能**：
  - `refresh()` - 从 TracingStore 加载最近的追踪数据
  - `clear()` - 清空显示（不删除存储数据）
  - `export_trace(trace_id)` - 导出追踪数据为 JSON
  - `filter_by_status(status)` - 按状态过滤
  - `filter_by_service(service)` - 按服务过滤
  - `show_span_detail(span_id)` - 显示 Span 详情
  - `expand_sub_spans(span_id)` - 展开查看子 Span 树（用于 Agentic Loop 内部追踪）
  - `show_error_traceback(span_id)` - 显示完整错误堆栈
- [ ] **Sub-Spans 展开功能**：
  - 当 Span 有子 Span 时，显示展开箭头 ▶
  - 点击展开后加载子 Span 树（调用 `TracingStore.get_span_tree()`）
  - 支持多级嵌套展开（如 `action_node → agentic_loop → llm_call_iter_0 → tool_xxx`）
  - 跨 checkpoint 恢复的 Span 显示特殊标记（虚线连接 + `resume.svg` 图标）
- [ ] **Agentic Loop 追踪层级展示**：
  ```
  ▼ trace_abc123 (用户请求)
    ├─ action_node (LangGraph 节点)
    │  └─ ▼ agentic_loop (循环整体)
    │       ├─ llm_call_iter_0 (第1次 LLM 调用)
    │       ├─ tool_patch_file (工具执行)
    │       ├─ llm_call_iter_1 (第2次 LLM 调用)
    │       ├─ tool_run_simulation (工具执行)
    │       └─ llm_call_iter_2 (第3次 LLM 调用)
    └─ ┈┈ [resume] action_node_resumed (跨 checkpoint 恢复)
  ```
- [ ] **实时更新机制**：
  ```python
  def __init__(self):
      super().__init__()
      # 订阅追踪事件
      EventBus.subscribe(TracingEvents.SPANS_FLUSHED, self._on_spans_flushed)
      EventBus.subscribe(TracingEvents.SPAN_ERROR, self._on_span_error)
  
  def _on_spans_flushed(self, data):
      """批量刷新完成后更新 UI"""
      # 增量加载新数据，不全量刷新
      asyncio.create_task(self._load_recent_spans())
  
  def _on_span_error(self, data):
      """错误 Span 高亮显示"""
      self._highlight_error_span(data["span_id"])
  ```
  ```
- [ ] **UI 组件**：
  - `QTreeView` - 追踪树形视图（trace → spans 层级）
  - `QTextEdit` - Span 详情显示（JSON 格式化）
  - `QComboBox` - 状态/服务过滤器
  - `QLabel` - 性能统计摘要
- [ ] **视觉设计**：
  - 成功 Span：绿色图标 ✓
  - 错误 Span：红色图标 ✗，行背景浅红
  - 运行中 Span：蓝色图标 ⟳
  - 取消 Span：灰色图标 ⊘
- [ ] **性能统计**：
  - 按服务分组计算平均耗时
  - 计算错误率（错误 Span 数 / 总 Span 数）
  - 显示最近 N 条追踪的统计摘要
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件
- [ ] **标签页注册**：
  - 标签页 ID：`TAB_DEVTOOLS`（需在 `tab_controller.py` 中定义）
  - 标签页标题 key：`panel.devtools`
  - 标签页图标：`icons/panel/bug.svg`
  - 默认可见性：仅在 `debug.show_devtools_panel` 配置为 true 时显示
- [ ] **被调用方**：`main_window.py`（通过 `TabController` 注册到右栏标签页）

---

### 1.5.9 右栏标签页集成

> **设计说明**：DevToolsPanel 作为右栏标签页之一，需要通过 `TabController` 注册。
> 右栏使用 `QTabWidget` 承载多个面板，由 `TabController` 统一管理。

#### 1.5.9.1 标签页常量定义

- [ ] **文件路径**：`presentation/core/tab_controller.py`
- [ ] **新增常量**：
  ```python
  TAB_DEVTOOLS = "TAB_DEVTOOLS"
  ```
- [ ] **导出更新**：将 `TAB_DEVTOOLS` 添加到 `__all__` 列表

#### 1.5.9.2 面板注册表更新

- [ ] **文件路径**：`presentation/core/panel_registry.py`
- [ ] **新增面板定义**：
  ```python
  "devtools": {
      "class": "DevToolsPanel",
      "module": "presentation.panels.devtools_panel",
      "region": "RIGHT",
      "default_visible": False,  # 默认隐藏，通过配置控制
      "title_key": "panel.devtools",
      "icon": "icons/panel/bug.svg",
      "tab_id": "TAB_DEVTOOLS",
      "config_key": "debug.show_devtools_panel",  # 配置控制可见性
  },
  ```

#### 1.5.9.3 main_window.py 右栏标签页初始化

> **设计说明**：`main_window.py` 需要创建 `QTabWidget` 作为右栏容器，并通过 `TabController` 管理标签页。

- [ ] **右栏布局结构**：
  ```
  右栏 (QTabWidget)
  ├── 对话 (ConversationPanel) - TAB_CONVERSATION
  ├── 信息 (InfoPanel) - TAB_INFO（阶段九实现）
  ├── 调试 (DevToolsPanel) - TAB_DEVTOOLS（配置控制）
  └── 元器件 (ComponentPanel) - TAB_COMPONENT（阶段十实现）
  ```

- [ ] **初始化流程**（在 `_create_panels()` 方法中）：
  1. 创建 `QTabWidget` 作为右栏容器
  2. 初始化 `TabController` 并绑定 `QTabWidget`
  3. 创建 `ConversationPanel` 并通过 `TabController.register_tab()` 注册
  4. 检查 `debug.show_devtools_panel` 配置
  5. 若配置为 true，创建 `DevToolsPanel` 并注册到标签页
  6. 将 `QTabWidget` 添加到水平分割器

- [ ] **代码示例**：
  ```python
  def _create_panels(self):
      # ... 左栏、中栏创建代码 ...
      
      # 右栏 - 使用 QTabWidget 承载多个面板
      from PyQt6.QtWidgets import QTabWidget
      from presentation.core.tab_controller import (
          TabController, TAB_CONVERSATION, TAB_DEVTOOLS
      )
      
      # 创建标签页容器
      right_tab_widget = QTabWidget()
      right_tab_widget.setMinimumWidth(250)
      
      # 初始化标签页控制器
      self._tab_controller = TabController()
      self._tab_controller.bind_tab_widget(right_tab_widget)
      
      # 注册对话面板
      from presentation.panels.conversation_panel import ConversationPanel
      chat_panel = ConversationPanel()
      self._tab_controller.register_tab(
          TAB_CONVERSATION,
          chat_panel,
          self._get_text("panel.conversation", "对话"),
          "resources/icons/panel/chat.svg"
      )
      self._panels["chat"] = chat_panel
      
      # 注册调试面板（根据配置）
      if self._should_show_devtools():
          from presentation.panels.devtools_panel import DevToolsPanel
          devtools_panel = DevToolsPanel()
          self._tab_controller.register_tab(
              TAB_DEVTOOLS,
              devtools_panel,
              self._get_text("panel.devtools", "调试"),
              "resources/icons/panel/bug.svg"
          )
          self._panels["devtools"] = devtools_panel
      
      # 添加到分割器
      self._splitters["horizontal"].addWidget(right_tab_widget)
      self._panels["right_tabs"] = right_tab_widget
  
  def _should_show_devtools(self) -> bool:
      """检查是否应显示调试面板"""
      if self.config_manager:
          return self.config_manager.get("debug.show_devtools_panel", True)
      return True  # 默认显示
  ```

- [ ] **国际化支持**：
  - 在 `retranslate_ui()` 中调用 `TabController.retranslate_tabs()`
  - 传入 `self._get_text` 作为标题获取函数

---

### 1.5.10 bootstrap.py 初始化顺序扩展

> **说明**：以下内容需要添加到阶段一 `bootstrap.py` 的初始化顺序中。

- [ ] **Phase 1 扩展**（核心管理器初始化）：
  ```
  ├─ 1.7 TracingStore 初始化
  │      ├─ 依赖：Logger
  │      ├─ 初始化 SQLite 数据库连接
  │      ├─ 创建表结构（若不存在）
  │      ├─ 清理过期追踪数据
  │      └─ 注册到 ServiceLocator
  ```

- [ ] **Phase 3 扩展**（延迟初始化）：
  ```
  ├─ 3.1.3 TracingLogger 初始化
  │      ├─ 依赖：EventBus、TracingStore
  │      ├─ 初始化内存缓冲区
  │      ├─ 启动定时刷新 QTimer
  │      └─ 注册到 ServiceLocator
  ```
- [ ] **应用关闭时**：
  ```python
  async def _shutdown():
      # 停止追踪日志记录器（最后一次刷新）
      tracing_logger = ServiceLocator.get(TracingLogger)
      if tracing_logger:
          await tracing_logger.shutdown()
      
      # 关闭追踪存储
      tracing_store = ServiceLocator.get(TracingStore)
      if tracing_store:
          await tracing_store.close()
  ```

---

### 1.5.11 与其他阶段的集成点

#### 与阶段三（LLM 集成）的集成

- [ ] **LLM 调用追踪**：
  ```python
  # llm_executor.py
  async def execute(self, messages, config):
      async with TracingContext.span("llm_call", "llm_executor") as span:
          span.set_input({"messages": messages, "model": config.model})
          try:
              response = await self._client.chat(messages, config)
              span.set_output({"response": response.content})
              span.set_status(TraceStatus.SUCCESS)
              return response
          except Exception as e:
              span.set_error(str(e))
              span.set_status(TraceStatus.ERROR)
              raise
  ```

#### 与阶段六（工具系统）的集成

- [ ] **工具执行追踪**：
  ```python
  # tool_executor.py
  async def execute_tool(self, tool_name, args):
      async with TracingContext.span("tool_execute", "tool_executor") as span:
          span.set_input({"tool": tool_name, "args": args})
          try:
              result = await self._tools[tool_name].execute(args)
              span.set_output({"result": result})
              span.set_status(TraceStatus.SUCCESS)
              return result
          except Exception as e:
              span.set_error(str(e))
              span.set_status(TraceStatus.ERROR)
              raise
  ```

#### 与阶段七（LangGraph 工作流）的集成

- [ ] **图节点追踪**：
  ```python
  # graph_nodes.py
  async def analyze_node(state: GraphState, config: RunnableConfig):
      # 从 config 恢复追踪上下文
      TracingContext.restore_from_langgraph(config)
      
      async with TracingContext.span("analyze_node", "graph") as span:
          span.set_input({"state_keys": list(state.keys())})
          # 节点逻辑
          result = await do_analysis(state)
          span.set_output({"result_summary": summarize(result)})
          return result
  ```

---

### 1.5.12 配置项

- [ ] **全局配置**（`~/.circuit_design_ai/config.json`）：
  ```json
  {
    "tracing": {
      "enabled": true,
      "flush_interval_ms": 500,
      "max_buffer_size": 100,
      "retention_days": 7,
      "log_inputs_outputs": true
    },
    "debug": {
      "reraise_async_errors": false,
      "show_devtools_panel": true
    }
  }
  ```
- [ ] **配置项说明**：
  - `tracing.enabled`：是否启用追踪（默认 true）
  - `tracing.flush_interval_ms`：缓冲区刷新间隔（默认 500ms）
  - `tracing.max_buffer_size`：缓冲区上限（默认 100 条）
  - `tracing.retention_days`：追踪数据保留天数（默认 7 天）
  - `tracing.log_inputs_outputs`：是否记录输入输出（默认 true，生产环境可关闭以节省空间）
  - `debug.reraise_async_errors`：异步槽异常是否重新抛出（默认 false）
  - `debug.show_devtools_panel`：是否显示调试面板（默认 true）

---

### 1.5.13 依赖库

- [ ] **新增依赖**（添加到 `requirements.txt`）：
  - `aiosqlite` - 异步 SQLite 操作
- [ ] **已有依赖复用**：
  - `qasync` - 已在阶段一引入
  - `PyQt6` - 已在阶段一引入

---

### 1.5.14 验收标准

- [ ] **UI 集成验收**：
  - 启动应用后，右栏显示为标签页结构（QTabWidget）
  - 默认显示"对话"标签页
  - 当 `debug.show_devtools_panel` 配置为 true 时，显示"调试"标签页
  - 点击标签页可正常切换
  - 标签页切换时发布 `EVENT_TAB_CHANGED` 事件
- [ ] **功能验收**：
  - 启动应用后，DevToolsPanel 能显示追踪数据
  - 发送一条消息后，能在 DevToolsPanel 看到 LLM 调用的追踪记录
  - 追踪记录包含正确的 trace_id、span_id、耗时、状态
  - 应用关闭后重新打开，历史追踪数据仍然存在
  - 7 天前的追踪数据被自动清理
- [ ] **性能验收**：
  - 追踪记录操作（`record_span`）耗时 < 1ms
  - 追踪系统不影响 LLM 调用的响应时间（< 5% 开销）
  - 内存缓冲区不超过配置的上限
- [ ] **异常处理验收**：
  - 异步槽函数抛出异常时，异常被记录到追踪系统
  - 异常不会导致应用崩溃
  - DevToolsPanel 能高亮显示错误 Span
