# 电路AI设计助理 - 开发流程框架

## 开发策略：垂直切片

本项目采用**垂直切片（Vertical Slice）**开发策略，每个阶段同时开发后端逻辑与对应的UI组件，确保：
- 每个阶段结束时都有可运行、可演示的功能
- UI与业务逻辑同步迭代，避免后期集成问题
- 尽早发现交互设计问题

## 开发阶段总览

```
阶段一：项目骨架与主窗口 ──→ 阶段1.5：可观测性基础设施 ──→ 阶段二：文件管理与编辑
        (1.5周)                    (0.5周)                      (2周)
                                                                  │
                                                                  ▼
阶段三：LLM对话交互 ──→ 阶段四：仿真执行与可视化 ──→ 阶段五：RAG知识检索
        (2周)                    (3周)                    (2周)
                                   │                        │
                                   ↓ [预集成]               │
                           核心流程验证通过                  │
                                                            ▼
阶段六：工具系统与执行框架 ←─────────────────────────────────┘
        (1.5周)
           │
           ▼
阶段七：LangGraph工作流编排 ──→ 阶段八：人机协作与检查点
        (1.5周)                      (1周)
                                       │
                                       ▼
阶段九：端到端集成验证 ──→ 阶段十：元器件商城集成与BOM管理
        (1周)                    (1.5周)
```

> **分阶段预集成策略**：
> - **阶段 1.5**：可观测性基础设施，建立追踪、调试、异常捕获能力
> - **预集成**（阶段四末）：核心流程预集成，验证"LLM→仿真→分析"主线
> - **阶段六至八**：LangGraph 最小集成验证 + 完整集成，添加迭代确认机制、建议选项、错误处理
> - **阶段十**：元器件商城集成，实现元器件查询、BOM分析、SPICE模型自动获取
> 
> 此策略确保：阶段四结束时核心流程可运行，阶段六至八完成后人机协作机制完整可用，阶段十增强设计可制造性验证能力

## 主窗口布局参考

```
┌─────────────────────────────────────────────────────────┐
│ 菜单栏 | 工具栏                                          │
├────────┬──────────────────────────┬─────────────────────┤
│ 左栏   │ 中栏                      │ 右栏                │
│ 10%    │ 60%                       │ 30%                 │
│ 文件   │ 代码编辑器                │ [对话][信息][元器件]│
│ 浏览器 │                           │ ← 标签页切换        │
├────────┴──────────────────────────┴─────────────────────┤
│ 下栏 (20% 高度) - 仿真结果区                             │
├─────────────────────────────────────────────────────────┤
│ 状态栏                                                   │
└─────────────────────────────────────────────────────────┘
```

> **右栏标签页说明**：
> - **对话**：LLM 对话面板，用户与 AI 交互的主界面
> - **信息**：统一信息展示面板（阶段九 9.0 节），整合仿真结果、RAG 检索、元器件搜索、工具执行等输出信息
> - **元器件**：元器件搜索面板（阶段十），提供元器件查询和 BOM 分析功能
> - **调试**：DevTools 调试面板（阶段 1.5），追踪查看器、性能分析、异常监控（开发模式下显示）

---

> **架构设计参考**：启动流程、数据流、事件机制的详细设计见 `4-核心架构设计.md`

---

## 统一管理机制

本项目采用以下统一管理机制，确保各模块间的一致性和可维护性：

| 管理机制 | 核心模块 | 职责 | 所在阶段 |
|----------|----------|------|----------|
| **错误处理** | `error_handler.py` | 错误分类、恢复策略、用户提示 | 阶段一 |
| **异步任务管理** | `async_task_registry.py` | 异步任务注册、状态追踪、取消、同类互斥 | 阶段一 |
| **凭证管理** | `credential_manager.py` | 敏感信息加密存储、按厂商隔离、安全读取 | 阶段一 |
| **配置访问** | `config_manager.py` | 非敏感配置读写、变更通知 | 阶段一 |
| **日志规范** | `logger.py` | 级别规范、敏感过滤、性能日志 | 阶段一 |
| **追踪上下文** | `tracing_context.py` | 追踪 ID 传递、Span 生命周期管理、上下文穿透 | 阶段 1.5 |
| **追踪日志** | `tracing_logger.py` | 内存缓冲、批量写入、定时刷新 | 阶段 1.5 |
| **追踪存储** | `tracing_store.py` | SQLite 持久化、查询、过期清理 | 阶段 1.5 |
| **文件操作** | `file_manager.py` | 统一文件访问、锁定机制、临时文件管理 | 阶段二 |
| **智能文件搜索** | `file_search_service.py` | 模糊搜索、内容搜索、符号搜索、索引管理 | 阶段二 |
| **文件分析** | `file_analyzer.py` | AST解析、符号提取、依赖分析、结构大纲 | 阶段二 |
| **Prompt模板** | `prompt_template_manager.py` | 模板加载、校验、版本控制、输出规范 | 阶段三 |
| **外部服务调用** | `external_service_manager.py` | 重试策略、熔断机制、调用统计 | 阶段三 |
| **Agentic Loop 护栏** | `loop_guardrails.py` | 停滞检测、失败重试限制、迭代警告 | 阶段三 |
| **LLM输出规范** | Prompt模板内嵌指令 | 格式规范、内容分离、风格指导、长度控制 | 阶段三 |
| **国际化（i18n）** | `i18n_manager.py` | 多语言文本管理、语言切换、UI刷新通知 | 阶段一 |
| **迭代历史视图** | `iteration_history_service.py` | 从 SqliteSaver 查询迭代历史，视图投影，历史对比 | 阶段 2.5 |
| **UI 状态** | `ui_state.py` | 纯 UI 状态管理（窗口布局、面板可见性、编辑器状态） | 阶段一 |
| **会话状态** | `session_state.py` | GraphState 的只读投影，供 UI 层读取业务状态 | 阶段一 |
| **状态投影** | `graph_state_projector.py` | GraphState 变更自动投影到 SessionState | 阶段七 |
| **工作流锁定** | `SessionState.workflow_locked` | 运行中禁用危险操作、保护状态一致性（派生自 GraphState.current_node） | 阶段七 |
| **元器件缓存** | `component_cache.py` | 元器件搜索结果缓存、库存信息缓存、过期管理 | 阶段十 |
| **SPICE模型管理** | `model_cache.py` | 已下载模型索引、模型文件管理、缓存清理 | 阶段十 |
| **统一信息展示** | `info_panel_manager.py` | 整合各模块输出信息、卡片式展示、复制导出 | 阶段九 |

> **设计原则**：所有跨模块的共享资源和操作都通过统一管理器进行，禁止直接访问底层API。

### 开发规范速查

在开发具体功能时，请遵循以下统一管理规范：

| 场景 | 规范 | 禁止 |
|------|------|------|
| **读写配置** | 通过 `config_manager.get()/set()` | 直接解析 `config.json` |
| **读写凭证** | 通过 `credential_manager.get_credential()/set_credential()` | 直接解析 `credentials.json` 或在代码中硬编码 API Key |
| **文件操作** | 通过 `file_manager` 的方法 | 直接使用 `open()`、`os.path` |
| **文件搜索** | 通过 `file_search_service` 的方法 | 直接遍历文件系统或使用 `glob` |
| **符号定位** | 通过 `location_service` 的方法 | 直接解析文件查找符号 |
| **记录日志** | 通过 `logger.get_logger()` | 直接使用 `print()` |
| **处理错误** | 通过 `error_handler.handle_error()` | 直接 `try/except` 后静默 |
| **后台任务** | 通过 `async_task_registry` 提交协程 | 直接创建 `QThread` 或 `asyncio.create_task()` |
| **跨组件通信** | 通过 `EventBus` 发布/订阅 | 直接调用其他组件方法 |
| **获取服务** | 通过 `ServiceLocator.get()` | 直接实例化或全局变量 |
| **调用外部API** | 通过 `external_service_manager` | 直接调用 `httpx`/`requests` |
| **加载Prompt** | 通过 `prompt_template_manager` | 直接读取JSON文件 |
| **LLM输出处理** | 用户内容存 `content`，操作记录存 `operations` | 混合存储导致解析困难 |
| **追踪 LLM 调用** | 使用 `TracingContext.span("llm_call", ...)` | 不记录追踪或手动管理 trace_id |
| **追踪工具执行** | 使用 `TracingContext.span("tool_execute", ...)` | 不记录追踪 |
| **LangGraph 节点追踪** | 调用 `TracingContext.restore_from_langgraph(config)` | 忽略上下文恢复 |
| **异步槽函数** | 使用 `@asyncSlot()` + `@safe_async_slot()` | 仅使用 `@asyncSlot()` |
| **元器件查询** | 通过 `component_service` 的方法（阶段十） | 直接调用商城 API |
| **SPICE模型获取** | 通过 `model_downloader` 的方法（阶段十） | 直接下载或手动管理模型文件 |
| **UI文本** | 通过 `i18n_manager.get_text()` | 硬编码中英文字符串 |
| **迭代历史** | 通过 `iteration_history_service` 从 SqliteSaver 查询 | 独立存储 `iteration_history.json` |
| **读取业务状态** | 通过 `SessionState.get()` 只读访问 | 直接读取 GraphState 或修改 SessionState |
| **修改业务状态** | 通过图节点执行，由 GraphStateProjector 自动投影 | 直接修改 SessionState 或 GraphState |
| **检查工作流锁定** | 检查 `SessionState.workflow_locked` | 直接检查 GraphState.current_node |
| **UI 状态管理** | 通过 `UIState.get()/set()` | 将 UI 状态存入 SessionState 或 GraphState |

> **提示**：每次开发新功能前，先确认该功能涉及哪些统一管理机制，确保使用正确的管理器接口。

### AI 开发注意事项

> **重要**：本文档设计用于 AI 大模型按步骤开发。为降低开发风险，AI 在执行每个步骤时必须遵循以下规则：

**三层状态分离原则**：
- **UIState**（Presentation 层）：纯 UI 状态，不影响业务逻辑
- **SessionState**（Application 层）：GraphState 的只读投影，UI 组件只读此层
- **GraphState**（Domain 层）：LangGraph 工作流的唯一真理来源
- **单向数据流**：GraphState → SessionState → UI，禁止反向修改
- UI 组件禁止直接读取或修改 GraphState

**跨阶段依赖检查**：
- 开始新阶段前，必须先读取前置阶段已实现的关键模块源码
- 确认接口签名、返回值类型与文档描述一致
- 若发现偏差，优先修正代码以符合文档设计

**统一管理机制遵循**：
- 每个步骤开始前，检查该步骤涉及哪些统一管理机制
- 禁止绕过管理器直接使用底层 API
- 代码中必须通过 `ServiceLocator.get()` 获取管理器实例
- 延迟获取原则：在类的构造函数 `__init__` 中不应调用 `ServiceLocator.get()`，应在方法首次调用时获取并缓存，避免初始化顺序问题

**LangGraph API 版本**：
- 涉及 LangGraph 的步骤，必须先读取本地 `LangGraph/docs/docs/concepts/` 相关文档
- 禁止依赖 AI 知识库中的旧版 API
- 特别注意：`interrupt()` 函数、`Command(resume=value)`、`add_messages` reducer

**PyQt6 线程安全**：
- Worker 与 UI 通信必须通过信号槽机制
- EventBus 的 handler 必须在主线程执行（使用 `QMetaObject.invokeMethod`）
- 禁止在 Worker 线程中直接操作 UI 组件

**迭代历史查询规则**：
- 迭代历史是 GraphState 历史版本的视图投影，从 SqliteSaver 查询
- 通过 `iteration_history_service.get_iteration_history()` 获取
- 禁止独立存储 `iteration_history.json`，避免双写一致性问题

**循环依赖防范**：
- 类型定义（TypedDict、常量、枚举）应独立于业务逻辑模块，放在专门的类型定义文件中
- 模块间依赖应通过接口（抽象基类、协议）而非具体实现
- 若模块 A 需要调用模块 B，而 B 的初始化又依赖 A 的某些定义，应将共享定义提取到独立模块
- 每完成一个阶段，执行"冷启动测试"：删除所有缓存，从零启动程序，确保初始化顺序正确

**延迟获取原则（重要）**：
- 在 `__init__` 中不调用 `ServiceLocator.get()`，避免初始化顺序问题
- 推荐模式：在方法中首次使用时获取并缓存到实例变量
- 若必须在初始化时获取，使用 `ServiceLocator.get_optional()` 并处理 `None` 情况
- 此原则适用于所有通过 ServiceLocator 获取的服务

**UI 组件初始化时序（重要）**：
- Phase 2.2 创建 MainWindow 时，Phase 3 的服务（如 ContextManager）尚未注册
- 依赖 Phase 3 服务的 UI 组件初始化必须延迟到 `EVENT_INIT_COMPLETE` 事件后执行
- 示例：`ConversationPanel.initialize()` 依赖 `ContextManager`，不能在 `MainWindow.__init__` 中调用
- 正确做法：MainWindow 订阅 `EVENT_INIT_COMPLETE` 事件，在事件处理中调用 `chat_panel.initialize()`
- 错误做法：在 `_connect_panel_signals()` 中直接调用 `chat_panel.initialize()`

**解耦设计原则**：
- **适配层隔离**：当模块 A 依赖外部系统 B（如 LangGraph）时，引入适配层隔离实现细节
  - 示例：`MessageAdapter` 隔离 ContextManager 与 GraphState 的直接依赖
  - 外部系统 API 变化时，只需修改适配层
- **职责拆分**：复杂模块拆分为多个子模块，共享基础逻辑提取到基类
  - 修改一个功能不影响另一个功能
- **ViewModel 模式**：UI 组件不直接依赖数据层，通过 ViewModel 中间层获取数据
  - 示例：`conversation_panel` 通过 `ConversationViewModel` 获取消息
  - 数据格式变化时，只需修改 ViewModel，不影响 UI 组件

---

## 并发模型架构

> **⚠️ 核心设计决策**：本项目采用**单一事件循环 + 进程隔离**的并发模型，避免 asyncio 与 QThread 混用导致的死锁和竞态条件。

### 执行上下文分类

本项目的所有代码运行在以下三种执行上下文之一，**严禁混用**：

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        主进程 (Main Process)                             │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │              融合事件循环 (qasync: Qt + asyncio)                    │  │
│  │                                                                   │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐               │  │
│  │  │ UI 渲染     │  │ I/O 协程    │  │ 信号槽      │               │  │
│  │  │ (QWidget)   │  │ (LLM/网络)  │  │ (EventBus)  │               │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘               │  │
│  │                    协作式调度，无跨线程通信                         │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │              QThreadPool (CPU 密集型任务)                          │  │
│  │  - 大文件哈希计算                                                  │  │
│  │  - FFT 后处理                                                      │  │
│  │  - 嵌入向量批量计算                                                │  │
│  │  通过 QRunnable 提交，结果通过信号返回主线程                        │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    │ subprocess / QProcess
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        子进程 (Subprocess)                               │
│  - ngspice 仿真引擎                                                     │
│  - Python 沙箱执行（RestrictedPython）                                  │
│  完全隔离，通过 stdout/stderr 或文件交换数据                             │
└─────────────────────────────────────────────────────────────────────────┘
```

### 任务类型与执行上下文映射

| 任务类型 | 执行上下文 | 实现方式 | 示例 |
|----------|------------|----------|------|
| **I/O 密集型** | 主线程协程 | `async/await` + qasync | LLM API 调用、文件读写、网络请求 |
| **CPU 密集型** | QThreadPool | `QRunnable` + 信号返回 | 文件哈希、FFT、向量计算 |
| **外部进程** | 子进程 | `QProcess` / `subprocess` | ngspice 仿真、Python 沙箱 |
| **UI 更新** | 主线程 | 直接调用或信号槽 | 所有 QWidget 操作 |

### 禁止的模式

1. **禁止在 QThread 中运行 asyncio 循环**：会导致双循环同步问题
2. **禁止在协程中执行 CPU 密集计算**：会阻塞事件循环，导致 UI 卡顿
3. **禁止跨线程直接访问共享状态**：必须通过信号槽或线程安全队列
4. **禁止在非主线程操作 QWidget**：PyQt6 的 UI 组件非线程安全

### 相关模块

| 模块 | 文件路径 | 职责 |
|------|----------|------|
| 异步运行时 | `shared/async_runtime.py` | qasync 事件循环初始化 |
| 任务注册表 | `shared/async_task_registry.py` | 异步任务注册、状态追踪、取消 |
| CPU 任务执行器 | `shared/cpu_task_executor.py` | QThreadPool 封装，CPU 密集型任务调度 |
| 事件节流器 | `shared/event_throttler.py` | 高频事件聚合，防止 EventBus 拥塞 |

---

## 阶段一：基础设施与应用框架 (1.5周)

> **目标**：搭建项目基础结构，实现可启动的主窗口框架，完成配置管理
> 
> **启动流程**：完成 Phase 0-2，建立ServiceLocator和EventBus骨架

> **⚠️ 本阶段统一管理提示**：
> - 本阶段建立核心管理器（ConfigManager、ErrorHandler、AsyncTaskRegistry、I18nManager）
> - 所有后续阶段的模块都应通过 ServiceLocator 获取这些管理器
> - UI 组件必须实现 `retranslate_ui()` 方法并订阅 `EVENT_LANGUAGE_CHANGED`

### 1.1 项目初始化

#### 1.1.1 创建项目目录结构
- [ ] 按照 `2-项目文件结构.md` 创建完整的四层目录骨架
- [ ] 在每个包目录下创建 `__init__.py`
- [ ] 创建 `resources/` 资源目录结构
- [ ] 目录结构：
  ```
  circuit_design_ai/
  ├── main.py                    # 程序入口（调用 bootstrap）
  ├── presentation/
  ├── application/
  │   └── bootstrap.py           # 启动引导器
  ├── domain/
  ├── infrastructure/
  └── resources/                 # UI 资源文件
      ├── icons/                # SVG 图标
      │   ├── toolbar/         # 工具栏图标（24x24）
      │   ├── menu/            # 菜单图标（16x16）
      │   ├── panel/           # 面板图标（20x20）
      │   ├── status/          # 状态图标（16x16）
      │   └── file/            # 文件类型图标（16x16）
      ├── styles/               # QSS 样式表
      │   └── main.qss         # 主样式表
      ├── i18n/                 # 国际化文本文件
      │   ├── en_US.json       # 英文文本
      │   └── zh_CN.json       # 简体中文文本
      ├── prompts/              # 内置 Prompt 模板（首次运行时复制到全局配置目录）
      │   ├── task_prompts.json           # 任务级提示词模板
      │   ├── output_format_prompts.json  # 输出格式规范模板
      │   └── version.json                # 模板版本信息
      └── resources.qrc         # Qt 资源文件
  ```

#### 1.1.2 配置 `requirements.txt` 依赖
- [ ] 核心依赖清单：
  - `PyQt6` - GUI框架
  - `PySpice` - 电路仿真
  - `chromadb` - 向量数据库
  - `langgraph` - 工作流编排（**⚠️ 注意版本兼容性，参考本地 `LangGraph/` 项目**）
  - `langgraph-checkpoint-sqlite` - SQLite 持久化（**⚠️ 独立包，需单独安装**）
  - `langchain-core` - LangChain 核心（langgraph 依赖）
  - `sentence-transformers>=3.3.0` - 文本向量化（**⚠️ 需 3.3.0+ 以支持 ModernBERT**）
  - `transformers>=4.48.0` - HuggingFace 模型加载（**⚠️ 需 4.48.0+ 以支持 ModernBERT 架构**）
  - `PyMuPDF` - PDF 文档处理（文本提取、页面渲染）
  - `python-docx` - Word 文档读取（.docx 格式）
  - `matplotlib` - 图表生成
  - `tiktoken` - OpenAI tokenizer
  - `httpx` - HTTP客户端（LLM API调用）
  - `cryptography` - API密钥加密
  - `watchdog` - 文件系统监听
  - `markdown` - Markdown 转 HTML（对话面板渲染）
  - `qasync` - Qt 与 asyncio 事件循环融合
  - `aiosqlite` - 异步 SQLite 操作（追踪系统使用）
  - `rapidfuzz` - 高性能模糊匹配（文件搜索使用）
- [ ] **LangGraph 相关说明**：
  - 本地参考项目：`LangGraph/` 包含最新源码和文档
  - API 可能与 AI 知识库中的旧版本不同，实现时务必参考本地项目
- [ ] **内嵌仿真引擎**：ngspice 二进制文件随软件分发，用户无需手动安装（详见 1.1.5）

#### 1.1.3 配置 `.gitignore`
- [ ] 忽略项：
  - `__pycache__/`, `*.pyc`
  - `.circuit_ai/` - 工作文件夹的系统目录
  - `~/.circuit_design_ai/` - 全局配置（含API密钥）
  - `*.sqlite3` - 检查点数据库
  - `.env` - 环境变量

#### 1.1.4 创建 `main.py` 入口与 `bootstrap.py` 启动引导器

> **单一职责设计**：为避免 main.py 职责过载，将初始化逻辑提取到独立的 `application/bootstrap.py` 模块中。

**`main.py` - 程序入口**
- [ ] **职责**：仅作为程序入口点，调用 bootstrap 启动应用
- [ ] **核心逻辑**：导入并调用 `application.bootstrap.run()` 函数
- [ ] **设计原则**：保持极简，不包含任何初始化逻辑

**`application/bootstrap.py` - 应用启动引导器**
- [ ] **职责**：集中管理所有初始化逻辑，协调各组件的启动顺序
- [ ] **核心功能**：
  - `run()` - 主启动函数，执行完整初始化流程并进入事件循环
  - `_init_phase_0()` - 基础设施初始化
  - `_init_phase_1()` - 核心管理器初始化
  - `_init_phase_2()` - GUI 框架初始化
  - `_delayed_init()` - 延迟初始化
- [ ] **统一管理机制初始化顺序**（严格按此顺序执行）：

> **说明**：此处定义完整的初始化蓝图，`bootstrap.py` 骨架版仅实现调用框架。各组件在后续步骤（1.2-1.5）中逐一实现，实现后回填到 `bootstrap.py` 的对应 Phase 中。
  ```
  Phase 0: 基础设施初始化（同步，阻塞式）
  ├─ 0.0 全局配置目录初始化
  │      ├─ 创建 ~/.circuit_design_ai/ 目录（若不存在）
  │      ├─ 创建 ~/.circuit_design_ai/logs/ 目录
  │      ├─ 创建 ~/.circuit_design_ai/prompts/system/ 目录
  │      ├─ 创建 ~/.circuit_design_ai/prompts/custom/ 目录
  │      └─ 复制内置 Prompt 模板到 prompts/system/（若不存在或版本更新）
  ├─ 0.1 Logger 初始化（最先，其他模块都需要日志）
  │      └─ 调用 logger.setup_logger()，配置控制台和文件输出
  ├─ 0.2 ServiceLocator 初始化（创建空容器）
  │      └─ 调用 ServiceLocator.instance()，确保单例存在
  └─ 0.3 EventBus 初始化（创建事件总线）
         └─ 创建 EventBus 实例并注册到 ServiceLocator
  
  Phase 1: 核心管理器初始化（同步，阻塞式）
  ├─ 1.0 CredentialManager 初始化
  │      ├─ 依赖：Logger（记录凭证操作日志）
  │      ├─ 加载 ~/.circuit_design_ai/credentials.json
  │      ├─ 初始化加密密钥（派生自机器标识）
  │      └─ 注册到 ServiceLocator
  ├─ 1.1 ConfigManager 初始化
  │      ├─ 依赖：Logger、CredentialManager（获取凭证）
  │      ├─ 加载 ~/.circuit_design_ai/config.json
  │      ├─ 缺失字段使用 settings.py 默认值
  │      ├─ 校验失败时记录日志并使用安全默认
  │      └─ 注册到 ServiceLocator
  ├─ 1.2 ErrorHandler 初始化
  │      ├─ 依赖：Logger、EventBus、ConfigManager（读取错误提示配置）
  │      ├─ 初始化错误分类规则和恢复策略
  │      └─ 注册到 ServiceLocator
  ├─ 1.3 I18nManager 初始化
  │      ├─ 依赖：ConfigManager（读取 language 配置）
  │      ├─ 从 resources/i18n/ 加载语言文件
  │      └─ 注册到 ServiceLocator
  ├─ 1.5 ModelRegistry 初始化
  │      ├─ 依赖：Logger（记录模型注册日志）
  │      ├─ 调用 ModelRegistry.initialize()
  │      ├─ 加载内置模型配置（zhipu_models.py 等）
  │      └─ 作为单例类，无需注册到 ServiceLocator
  └─ 1.6 TracingStore 初始化（阶段 1.5 实现）
         ├─ 依赖：Logger
         ├─ 初始化 SQLite 数据库连接（~/.circuit_design_ai/traces.sqlite3）
         ├─ 创建表结构（若不存在）
         ├─ 清理过期追踪数据（默认 7 天）
         └─ 注册到 ServiceLocator
  
  Phase 2: GUI 框架初始化（同步，阻塞式）
  ├─ 2.0.1 预导入 WebEngine（必须在 QApplication 创建之前）
  │      ├─ 导入 `PyQt6.QtWebEngineWidgets.QWebEngineView`
  │      ├─ 原因：PyQt6-WebEngine 要求在 QCoreApplication 实例化之前导入
  │      └─ 若导入失败，记录警告日志，LaTeX 渲染功能降级
  ├─ 2.1 创建 QApplication 实例
  │      └─ 加载 QSS 样式表（resources/styles/main.qss）
  ├─ 2.2 创建 MainWindow 实例
  │      ├─ 依赖：ServiceLocator（获取 I18nManager 等）
  │      ├─ 仅创建布局骨架，不加载数据
  │      ├─ 初始化 UIState（纯 UI 状态容器）
  │      └─ 订阅 EVENT_LANGUAGE_CHANGED 事件
  ├─ 2.3 调用 MainWindow.show()（立即显示窗口）
  └─ 2.4 使用 QTimer.singleShot(0, _delayed_init) 触发延迟初始化
  
  Phase 3: 延迟初始化（异步，在事件循环中执行）
  ├─ 3.1 AsyncTaskRegistry 初始化
  │      ├─ 依赖：EventBus（任务状态事件）
  │      ├─ 职责：异步任务注册、状态追踪、取消
  │      ├─ 创建任务类型注册表（此时不创建任务实例）
  │      └─ 注册到 ServiceLocator
  ├─ 3.1.1 CpuTaskExecutor 初始化
  │      ├─ 依赖：EventBus
  │      ├─ 职责：CPU 密集型任务执行（QThreadPool）
  │      └─ 注册到 ServiceLocator
  ├─ 3.1.2 TracingLogger 初始化（阶段 1.5 实现）
  │      ├─ 依赖：EventBus、TracingStore
  │      ├─ 职责：追踪日志记录（内存缓冲 + 定时刷新）
  │      ├─ 初始化内存缓冲区
  │      ├─ 启动定时刷新 QTimer（500ms 间隔）
  │      └─ 注册到 ServiceLocator
  ├─ 3.2 FileManager 初始化（阶段二实现，此处预留）
  │      ├─ 依赖：Logger、EventBus
  │      └─ 注册到 ServiceLocator
  ├─ 3.3 ProjectService 初始化
  │      ├─ 依赖：FileManager、EventBus
  │      └─ 注册到 ServiceLocator
  ├─ 3.3.1 StopController 初始化
  │      ├─ 依赖：Logger、EventBus
  │      ├─ 职责：全局停止状态管理，协调各层组件的停止操作
  │      ├─ 初始化停止状态为 IDLE
  │      └─ 注册到 ServiceLocator
  ├─ 3.4 ContextManager 初始化
  │      ├─ 依赖：Logger、EventBus
  │      ├─ 职责：管理对话消息、Token 监控、上下文压缩（不含会话管理）
  │      └─ 注册到 ServiceLocator
  ├─ 3.5 SessionState 初始化
  │      ├─ 依赖：EventBus
  │      ├─ 职责：GraphState 的只读投影，供 UI 层读取业务状态
  │      ├─ 初始化所有状态字段为默认值
  │      └─ 注册到 ServiceLocator
  ├─ 3.6 GraphStateProjector 初始化
  │      ├─ 依赖：SessionState、EventBus
  │      ├─ 职责：监听 GraphState 变更，自动投影到 SessionState
  │      └─ 注册到 ServiceLocator
  ├─ 3.7 OllamaService 初始化（本地模型支持）
  │      ├─ 依赖：Logger、EventBus、ConfigManager
  │      ├─ 异步检测 Ollama 服务状态
  │      ├─ 若服务可用，获取已安装模型列表并注册到 ModelRegistry
  │      ├─ 发布 EVENT_OLLAMA_STATUS_CHANGED 事件
  │      └─ 注册到 ServiceLocator
  ├─ 3.8 PromptTemplateManager 初始化
  │      ├─ 依赖：Logger
  │      ├─ 职责：加载和管理 prompts/ 目录下的 Prompt 模板
  │      └─ 注册到 ServiceLocator
  ├─ 3.9 ExternalServiceManager 初始化
  │      ├─ 依赖：Logger、ConfigManager
  │      ├─ 职责：外部服务统一管理（重试、熔断、统计）
  │      └─ 注册到 ServiceLocator
  ├─ 3.10 LLMExecutor 任务类型注册
  │      ├─ 依赖：AsyncTaskRegistry、ExternalServiceManager
  │      └─ 注册 TASK_LLM 任务类型到 AsyncTaskRegistry
  │
  │  ══════════════════════════════════════════════════════════════
  │  以下组件在后续阶段实现，此处定义初始化顺序蓝图
  │  ══════════════════════════════════════════════════════════════
  │
  │  ─── 阶段四：仿真引擎与可视化 ───
  ├─ 3.20 ExecutorRegistry 初始化
  │      ├─ 依赖：Logger
  │      ├─ 职责：管理所有仿真执行器的注册、查询和调度
  │      └─ 注册到 ServiceLocator
  ├─ 3.21 SimulationService 初始化
  │      ├─ 依赖：ExecutorRegistry、EventBus、Logger
  │      ├─ 职责：仿真服务协调中心，两层分离架构
  │      └─ 注册到 ServiceLocator
  ├─ 3.22 SimulationTask 任务类型注册
  │      ├─ 依赖：AsyncTaskRegistry、SimulationService
  │      └─ 注册 TASK_SIMULATION 任务类型到 AsyncTaskRegistry
  ├─ 3.23 SchematicTask 任务类型注册
  │      ├─ 依赖：AsyncTaskRegistry、CpuTaskExecutor、SchematicService
  │      └─ 注册 TASK_SCHEMATIC 任务类型到 AsyncTaskRegistry
  │
  │  ─── 阶段五：RAG知识检索与代码索引 ───
  ├─ 3.30 EmbeddingService 初始化
  │      ├─ 依赖：ConfigManager、EmbeddingModelRegistry
  │      ├─ 职责：嵌入服务门面，管理嵌入模型加载和切换
  │      ├─ 发布 EVENT_EMBEDDING_MODEL_READY 事件
  │      └─ 注册到 ServiceLocator
  ├─ 3.31 VectorStore 初始化
  │      ├─ 依赖：EmbeddingService、ConfigManager
  │      ├─ 职责：向量存储门面，管理向量数据库连接
  │      ├─ 发布 EVENT_VECTOR_STORE_READY 事件
  │      └─ 注册到 ServiceLocator
  ├─ 3.32 CodeIndexer 初始化
  │      ├─ 依赖：VectorStore、EmbeddingService、EventBus
  │      ├─ 职责：代码索引器门面，管理代码文件索引
  │      └─ 注册到 ServiceLocator
  ├─ 3.33 IndexManager 初始化
  │      ├─ 依赖：VectorStore、EmbeddingService、DocumentProcessor、CodeIndexer
  │      ├─ 职责：索引管理器，统一管理文档和代码索引
  │      └─ 注册到 ServiceLocator
  ├─ 3.34 RAGTask 任务类型注册
  │      ├─ 依赖：AsyncTaskRegistry、IndexManager、RetrievalService
  │      └─ 注册 TASK_RAG_INDEX 和 TASK_RAG_SEARCH 任务类型到 AsyncTaskRegistry
  │
  │  ─── 阶段六：工具系统与执行框架 ───
  ├─ 3.40 ToolExecutor 初始化
  │      ├─ 依赖：FileManager、AsyncTaskRegistry、各领域服务
  │      ├─ 职责：工具执行门面，协调工具调用和结果处理
  │      └─ 注册到 ServiceLocator
  │
  │  ─── 阶段七/八：LangGraph 工作流编排 ───
  ├─ 3.50 DesignWorkflow 初始化
  │      ├─ 依赖：AsyncTaskRegistry、EventBus、SessionState、GraphStateProjector、所有图节点
  │      ├─ 职责：工作流编排模块，协调设计流程
  │      ├─ 编译 LangGraph StateGraph
  │      └─ 注册到 ServiceLocator
  │
  │  ══════════════════════════════════════════════════════════════
  │
  ├─ 3.99 发布 EVENT_INIT_COMPLETE 事件
  │      └─ 通知所有订阅者初始化完成
  └─ 3.100 会话恢复（在 EVENT_INIT_COMPLETE 后执行）
         ├─ 读取 sessions.json 获取 current_session_id
         ├─ 若存在当前会话：
         │      ├─ 从 SqliteSaver 恢复 GraphState
         │      ├─ GraphStateProjector 自动投影到 SessionState
         │      ├─ 发布 EVENT_SESSION_CHANGED 事件
         │      └─ UI 组件订阅事件后刷新显示
         └─ 若不存在当前会话：
                ├─ 创建初始 GraphState
                ├─ 生成新会话 ID（格式：YYYYMMDD_HHMMSS）
                └─ 发布 EVENT_SESSION_CHANGED 事件
  ```
- [ ] **初始化失败处理**：
  - Phase 0 Logger 失败：回退到 print() 输出，继续启动
  - Phase 1 CredentialManager 失败：记录日志，凭证功能降级（无法保存/读取凭证）
  - Phase 1 ConfigManager 失败：使用硬编码默认值，弹窗提示
  - Phase 1 ErrorHandler 失败：使用简化错误处理，记录日志
  - Phase 1 I18nManager 失败：使用英文硬编码文本
  - Phase 2 MainWindow 失败：致命错误，弹窗后退出
  - Phase 3 AsyncTaskRegistry 失败：记录日志，功能降级运行
- [ ] **防卡死策略**：
  - Phase 0-2 必须在 500ms 内完成，超时则记录警告
  - Phase 3 的耗时操作（Workers、Graph编译）在事件循环中异步执行
  - 绑定全局异常钩子，未捕获异常写入日志并弹窗提示
- [ ] **依赖**：
  - `main.py` 依赖 `application/bootstrap.py`
  - `bootstrap.py` 依赖 `presentation/main_window.py`、`infrastructure/config/config_manager.py`、`shared/*`

#### 1.1.5 内嵌仿真引擎 (`vendor/ngspice/`)
- [ ] **职责**：将 ngspice 二进制文件随软件分发，用户无需手动安装仿真环境
- [ ] **目录结构**：
  ```
  vendor/ngspice/
  ├── win64/Spice64_dll/        # Windows 64位（DLL 共享库版本）
  │   ├── dll-vs/
  │   │   ├── ngspice.dll       # 核心共享库（PySpice 必需）
  │   │   └── libomp140.x86_64.dll  # OpenMP 依赖库
  │   ├── lib/ngspice/          # 模型库（.cm 和 .osdi 文件）
  │   └── share/ngspice/scripts/ # 启动脚本
  ├── linux64/                  # Linux 64位
  │   └── libngspice.so
  ├── macos/                    # macOS
  │   └── libngspice.dylib
  └── LICENSE                   # ngspice BSD-3-Clause 许可证
  ```
- [ ] **获取方式**：
  - Windows：从 ngspice 官网下载 **DLL 共享库版本**（文件名含 `dll` 字样，如 `ngspice-xx_dll_64.7z`），注意不是命令行版本
  - Linux/macOS：从系统包管理器安装后复制，或自行编译

#### 1.1.6 ngspice 运行时路径配置 (`infrastructure/utils/ngspice_config.py`)

> **⚠️ 关键约束**：此模块必须在任何 PySpice 导入之前执行，否则 PySpice 会使用默认路径导致加载失败

- [ ] **职责**：在程序启动时配置 ngspice 共享库路径，确保 PySpice 能正确加载内嵌的 ngspice
- [ ] **核心功能**：
  - `configure_ngspice()` - 配置 ngspice 路径，必须在导入 PySpice 之前调用
  - `get_ngspice_path()` - 获取当前平台的 ngspice 基础目录路径（Spice64_dll 目录）
  - `get_ngspice_lib_path()` - 获取 lib/ngspice 目录路径（codemodel 和 OSDI 文件）
  - `get_ngspice_models_path()` - 获取 share/ngspice/models 目录路径（cmp/sub/custom）
  - `get_ngspice_scripts_path()` - 获取 share/ngspice/scripts 目录路径（spinit 模板）
  - `is_ngspice_available()` - 检查 ngspice 是否可用
  - `get_configuration_error()` - 获取配置错误信息
  - `get_ngspice_info()` - 获取 ngspice 配置的详细信息（用于调试）
- [ ] **路径层级说明**：
  ```
  ngspice_path (基础目录，由 get_ngspice_path() 返回)
  └── vendor/ngspice/win64/Spice64_dll/
      ├── dll-vs/                    # DLL 文件目录
      │   ├── ngspice.dll
      │   └── libomp140.x86_64.dll
      ├── lib/ngspice/               # get_ngspice_lib_path() 返回
      │   ├── analog.cm              # codemodel 文件
      │   ├── digital.cm
      │   └── *.osdi                 # OSDI 模型
      └── share/ngspice/
          ├── models/                # get_ngspice_models_path() 返回
          │   ├── cmp/               # 基础器件模型参数
          │   ├── sub/               # 子电路定义
          │   └── custom/            # 用户自定义模型
          └── scripts/               # get_ngspice_scripts_path() 返回
              └── spinit             # 初始化脚本模板
  ```
- [ ] **路径配置策略**：
  - 检测操作系统类型（`platform.system()`）
  - 判断运行环境（开发环境 vs PyInstaller 打包环境）
  - 开发环境：使用 `vendor/ngspice/{platform}/Spice64_dll/` 相对路径
  - 打包环境：使用 `sys._MEIPASS` 临时目录下的相同相对路径
  - 所有路径函数返回 `Path` 对象，调用方可按需转换为字符串
- [ ] **环境变量设置**：
  - 将 DLL 目录添加到 `PATH` 环境变量（Windows）
  - 设置 `SPICE_LIB_DIR` 指向 lib/ngspice 目录（codemodel 文件）
  - 设置 `SPICE_SCRIPTS` 指向脚本目录（spinit 文件位置）
  - 设置 `NGSPICE_LIBRARY_PATH` 指向共享库文件路径
- [ ] **PySpice 路径覆盖**：
  - 修改 `NgSpiceShared.LIBRARY_PATH` 指向 DLL 文件路径
- [ ] **与仿真模块的协作**（阶段四实现）：
  - `PathPreprocessor`：调用 `get_ngspice_models_path()` 将 .include/.lib 语句中的相对路径转换为绝对路径
  - 本模块负责路径检测和环境变量设置
  - spinit 文件使用相对路径（仅文件名），ngspice 自动在 SPICE_LIB_DIR 中查找 codemodel 和 OSDI 文件
- [ ] **调用时机**：
  - 在 `bootstrap.py` 的最开始调用，位于所有其他导入之前
  - 确保在 Phase 0 基础设施初始化之前完成
- [ ] **回退机制**：
  - 若内嵌版本路径不存在，尝试使用系统已安装的 ngspice
  - 若均失败，记录错误日志并设置标志位，后续仿真功能降级提示用户
- [ ] **被调用方**：`bootstrap.py`（启动引导器最开始）、`PathPreprocessor`（阶段四）

#### 1.1.7 打包分发配置

> **设计目标**：确保使用 PyInstaller 打包后，ngspice 文件随应用分发，用户无需额外安装

- [ ] **职责**：定义打包配置和运行时资源定位策略
- [ ] **PyInstaller 配置**：
  - 使用 `--add-data` 参数将 `vendor/ngspice/` 目录包含进打包文件
  - Windows 示例：`--add-data "vendor/ngspice;vendor/ngspice"`
  - 确保以下目录都被包含：
    - `dll-vs/` - DLL 文件（ngspice.dll、libomp140.x86_64.dll）
    - `lib/ngspice/` - codemodel 文件（*.cm）和 OSDI 模型（*.osdi）
    - `share/ngspice/models/` - SPICE 模型库（cmp/sub/custom）
    - `share/ngspice/scripts/` - 脚本目录（spinit 模板）
- [ ] **vendor 目录完整结构**：
  ```
  vendor/ngspice/
  ├── win64/Spice64_dll/              # Windows 64位平台
  │   ├── dll-vs/                     # DLL 文件目录
  │   │   ├── ngspice.dll             # 核心共享库（PySpice 必需）
  │   │   └── libomp140.x86_64.dll    # OpenMP 依赖库
  │   ├── lib/ngspice/                # codemodel 和 OSDI 模型
  │   │   ├── analog.cm               # 模拟器件 codemodel
  │   │   ├── digital.cm              # 数字器件 codemodel
  │   │   ├── spice2poly.cm           # SPICE2 多项式 codemodel
  │   │   ├── table.cm                # 查表 codemodel
  │   │   ├── xtradev.cm              # 扩展器件 codemodel
  │   │   ├── xtraevt.cm              # 扩展事件 codemodel
  │   │   └── *.osdi                  # OSDI 模型文件
  │   └── share/ngspice/
  │       ├── models/                 # SPICE 模型库
  │       │   ├── cmp/                # 基础器件模型参数
  │       │   │   ├── standard.bjt    # BJT 晶体管模型
  │       │   │   ├── standard.mos    # MOSFET 模型
  │       │   │   ├── standard.dio    # 二极管模型
  │       │   │   └── ...
  │       │   ├── sub/                # 子电路定义（运放、稳压器等）
  │       │   │   ├── ADI.lib         # ADI 运放综合库
  │       │   │   ├── LM741.lib       # 741 运放
  │       │   │   ├── TL072.lib       # TL072 运放
  │       │   │   └── ...
  │       │   └── custom/             # 用户自定义模型（预留空目录）
  │       │       └── .gitkeep        # Git 占位文件
  │       └── scripts/
  │           └── spinit              # 初始化脚本（使用相对路径，ngspice 自动在 SPICE_LIB_DIR 中查找）
  ├── linux64/                        # Linux 64位（预留）
  │   └── .gitkeep
  ├── macos/                          # macOS（预留）
  │   └── .gitkeep
  └── LICENSE                         # ngspice BSD-3-Clause 许可证
  ```
- [ ] **.gitkeep 文件说明**：
  - `.gitkeep` 是约定俗成的占位文件，用于让 Git 跟踪空目录
  - Git 本身不跟踪空目录，只跟踪文件
  - `linux64/.gitkeep` 和 `macos/.gitkeep`：为未来跨平台支持预留目录结构
  - `custom/.gitkeep`：为用户自定义模型预留目录
  - 当目录中有实际文件后，可删除对应的 `.gitkeep`
- [ ] **冗余 .gitkeep 清理规则**：
  - 若目录已有实际内容，应删除 `.gitkeep` 避免冗余
  - 例如：`cmp/` 和 `sub/` 目录已有模型文件，不需要 `.gitkeep`
- [ ] **运行时资源定位**：
  - 打包后程序运行时，资源文件解压到 `sys._MEIPASS` 临时目录
  - `ngspice_config.py` 使用 `getattr(sys, '_MEIPASS', None)` 判断是否为打包环境
  - 所有路径获取函数（`get_ngspice_*_path()`）自动处理开发/打包环境差异
  - 模型库路径通过 `PathPreprocessor`（阶段四）解析用户网表中的 .include/.lib 引用
- [ ] **spinit 相对路径方案**：
  - spinit 文件使用相对路径（仅文件名，如 `codemodel analog.cm`）
  - ngspice 自动在 `SPICE_LIB_DIR` 环境变量指向的目录中查找 codemodel 和 OSDI 文件
  - `ngspice_config.py` 在启动时设置 `SPICE_LIB_DIR` 指向正确的 lib/ngspice 目录
  - 此方案确保打包后和开发环境完全一致，无需运行时动态生成 spinit
- [ ] **许可证合规**：
  - ngspice 采用 BSD-3-Clause 许可证，允许二进制分发
  - 在软件"关于"对话框中包含 ngspice 许可证声明
  - 在 `vendor/ngspice/LICENSE` 中保留完整许可证文本
- [ ] **打包命令示例**：
  ```bash
  # Windows PyInstaller 打包命令
  pyinstaller --name "CircuitDesignAI" \
    --add-data "vendor/ngspice;vendor/ngspice" \
    --add-data "vendor/models;vendor/models" \
    --add-data "resources;resources" \
    main.py
  ```

#### 1.1.8 内嵌 AI 模型 (`vendor/models/`)
- [ ] **职责**：将 RAG 所需的嵌入模型和重排序模型预下载到本地，随软件分发，用户无需联网下载
- [ ] **英文索引支持**：
  - 本项目主要处理英文电路设计论文和技术文档
  - 使用英文优化的轻量级模型，平衡性能与存储空间
  - 默认开启高级 RAG 策略（混合检索 + 重排序）
- [ ] **目录结构**：
  ```
  vendor/models/
  ├── embeddings/
  │   └── gte-modernbert-base/  # 英文嵌入模型
  │       ├── config.json
  │       ├── model.safetensors
  │       ├── tokenizer.json
  │       └── tokenizer_config.json
  ├── rerankers/
  │   └── mxbai-rerank-base-v1/  # 重排序模型
  │       ├── config.json
  │       ├── model.safetensors
  │       └── tokenizer.json
  └── LICENSE                   # 模型许可证声明
  ```
- [ ] **预下载方式**：
  - 开发阶段使用 `huggingface-cli download` 命令下载模型到 `vendor/models/` 目录
  - 嵌入模型：`huggingface-cli download Alibaba-NLP/gte-modernbert-base --local-dir vendor/models/embeddings/gte-modernbert-base`
  - 重排序模型：`huggingface-cli download mixedbread-ai/mxbai-rerank-base-v1 --local-dir vendor/models/rerankers/mxbai-rerank-base-v1`
- [ ] **浏览器下载链接**（若命令行下载失败）：
  - 嵌入模型：https://huggingface.co/Alibaba-NLP/gte-modernbert-base/tree/main
  - 重排序模型：https://huggingface.co/mixedbread-ai/mxbai-rerank-base-v1/tree/main
  - 下载后解压到对应的 `vendor/models/` 子目录
- [ ] **模型选择说明**：
  - `Alibaba-NLP/gte-modernbert-base`：英文嵌入模型（2024 最新），768 维，149M 参数，约 600MB
    - 基于 ModernBERT 架构，支持 8192 长上下文
    - MTEB 英文排行榜 64.38 分，BEIR 55.33 分
    - 适合英文技术文档和代码检索（CoIR 79.31 分）
  - `mixedbread-ai/mxbai-rerank-base-v1`：重排序模型，110M 参数，约 440MB
    - 基于 DeBERTa-v3 架构，支持 512 tokens 上下文
    - 原生支持 sentence-transformers CrossEncoder API
    - 在 BEIR 基准上表现优秀，平衡性能与存储空间
    - 默认开启
- [ ] **许可证合规**：
  - GTE 嵌入模型采用 Apache 2.0 许可证
  - mxbai-rerank 模型采用 Apache 2.0 许可证
  - 在 `vendor/models/LICENSE` 中保留模型许可证声明
  - 在软件"关于"对话框中包含模型来源说明（Alibaba-NLP、mixedbread-ai）
- [ ] **依赖库版本要求**：
  - `transformers>=4.48.0`：ModernBERT 架构需要较新版本的 transformers 库支持
  - `sentence-transformers>=3.3.0`：需要新版本以正确加载 ModernBERT 模型
  - ChromaDB 无需修改：模型输出维度为 768，与常用的 bge-base 相同
- [ ] **分块策略优化**：
  - ModernBERT 支持 8192 tokens 长上下文，相比传统模型的 512 tokens 有显著提升
  - 建议将 `DEFAULT_CHUNK_SIZE` 从 500-800 提升至 1000-2000 tokens
  - 更大的分块能包含更完整的电路功能描述（如完整的 .subckt 定义），减少语义被切断

#### 1.1.9 AI 模型运行时路径配置 (`infrastructure/utils/model_config.py`)
- [ ] **职责**：在程序启动时配置 AI 模型路径，确保 sentence-transformers 能正确加载内嵌模型
- [ ] **核心功能**：
  - `configure_models()` - 配置模型路径，设置环境变量
  - `get_embedding_model_path()` - 获取嵌入模型本地路径
  - `get_reranker_model_path()` - 获取重排序模型本地路径
  - `is_model_available(model_type)` - 检查指定模型是否可用
- [ ] **路径配置策略**：
  - 判断运行环境（开发环境 vs PyInstaller 打包环境）
  - 开发环境：使用 `vendor/models/` 相对路径
  - 打包环境：使用 `sys._MEIPASS` 临时目录下的路径
  - 设置 `HF_HOME` 或 `TRANSFORMERS_CACHE` 环境变量指向本地模型目录
- [ ] **加载优先级**：
  - 优先加载 `vendor/models/` 中的本地模型
  - 若本地模型不存在，回退到 HuggingFace 缓存目录
  - 若均不存在，提示用户下载或联网获取
- [ ] **调用时机**：
  - 在 `bootstrap.py` 的 Phase 0 阶段调用
  - 在 ngspice 配置之后、Logger 初始化之前
- [ ] **被调用方**：`bootstrap.py`（启动引导器）、`embeddings.py`（模型加载时）

---

### 1.2 配置管理模块 (`infrastructure/config/`)

#### 1.2.1 `settings.py` - 默认设置常量定义
- [ ] **职责**：定义系统级默认配置值，作为配置缺失时的回退
- [ ] **常量清单**：
  - `DEFAULT_MAX_CHECKPOINTS = 20` - 最大检查点次数
  - `DEFAULT_STAGNATION_THRESHOLD = 3` - 停滞判断阈值
  - `DEFAULT_CONTEXT_LIMIT_RATIO = 0.8` - 上下文占用触发总结的阈值
  - `DEFAULT_TIMEOUT = 60` - LLM API 普通请求超时秒数
  - `DEFAULT_STREAMING = True` - 默认启用流式输出
  - `DEFAULT_CHUNK_SIZE = 1500` - RAG分块大小（tokens，利用 ModernBERT 8192 长上下文优势）
  - `DEFAULT_CHUNK_OVERLAP = 0.1` - 分块重叠比例（10%）
  - `GLOBAL_CONFIG_DIR = "~/.circuit_design_ai/"` - 全局配置目录
  - `WORK_FOLDER_HIDDEN_DIR = ".circuit_ai/"` - 工作文件夹隐藏目录名
  - `DEFAULT_LANGUAGE = "en_US"` - 默认界面语言
  - `SUPPORTED_LANGUAGES = ["en_US", "zh_CN"]` - 支持的语言列表
  - `DEFAULT_EMBEDDING_MODEL = "Alibaba-NLP/gte-modernbert-base"` - 默认嵌入模型（英文）
  - `DEFAULT_RERANKER_MODEL = "mixedbread-ai/mxbai-rerank-base-v1"` - 默认重排序模型
  - `DEFAULT_ENABLE_RERANKING = True` - 默认开启重排序
  - `DEFAULT_RAG_TOP_K = 5` - RAG 检索返回数量
  - `DEFAULT_HYBRID_SEARCH = True` - 默认启用混合检索
  - `VENDOR_MODELS_DIR = "vendor/models/"` - 内嵌模型目录
  - `EMBEDDINGS_MODEL_DIR = "vendor/models/embeddings/"` - 嵌入模型目录
  - `RERANKERS_MODEL_DIR = "vendor/models/rerankers/"` - 重排序模型目录
  - `CREDENTIALS_FILE = "credentials.json"` - 凭证存储文件名
- [ ] **追踪相关常量**（阶段 1.5）：
  - `DEFAULT_TRACING_ENABLED = True` - 默认启用追踪
  - `DEFAULT_TRACING_FLUSH_INTERVAL_MS = 500` - 追踪缓冲区刷新间隔（毫秒）
  - `DEFAULT_TRACING_MAX_BUFFER_SIZE = 100` - 追踪缓冲区上限
  - `DEFAULT_TRACING_RETENTION_DAYS = 7` - 追踪数据保留天数
  - `DEFAULT_TRACING_LOG_INPUTS_OUTPUTS = True` - 是否记录输入输出
  - `DEFAULT_DEBUG_RERAISE_ASYNC_ERRORS = False` - 异步槽异常是否重新抛出
  - `DEFAULT_DEBUG_SHOW_DEVTOOLS_PANEL = True` - 是否显示调试面板
  - `TRACING_DB_FILE = "traces.sqlite3"` - 追踪数据库文件名
- [ ] **凭证类型常量**：
  - `CREDENTIAL_TYPE_LLM = "llm"` - LLM 厂商凭证类型
  - `CREDENTIAL_TYPE_SEARCH = "search"` - 搜索厂商凭证类型
  - `CREDENTIAL_TYPE_EMBEDDING = "embedding"` - 嵌入模型厂商凭证类型
  - `CREDENTIAL_TYPE_COMPONENT = "component"` - 元器件商城凭证类型（阶段十）
- [ ] **模型厂商相关常量**：
  - `LLM_PROVIDER_ZHIPU = "zhipu"` - 智谱 AI（已实现）
  - `LLM_PROVIDER_SILICONFLOW = "siliconflow"` - 硅基流动（多模型聚合平台）
  - `LLM_PROVIDER_DEEPSEEK = "deepseek"` - DeepSeek（占位）
  - `LLM_PROVIDER_QWEN = "qwen"` - 阿里通义千问（占位）
  - `LLM_PROVIDER_OPENAI = "openai"` - OpenAI（占位）
  - `LLM_PROVIDER_ANTHROPIC = "anthropic"` - Anthropic Claude（占位）
  - `LLM_PROVIDER_LOCAL = "local"` - 本地大模型（通过 Ollama 运行）
  - `SUPPORTED_LLM_PROVIDERS = [...]` - 支持的厂商列表（含 local、siliconflow）
  - `DEFAULT_LLM_PROVIDER = ""` - 默认 LLM 提供者（空表示未配置）
- [ ] **本地大模型相关常量**：
  - `DEFAULT_LOCAL_LLM_HOST = "http://localhost:11434"` - Ollama 默认服务地址
  - `DEFAULT_LOCAL_LLM_MODEL = "qwen2.5:7b"` - 默认本地模型（推荐 Qwen2.5 7B）
  - `LOCAL_LLM_CONNECT_TIMEOUT = 5` - 本地服务连接超时秒数
  - `LOCAL_LLM_REQUEST_TIMEOUT = 300` - 本地模型请求超时秒数（本地推理较慢）
  - `LOCAL_LLM_HEALTH_CHECK_INTERVAL = 30` - 健康检查间隔秒数
- [ ] **厂商基础配置字典**（仅包含 UI 显示和厂商级别信息，模型详情从 ModelRegistry 获取）：
  ```python
  PROVIDER_DEFAULTS = {
      "zhipu": {
          "base_url": "https://open.bigmodel.cn/api/paas/v4",
          "default_model": "glm-4.7",
          "supports_web_search": True,  # 厂商专属联网搜索
          "requires_api_key": True,     # 需要 API Key
          "implemented": True,
      },
      "siliconflow": {
          "base_url": "https://api.siliconflow.cn/v1",
          "default_model": "",  # 无默认模型，用户必须手动输入
          "supports_web_search": False,
          "requires_api_key": True,
          "model_input_mode": "text",  # 纯文本输入模式，不使用下拉选择
          "model_name_hint": "从模型广场复制模型名称，如 Qwen/Qwen2.5-72B-Instruct",
          "model_gallery_url": "https://cloud.siliconflow.cn/models",  # 模型广场链接
          "implemented": True,
      },
      "deepseek": {
          "base_url": "https://api.deepseek.com/v1",
          "default_model": "deepseek-chat",
          "supports_web_search": False,
          "requires_api_key": True,
          "implemented": False,
      },
      "local": {
          "base_url": "http://localhost:11434",  # Ollama 默认地址
          "default_model": "qwen2.5:7b",
          "supports_web_search": False,
          "requires_api_key": False,    # 本地模型无需 API Key
          "is_local": True,             # 标识为本地厂商
          "implemented": True,
      },
      # ... 其他厂商类似
  }
  ```
  > **注意**：`models` 列表和 `supports_thinking` 已移至 ModelRegistry，不再在此定义
  > **本地厂商特殊性**：`local` 厂商的 `requires_api_key` 为 False，配置界面不显示 API Key 输入框
  > **硅基流动特殊性**：`model_input_mode: "text"` 表示使用纯文本输入框而非下拉选择，用户从模型广场复制模型名称
- [ ] **深度思考相关默认值**：
  - `DEFAULT_ENABLE_THINKING = True` - 默认开启深度思考（全局开关）
  - `DEFAULT_THINKING_TIMEOUT = 300` - 深度思考模式下的超时秒数
  > **注意**：`max_tokens` 和 `temperature` 等模型特定配置已移至 ModelRegistry
- [ ] **通用联网搜索常量**（Google/Bing，与厂商无关）：
  - `WEB_SEARCH_GOOGLE = "google"` - Google Custom Search（需 API Key + cx）
  - `WEB_SEARCH_BING = "bing"` - Bing Web Search（需 API Key）
  - `SUPPORTED_GENERAL_WEB_SEARCH = [WEB_SEARCH_GOOGLE, WEB_SEARCH_BING]`
- [ ] **搜索厂商凭证字段定义**：
  - Google 凭证字段：`api_key`（必需）、`cx`（搜索引擎 ID，必需）
  - Bing 凭证字段：`api_key`（必需）
- [ ] **嵌入模型厂商相关常量**：
  - `EMBEDDING_PROVIDER_LOCAL = "local"` - 本地嵌入模型（默认，使用内嵌模型）
  - `EMBEDDING_PROVIDER_ZHIPU = "zhipu"` - 智谱嵌入模型（Embedding-3）
  - `EMBEDDING_PROVIDER_OPENAI = "openai"` - OpenAI 嵌入模型（占位）
  - `SUPPORTED_EMBEDDING_PROVIDERS = ["local", "zhipu", "openai"]` - 支持的嵌入模型厂商列表
  - `DEFAULT_EMBEDDING_PROVIDER = "local"` - 默认使用本地嵌入模型
- [ ] **嵌入模型厂商配置字典**：
  ```python
  EMBEDDING_PROVIDER_DEFAULTS = {
      "local": {
          "display_name": "本地模型",
          "default_model": "gte-modernbert-base",
          "requires_api_key": False,
          "is_local": True,
          "implemented": True,
      },
      "zhipu": {
          "display_name": "智谱 AI",
          "base_url": "https://open.bigmodel.cn/api/paas/v4/embeddings",
          "default_model": "embedding-3",
          "requires_api_key": True,
          "is_local": False,
          "implemented": True,
          "dimensions": 2048,  # Embedding-3 输出维度
          "max_tokens": 8192,  # 单次请求最大 token 数
      },
      "openai": {
          "display_name": "OpenAI",
          "base_url": "https://api.openai.com/v1/embeddings",
          "default_model": "text-embedding-3-small",
          "requires_api_key": True,
          "is_local": False,
          "implemented": False,
      },
  }
  ```
- [ ] **嵌入模型相关默认值**：
  - `DEFAULT_EMBEDDING_BATCH_SIZE = 32` - 批量嵌入请求大小
  - `DEFAULT_EMBEDDING_TIMEOUT = 30` - 嵌入 API 请求超时秒数
- [ ] **设计原则**：纯常量定义，无业务逻辑，便于全局引用

#### 1.2.1.1 ModelRegistry 模型注册表（`shared/model_registry.py`）

> **初始化顺序**：Phase 1.5，在 I18nManager 之后初始化
> 
> **设计说明**：ModelRegistry 是所有模型配置的单一信息源（Single Source of Truth），集中管理模型列表、能力标志、Token 限制等信息，避免在多个文件中重复定义。

- [ ] **职责**：作为模型配置的唯一数据源，管理模型和厂商的注册、查询
- [ ] **核心功能**：
  - `initialize()` - 初始化注册表，加载内置模型配置
  - `get_model(model_id)` - 获取模型配置（格式: "provider:model_name"）
  - `list_models(provider_id)` / `list_model_names(provider_id)` - 获取模型列表
  - `get_vision_fallback(model_id)` - 获取视觉回退模型
  - `resolve_model_for_content(model_id, has_images)` - 根据内容类型解析实际使用的模型
  - `refresh_local_models(host)` - 刷新本地模型列表（从 Ollama 服务获取）
  - `get_local_models()` - 获取已缓存的本地模型列表
- [ ] **数据类型**（`shared/model_types.py`）：
  - `ModelConfig` - 模型配置数据类，包含：基础信息（id、provider、name）、能力标志（supports_vision、supports_thinking 等）、Token 限制（context_limit、max_tokens_default、max_tokens_thinking）、深度思考配置（thinking_temperature）、视觉回退（vision_fallback）、是否为本地模型（is_local）
  - `ProviderConfig` - 厂商配置数据类，包含：基础信息、API 端点、默认模型、实现状态、是否需要凭证（requires_api_key）
  - `LocalModelInfo` - 本地模型信息数据类，包含：模型名称、大小、修改时间、参数量估算
- [ ] **模型配置文件**（`infrastructure/llm_adapters/model_configs/zhipu_models.py`）：
  - 定义 `ZHIPU_PROVIDER` 厂商配置和 `ZHIPU_MODELS` 模型列表
  - 当前支持：GLM-4.7（纯文本，200K 上下文/128K 输出）、GLM-4.6V（视觉，128K 上下文/16K 输出）、GLM-4.6V-Flash
- [ ] **本地模型动态发现**：
  - 本地模型列表不预定义，而是从 Ollama 服务动态获取
  - 调用 `GET /api/tags` 接口获取已安装的模型列表
  - 缓存模型列表，避免频繁请求
  - 配置界面提供"刷新模型列表"按钮
  - Ollama 服务不可用时显示友好提示
- [ ] **被调用方**：`model_config_dialog.py`、`zhipu_request_builder.py`、`zhipu_client.py`、`token_counter.py`、`local_llm_client.py`

#### 1.2.1.2 EmbeddingModelRegistry 嵌入模型注册表（`shared/embedding_model_registry.py`）

> **初始化顺序**：Phase 1.5，与 ModelRegistry 同时初始化
> 
> **设计说明**：EmbeddingModelRegistry 是嵌入模型配置的单一信息源，集中管理本地和线上嵌入模型的配置信息，与 LLM 的 ModelRegistry 分离管理。

- [ ] **职责**：作为嵌入模型配置的唯一数据源，管理嵌入模型和厂商的注册、查询
- [ ] **核心功能**：
  - `initialize()` - 初始化注册表，加载内置嵌入模型配置
  - `get_model(model_id)` - 获取嵌入模型配置（格式: "provider:model_name"）
  - `list_models(provider_id)` - 获取指定厂商的模型列表
  - `get_provider(provider_id)` - 获取厂商配置
  - `list_providers()` - 获取所有支持的厂商列表
  - `get_current_model()` - 获取当前配置的嵌入模型
- [ ] **数据类型**（`shared/model_types.py` 扩展）：
  - `EmbeddingModelConfig` - 嵌入模型配置数据类，包含：
    - `id: str` - 模型唯一标识（格式: "provider:model_name"）
    - `provider: str` - 厂商标识
    - `name: str` - 模型名称
    - `display_name: str` - 显示名称
    - `dimensions: int` - 输出向量维度
    - `max_tokens: int` - 单次请求最大 token 数
    - `is_local: bool` - 是否为本地模型
    - `description: str` - 模型描述
  - `EmbeddingProviderConfig` - 嵌入模型厂商配置数据类，包含：
    - `id: str` - 厂商标识
    - `display_name: str` - 显示名称
    - `base_url: str` - API 端点
    - `requires_api_key: bool` - 是否需要 API Key
    - `is_local: bool` - 是否为本地厂商
    - `implemented: bool` - 是否已实现
- [ ] **内置模型配置**：
  - **本地模型**：
    - `local:gte-modernbert-base` - GTE ModernBERT（768维，8192 tokens，默认）
    - `local:bge-small-en-v1.5` - BGE Small（384维，512 tokens，轻量备选）
  - **智谱嵌入模型**：
    - `zhipu:embedding-3` - Embedding-3（2048维，8192 tokens）
    - `zhipu:embedding-2` - Embedding-2（1024维，512 tokens，旧版）
  - **OpenAI 嵌入模型**（占位）：
    - `openai:text-embedding-3-small` - 1536维
    - `openai:text-embedding-3-large` - 3072维
- [ ] **模型配置文件**（`infrastructure/embedding_adapters/model_configs/`）：
  - `local_embedding_models.py` - 本地嵌入模型配置
  - `zhipu_embedding_models.py` - 智谱嵌入模型配置
- [ ] **被调用方**：`embedding_config_dialog.py`、`embedding_service.py`、`vector_store.py`

#### 1.2.2 `credential_manager.py` - 凭证管理器（敏感信息专用）

> **初始化顺序**：Phase 1.0，在 ConfigManager 之前初始化，注册到 ServiceLocator
> 
> **设计说明**：将敏感信息（API Key 等）与普通配置分离，独立管理。每个厂商的凭证独立存储，避免切换厂商时丢失配置或传递给错误厂商。

- [ ] **职责**：专门负责敏感凭证的加密存储、读取和管理
- [ ] **核心功能**：
  - `get_credential(provider_type, provider_id)` - 获取指定厂商的解密凭证
  - `set_credential(provider_type, provider_id, credential_data)` - 加密存储厂商凭证
  - `delete_credential(provider_type, provider_id)` - 删除指定厂商凭证
  - `has_credential(provider_type, provider_id)` - 检查凭证是否存在
  - `list_providers(provider_type)` - 列出已配置凭证的厂商
  - `validate_credential(provider_type, provider_id)` - 校验凭证格式
- [ ] **厂商类型（provider_type）**：
  - `llm` - LLM 厂商（zhipu、siliconflow、deepseek、qwen、openai、anthropic）
  - `search` - 搜索厂商（google、bing）
  - `embedding` - 嵌入模型厂商（zhipu、openai）
- [ ] **存储结构**（`~/.circuit_design_ai/credentials.json`）：
  ```python
  {
    "llm": {
      "zhipu": {
        "api_key": "encrypted_value",
        "updated_at": "2024-01-01T00:00:00Z"
      },
      "siliconflow": {
        "api_key": "encrypted_value",
        "updated_at": "2024-01-01T00:00:00Z"
      },
      "deepseek": {
        "api_key": "encrypted_value",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    "search": {
      "google": {
        "api_key": "encrypted_value",
        "cx": "search_engine_id",
        "updated_at": "2024-01-01T00:00:00Z"
      },
      "bing": {
        "api_key": "encrypted_value",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    "embedding": {
      "zhipu": {
        "api_key": "encrypted_value",
        "updated_at": "2024-01-01T00:00:00Z"
      },
      "openai": {
        "api_key": "encrypted_value",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    }
  }
  ```
- [ ] **加密策略**：
  - 使用 `cryptography.fernet` 对敏感字段进行对称加密
  - 加密密钥派生自机器标识（MAC 地址 + 用户名 + 固定盐值）
  - 仅 `api_key` 字段加密，其他字段（如 `cx`、`updated_at`）明文存储
  - 空值不加密，直接存储空字符串
- [ ] **安全原则**：
  - 凭证文件权限设置为仅当前用户可读写（Unix: 0600）
  - 日志中禁止输出任何凭证内容，仅输出厂商标识
  - 内存中的解密凭证使用后尽快清理（不长期缓存）
- [ ] **被调用方**：`config_manager.py`（获取当前厂商凭证）、`model_config_dialog.py`（保存凭证）

#### 1.2.3 `config_manager.py` - 配置统一访问管理器

> **初始化顺序**：Phase 1.1，依赖 Logger 和 CredentialManager，注册到 ServiceLocator

- [ ] **职责**：提供非敏感配置的统一访问接口，管理配置的读写、校验和变更通知
- [ ] **核心功能**：
  - `load_config()` - 加载配置，缺失字段使用 `settings.py` 默认值
  - `save_config(config_dict)` - 保存配置到JSON文件
  - `get(key, default=None)` - 统一配置读取接口（禁止直接读取JSON）
  - `set(key, value)` - 统一配置写入接口（自动触发变更通知）
  - `get_current_llm_credential()` - 获取当前选中 LLM 厂商的凭证（委托给 CredentialManager）
  - `get_current_search_credential()` - 获取当前选中搜索厂商的凭证（委托给 CredentialManager）
  - `get_current_embedding_credential()` - 获取当前选中嵌入模型厂商的凭证（委托给 CredentialManager）
  - `subscribe_change(key, handler)` - 订阅特定配置项变更
  - `get_all_keys()` - 获取所有配置键列表
- [ ] **配置字段**（`~/.circuit_design_ai/config.json`，不含敏感信息）：
  ```python
  {
    # 通用配置
    "language": str,            # 界面语言（en_US/zh_CN，默认en_US）
    
    # LLM 厂商选择（当前使用的厂商，凭证存储在 credentials.json）
    "llm_provider": str,        # 当前选中的厂商标识（zhipu/siliconflow/deepseek/qwen/openai/anthropic/local）
    "llm_model": str,           # 当前选中的模型名称
    "llm_base_url": str,        # 自定义 API 端点（可选，空则使用厂商默认）
    "llm_timeout": int,         # 普通请求超时秒数（默认60）
    "llm_streaming": bool,      # 是否流式输出（默认True）
    
    # 硅基流动配置（仅当 llm_provider 为 "siliconflow" 时生效）
    "siliconflow_model": str,   # 用户手动输入的模型名称（从模型广场复制，如 Qwen/Qwen2.5-72B-Instruct）
    "siliconflow_base_url": str,  # API 端点（默认 https://api.siliconflow.cn/v1）
    
    # 本地大模型配置（仅当 llm_provider 为 "local" 时生效）
    "local_llm_host": str,      # 本地服务地址（默认 http://localhost:11434）
    "local_llm_model": str,     # 本地模型名称（如 qwen2.5:7b、llama3.1:8b）
    
    # 深度思考配置（仅支持深度思考的厂商/模型显示）
    "enable_thinking": bool,    # 深度思考开关（默认True）
    "thinking_timeout": int,    # 深度思考模式下的超时秒数（默认300）
    
    # 联网搜索配置（厂商专属与通用搜索互斥，只能启用其一）
    "enable_provider_web_search": bool,  # 厂商专属联网搜索开关（默认False，仅支持的厂商可用）
    "enable_general_web_search": bool,   # 通用联网搜索开关（默认False，与厂商专属互斥）
    "general_web_search_provider": str,  # 当前选中的搜索厂商（google/bing）
    
    # 嵌入模型配置（RAG 向量化使用）
    "embedding_provider": str,           # 当前选中的嵌入模型厂商（local/zhipu/openai，默认local）
    "embedding_model": str,              # 当前选中的嵌入模型名称
    "embedding_base_url": str,           # 自定义嵌入 API 端点（可选，空则使用厂商默认）
    "embedding_timeout": int,            # 嵌入 API 请求超时秒数（默认30）
    "embedding_batch_size": int,         # 批量嵌入请求大小（默认32）
  }
  ```
- [ ] **配置与凭证分离原则**：
  - `config.json` 仅存储非敏感的选择和偏好设置
  - 所有 API Key 存储在 `credentials.json`，由 CredentialManager 管理
  - 切换厂商时只修改 `llm_provider`，不影响其他厂商的已保存凭证
  - 用户可以预先配置多个厂商的凭证，随时切换使用
  - **本地模型例外**：`local` 厂商无需凭证，其配置（host、model）直接存储在 `config.json`
- [ ] **统一访问原则**：
  - 所有模块通过 `config_manager.get(key)` 读取非敏感配置
  - 敏感凭证通过 `config_manager.get_current_llm_credential()` 获取
  - 禁止直接解析 `config.json` 或 `credentials.json` 文件
  - 配置变更通过 `set()` 方法，自动触发 `EVENT_STATE_CONFIG_CHANGED` 事件
- [ ] **变更通知机制**：
  - 配置变更时通过EventBus发布事件
  - 支持细粒度订阅（只关注特定配置项变更）
  - 订阅者在主线程接收通知
  - 厂商切换时发布 `EVENT_LLM_PROVIDER_CHANGED` 事件
  - 嵌入模型厂商切换时发布 `EVENT_EMBEDDING_PROVIDER_CHANGED` 事件
- [ ] **校验规则**：
  - 值范围校验（timeout > 0）
  - 类型校验（streaming 必须为 bool）
  - 厂商标识校验（必须在 `SUPPORTED_LLM_PROVIDERS` 列表中）
  - 嵌入模型厂商校验（必须在 `SUPPORTED_EMBEDDING_PROVIDERS` 列表中）
  - 联网搜索互斥校验（`enable_provider_web_search` 和 `enable_general_web_search` 不能同时为 True）
  - 本地模型地址校验（`local_llm_host` 必须是有效的 URL 格式）
  - 嵌入模型 API 端点校验（`embedding_base_url` 若非空必须是有效的 URL 格式）
- [ ] **异常处理**：
  - 文件不存在 → 创建默认配置
  - JSON解析失败 → 记录日志，返回默认配置
  - 字段校验失败 → 返回错误信息，不阻塞启动
- [ ] **失败快速原则**：启动时校验关键配置（超时值范围、厂商标识有效性），无效配置应明确提示而非静默使用默认值
- [ ] **被调用方**：`bootstrap.py`（启动时）、`model_config_dialog.py`（配置界面）、`llm_worker.py`（获取配置）、所有需要读取配置的模块

---

### 1.3 工具函数模块 (`infrastructure/utils/`)

#### 1.3.1 `logger.py` - 统一日志管理器

> **初始化顺序**：Phase 0.1，最先初始化，其他模块都依赖日志

- [ ] **职责**：配置和管理应用日志系统，提供统一的日志规范和敏感信息过滤
- [ ] **核心功能**：
  - `setup_logger(name, level)` - 创建命名日志器
  - `get_logger(name)` - 获取已配置的日志器
  - `log_performance(operation, duration_ms)` - 记录性能日志
  - `log_api_call(provider, endpoint, status)` - 记录API调用日志
  - `sanitize_message(message)` - 过滤敏感信息
- [ ] **日志输出**：
  - 控制台：INFO级别以上，彩色输出
  - 文件：DEBUG级别以上，写入 `~/.circuit_design_ai/logs/app.log`
  - 日志轮转：按大小（10MB）或时间（每天）轮转，保留最近7天
- [ ] **日志格式**：
  ```
  [时间] [级别] [模块名] [线程ID] 消息
  ```
- [ ] **日志级别使用规范**：
  | 级别 | 使用场景 |
  |------|----------|
  | DEBUG | 详细调试信息（变量值、流程跟踪） |
  | INFO | 正常操作记录（用户操作、状态变更） |
  | WARNING | 可恢复的异常情况（重试、降级） |
  | ERROR | 操作失败但不影响系统运行 |
  | CRITICAL | 致命错误，系统无法继续 |
- [ ] **敏感信息过滤规则**：
  - API密钥：替换为 `***REDACTED***`
  - 文件正文内容：仅记录路径和字符数
  - 用户输入：超过100字符截断并标记
  - 仿真数据：仅记录数据点数量，不记录具体值
- [ ] **性能日志格式**：
  ```
  [PERF] operation=llm_call duration=1234ms status=success
  ```
- [ ] **日志清理策略**：
  - 自动清理超过7天的日志文件
  - 单个日志文件超过10MB自动轮转
  - 保留最近5个轮转文件
- [ ] **可观测性原则**：关键路径（LLM 调用、仿真执行、文件操作）必须记录性能日志，便于问题定位和性能优化
- [ ] **被调用方**：所有模块

#### 1.3.2 `json_utils.py` - JSON序列化/反序列化
- [ ] **职责**：提供增强的JSON处理功能，支持特殊类型序列化
- [ ] **核心功能**：
  - `safe_json_loads(text, default=None)` - 安全解析JSON，异常时返回默认值
  - `safe_json_dumps(data, indent=2)` - 安全序列化，处理不可序列化类型
  - `CustomJSONEncoder` - 自定义编码器，支持：
    - `datetime` → ISO格式字符串
    - `Path` → 字符串
    - `numpy.ndarray` → 列表
    - `dataclass` → 字典
- [ ] **被调用方**：`json_repository.py`、`response_parser.py`

---

### 1.4 共享内核模块 (`shared/`)

> **设计说明**：共享内核层包含被所有层依赖的跨层基础设施（服务定位器、事件总线、应用状态、错误处理、Worker管理）。这些组件不属于任何单一层，而是作为整个应用的"神经系统"存在。将其独立为顶级目录 `shared/`，明确其特殊地位，避免依赖方向混乱。

> **⚠️ 循环依赖防范**：共享内核模块是最底层的依赖，其内部模块之间也需要注意依赖方向：
> - `service_names.py`、`event_types.py` 是纯常量定义，不依赖任何其他模块
> - `service_locator.py` 仅依赖 `service_names.py`
> - `event_bus.py` 依赖 `event_types.py`，不依赖 `error_handler.py`
> - `error_handler.py` 依赖 `event_bus.py`，但内部错误处理不能再调用自身
> - `stop_controller.py` 依赖 `event_bus.py`、`event_types.py`，提供全局停止状态管理
> - 其他模块可依赖以上所有，但不能被以上模块反向依赖

#### 1.4.1 `service_locator.py` - 服务定位器

> **初始化顺序**：Phase 0.2，Logger 之后，创建空容器供后续服务注册

- [ ] **职责**：轻量级依赖注入容器，管理服务实例的注册与获取
- [ ] **核心功能**：
  - `register(name, instance)` - 注册服务实例
  - `get(name)` - 获取服务实例
  - `has(name)` - 检查服务是否已注册
  - `clear()` - 清空所有注册（用于测试）
- [ ] **设计原则**：
  - 单例模式，全局唯一实例
  - 启动时注册，运行时只读
  - 服务名使用常量定义，避免字符串硬编码
- [ ] **服务名常量**（在 `service_names.py` 中定义）：
  - `SVC_CREDENTIAL_MANAGER` - 凭证管理器
  - `SVC_CONFIG_MANAGER` - 配置管理器
  - `SVC_FILE_MANAGER` - 文件管理器
  - `SVC_EVENT_BUS` - 事件总线
  - `SVC_APP_STATE` - 应用状态
  - `SVC_PROJECT_SERVICE` - 项目服务
  - `SVC_CONTEXT_MANAGER` - 消息管理器
  - `SVC_SESSION_STATE_MANAGER` - 会话状态管理器
  - `SVC_STOP_CONTROLLER` - 停止控制器（全局停止状态管理）
  - `SVC_DESIGN_WORKFLOW` - 设计工作流
  - `SVC_OLLAMA_SERVICE` - Ollama 服务管理（本地模型）
  - `SVC_EXTERNAL_SERVICE_MANAGER` - 外部服务管理器
  - `SVC_PROMPT_TEMPLATE_MANAGER` - Prompt 模板管理器
  - 等...
- [ ] **初始化顺序安全**：
  - `get(name)` 在服务未注册时抛出明确的 `ServiceNotFoundError`，包含服务名和可能的原因
  - 提供 `get_optional(name)` 方法，服务不存在时返回 `None` 而非抛出异常
  - 调用方应在构造函数外获取服务（方法调用时），避免初始化顺序问题
- [ ] **被调用方**：所有需要跨层访问服务的模块

#### 1.4.2 `event_bus.py` - 事件总线

> **⚠️ 开发前必读**：本步骤涉及线程安全，请先阅读本阶段开头的"AI 开发注意事项"中的"PyQt6 线程安全"部分。

> **初始化顺序**：Phase 0.3，ServiceLocator 之后，创建并注册到 ServiceLocator

- [ ] **职责**：解耦组件间通信，实现发布-订阅模式
- [ ] **类结构**：
  - `EventBus` - 主类，管理订阅和发布
  - `EventBusReceiver(QObject)` - 辅助类，在主线程中执行 handler
- [ ] **核心功能**：
  - `publish(event_type, data=None, source=None)` - 发布事件
  - `publish_critical(event_type, data=None, source=None)` - 发布关键事件（带重试保护）
  - `publish_throttled(event_type, data=None, throttle_ms=50)` - 发布节流事件（高频事件聚合）
  - `subscribe(event_type, handler)` - 订阅事件
  - `unsubscribe(event_type, handler)` - 取消订阅
  - `clear_all()` - 清空所有订阅（用于测试）
  - `set_debug(enabled)` - 设置调试模式
- [ ] **事件优先级分类**：
  - **关键事件（Critical）**：用户交互相关，必须立即处理
    - `EVENT_STOP_REQUESTED`、`EVENT_ITERATION_AWAITING_CONFIRMATION`、`EVENT_WORKFLOW_LOCKED/UNLOCKED`、`EVENT_ERROR_OCCURRED`
    - 使用 `publish_critical()` 发布，带重试保护
  - **普通事件（Normal）**：业务逻辑事件，正常队列处理
    - `EVENT_LLM_COMPLETE`、`EVENT_SIM_COMPLETE`、`EVENT_SESSION_CHANGED` 等
    - 使用 `publish()` 发布
  - **高频事件（Throttled）**：可能产生大量事件，需要节流聚合
    - `EVENT_LLM_CHUNK`、`EVENT_WORKER_PROGRESS`、`EVENT_RAG_INDEX_PROGRESS`
    - 使用 `publish_throttled()` 发布，在指定时间窗口内聚合
- [ ] **高频事件节流机制**：
  - `publish_throttled()` 将事件放入缓冲区，不立即分发
  - 使用 `QTimer` 定期（默认 50ms）刷新缓冲区
  - 同一事件类型在时间窗口内的多次发布合并为一次
  - 合并策略：保留最新的 `data`，或累积（如进度百分比取最大值）
  - 防止 LLM 流式输出 + 仿真进度 + 日志更新同时发生时的事件风暴
- [ ] **诊断方法**：
  - `get_subscriber_count(event_type)` - 获取指定事件的订阅者数量
  - `get_all_event_types()` - 获取所有已订阅的事件类型
  - `get_stats()` - 获取事件总线统计信息（包括节流统计）
- [ ] **线程安全**（关键要求）：
  - 使用 `QMetaObject.invokeMethod` 确保 handler 在主线程执行
  - 支持 `Qt.QueuedConnection` 跨线程投递
  - `publish()` 可从任意线程调用，内部自动切换到主线程
  - handler 函数禁止执行耗时操作，避免阻塞 UI
  - 订阅列表使用 `threading.Lock` 保护，防止并发修改
- [ ] **事件数据结构**：
  ```python
  {
    "type": str,        # 事件类型
    "data": Any,        # 业务数据（发布时传入的数据）
    "timestamp": float, # 发布时间戳
    "source": str,      # 发布者标识（可选）
  }
  ```
- [ ] **事件数据访问规范**：
  - handler 接收的 `event_data` 是完整的事件结构
  - 业务数据应从 `event_data.get("data", {})` 获取
  - 示例：`project_path = event_data.get("data", {}).get("path")`
  - 禁止直接从 `event_data` 获取业务字段（如 `event_data.get("path")`）
- [ ] **异常隔离**（防止单个 handler 影响其他订阅者）：
  - 每个 handler 调用包裹在 `try/except` 中
  - handler 抛出异常时：记录错误日志，继续执行后续 handler
  - 不因单个 handler 失败而中断整个事件分发
- [ ] **关键事件保护**：
  - 定义关键事件列表：`ITERATION_AWAITING_CONFIRMATION`、`WORKFLOW_LOCKED/UNLOCKED`、`ERROR_OCCURRED`
  - 关键事件发布失败时：重试一次，仍失败则记录 CRITICAL 日志
  - 关键事件的 handler 执行超时（>500ms）时记录警告
- [ ] **调试支持**：
  - 可配置事件日志级别
  - 记录事件发布/处理耗时
  - 记录每个 handler 的执行时间，便于定位性能问题
- [ ] **被调用方**：所有需要跨组件通信的模块

#### 1.4.3 `event_types.py` - 事件类型定义
- [ ] **职责**：集中定义所有事件类型常量，纯常量文件，不依赖任何其他模块
- [ ] **事件分类**（按功能模块组织）：
  - 初始化：`EVENT_INIT_PHASE_COMPLETE`, `EVENT_INIT_COMPLETE`
  - UI交互：`EVENT_UI_FILE_SELECTED`, `EVENT_UI_SEND_MESSAGE`, `EVENT_UI_REQUEST_SIMULATION`
  - 状态变更：`EVENT_STATE_PROJECT_OPENED/CLOSED`, `EVENT_STATE_CONFIG_CHANGED`, `EVENT_STATE_ITERATION_UPDATED`
  - Worker：`EVENT_WORKER_STARTED/PROGRESS/COMPLETE/ERROR`
  - LLM：`EVENT_LLM_CHUNK`, `EVENT_LLM_COMPLETE`, `EVENT_LLM_TOOL_CALL`, `EVENT_LLM_CLIENT_REINITIALIZED`
  - 本地模型：`EVENT_OLLAMA_STATUS_CHANGED`, `EVENT_OLLAMA_MODELS_UPDATED`
  - 仿真：`EVENT_SIM_STARTED/COMPLETE/ERROR`, `EVENT_MAIN_CIRCUIT_CHANGED`, `EVENT_CIRCUIT_ANALYSIS_COMPLETE`, `EVENT_SIMULATION_NEED_SELECTION`, `EVENT_SIMULATION_NO_MAIN_CIRCUIT`, `EVENT_EXECUTOR_REGISTERED/UNREGISTERED`
  - RAG：`EVENT_RAG_INDEX_STARTED/PROGRESS/COMPLETE`, `EVENT_RAG_SEARCH_COMPLETE`
  - 上下文压缩：`EVENT_CONTEXT_COMPRESS_REQUESTED/PREVIEW_READY/COMPLETE`
  - 对话管理：`EVENT_CONVERSATION_RESET`, `EVENT_CONVERSATION_UPDATED`, `EVENT_SESSION_CHANGED`
  - **停止控制**：`EVENT_STOP_REQUESTED`, `EVENT_STOP_COMPLETED`, `EVENT_STOP_STATE_CHANGED`
  - 错误处理：`EVENT_ERROR_OCCURRED`, `EVENT_ERROR_RECOVERED`
  - 文件操作：`EVENT_FILE_CHANGED/LOCKED/UNLOCKED`
  - 外部服务：`EVENT_SERVICE_CIRCUIT_OPEN/CLOSE`
  - 国际化：`EVENT_LANGUAGE_CHANGED`
  - 迭代确认：`EVENT_ITERATION_AWAITING_CONFIRMATION`, `EVENT_ITERATION_USER_CONFIRMED`, `EVENT_ITERATION_USER_STOPPED`
  - 设计目标：`EVENT_DESIGN_GOALS_UPDATED`
  - 设计完成：`EVENT_DESIGN_COMPLETED`, `EVENT_DESIGN_ACCEPTED`, `EVENT_DESIGN_STOPPED`
  - 工作流锁定：`EVENT_WORKFLOW_LOCKED`, `EVENT_WORKFLOW_UNLOCKED`
- [ ] **关键事件列表**：定义 `CRITICAL_EVENTS` 列表，包含需要特殊保护的事件（`EVENT_ITERATION_AWAITING_CONFIRMATION`、`EVENT_WORKFLOW_LOCKED/UNLOCKED`、`EVENT_ERROR_OCCURRED`、`EVENT_STOP_REQUESTED`）
- [ ] **事件数据字段详细说明**：
  - `EVENT_STATE_PROJECT_OPENED` 携带数据：
    - `path`: 项目路径
    - `name`: 项目名称
    - `is_existing`: 是否为已有项目（存在 checkpoints.sqlite3）
    - `has_history`: 是否有历史对话和优化记录
    - `status`: 项目状态（ready/degraded）
  - `EVENT_STATE_PROJECT_CLOSED` 携带数据：
    - `path`: 关闭的项目路径
  - `EVENT_STOP_REQUESTED` 携带数据：
    - `task_id`: 被停止的任务 ID
    - `reason`: 停止原因（"user_requested"、"timeout"、"error"、"session_switch"、"app_shutdown"）
    - `timestamp`: 请求时间戳
  - `EVENT_STOP_COMPLETED` 携带数据：
    - `task_id`: 被停止的任务 ID
    - `reason`: 停止原因
    - `partial_result`: 部分结果（若有）
    - `is_partial`: 是否为部分结果
    - `cleanup_success`: 资源清理是否成功
  - `EVENT_STOP_STATE_CHANGED` 携带数据：
    - `old_state`: 旧状态（"idle"、"running"、"stop_requested"、"stopping"、"stopped"）
    - `new_state`: 新状态
    - `task_id`: 相关任务 ID（若有）
  - `EVENT_ITERATION_AWAITING_CONFIRMATION` 携带数据：
    - `iteration`: 当前迭代序号
    - `performance_score`: 当前性能得分
    - `suggested_actions`: 建议选项列表，每项包含 `id`、`label`、`description`、`is_primary`、`is_enabled`、`style`
    - `status_summary`: 状态摘要文本（如"迭代 3 完成，增益 18dB/目标 20dB"）
    - `simulation_success`: 仿真是否成功（用于决定是否显示"修复错误"选项）
    - **说明**：对话面板收到此事件后，追加建议选项消息到对话历史区
  - `EVENT_WORKFLOW_LOCKED` 携带数据：
    - `reason`: 锁定原因（如 "llm_processing"、"simulation_running"）
    - `node_name`: 当前执行的节点名称
  - `EVENT_WORKFLOW_UNLOCKED` 携带数据：
    - `reason`: 解锁原因（如 "checkpoint_reached"、"error_occurred"）
  - `EVENT_DESIGN_COMPLETED` 携带数据：
    - `termination_reason`: 终止原因（"user_accepted"、"goals_satisfied"、"max_checkpoints"、"stagnated"、"user_stopped"）
    - `final_score`: 最终性能得分
    - `checkpoint_count`: 总检查点次数
    - `report_path`: 生成的报告路径（若有）
  - `EVENT_DESIGN_GOALS_UPDATED` 携带数据：
    - `goals`: 更新后的设计目标列表
    - `source`: 更新来源（"dialog" 表示用户通过对话框编辑，"llm" 表示 LLM 提取）
    - `previous_goals`: 更新前的设计目标（用于撤销）
  - `EVENT_LLM_CHUNK` 携带数据：
    - `chunk`: 流式输出的文本片段
    - `type`: 内容类型（"reasoning" 或 "content"）
    - `is_final`: 是否为最后一个片段
  - `EVENT_LLM_CLIENT_REINITIALIZED` 携带数据：
    - `provider`: LLM 厂商 ID（如 "zhipu"）
    - `model`: 模型名称（如 "glm-4-plus"）
    - `source`: 触发来源（如 "model_config_dialog"）
    - **说明**：当用户在模型配置对话框中更改配置并保存后发布，订阅者（如 LLMWorker）收到后应刷新缓存的客户端引用
  - `EVENT_UI_SEND_MESSAGE` 携带数据：
    - `text`: 用户输入的消息文本
    - `attachments`: 附件列表
    - `source`: 消息来源（"input_box" 或 "suggestion_button"）
    - `suggestion_id`: 若来源为建议按钮，则为按钮 ID
  - `EVENT_SESSION_CHANGED` 携带数据（由 SessionStateManager 发布）：
    - `session_name`: 当前会话名称
    - `message_count`: 消息数量
    - `is_new`: 是否为新建会话
    - `action`: 触发动作（"new"、"switch"、"restore"、"rename"、"delete"）
  - `EVENT_CONVERSATION_RESET` 携带数据：
    - `new_session_name`: 新会话名称
  - `EVENT_OLLAMA_STATUS_CHANGED` 携带数据：
    - `status`: 服务状态（"running"、"not_running"、"not_installed"、"error"）
    - `base_url`: Ollama 服务地址
    - `error_message`: 错误信息（若状态为 error）
  - `EVENT_OLLAMA_MODELS_UPDATED` 携带数据：
    - `models`: 模型列表，每项包含 `name`、`size`、`parameter_size`、`modified_at`
    - `count`: 模型数量
- [ ] **命名规范**：`EVENT_{模块}_{动作}`，全大写下划线分隔
- [ ] **扩展说明**：后续阶段可能需要添加新事件类型（如阶段四的 `EVENT_CODE_INDEX_UPDATED`），添加时遵循命名规范并更新 `__all__` 导出列表
- [ ] **被调用方**：`event_bus.py`、所有需要发布或订阅事件的模块

#### 1.4.4 `error_handler.py` - 统一错误处理器

> **初始化顺序**：Phase 1.2，依赖 Logger、EventBus、ConfigManager

- [ ] **职责**：集中管理应用错误的分类、处理、恢复和用户提示
- [ ] **错误分类体系**：
  - **主分类（ErrorCategory）**：`RECOVERABLE`（可自动恢复）、`USER_ACTIONABLE`（需用户操作）、`FATAL`（致命错误）
  - **子分类（ErrorType）**：按模块细分
    - 网络：`NETWORK_TIMEOUT`, `NETWORK_CONNECTION`
    - LLM API：`LLM_AUTH_FAILED`, `LLM_RATE_LIMIT`, `LLM_RESPONSE_PARSE`, `LLM_CONTEXT_OVERFLOW`
    - 仿真：`SIM_SYNTAX_ERROR`, `SIM_CONVERGENCE_DC/TRAN`, `SIM_MODEL_MISSING`, `SIM_NODE_FLOATING`, `SIM_TIMEOUT`, `SIM_NGSPICE_CRASH`
    - 文件：`FILE_NOT_FOUND`, `FILE_PERMISSION`, `FILE_LOCKED`, `FILE_CORRUPTED`
    - 系统：`DISK_SPACE`, `MEMORY_OVERFLOW`
- [ ] **核心功能**：
  - `handle_error(error, context, category)` - 统一错误处理入口
  - `classify_error(error)` - 自动分类错误类型（返回 ErrorCategory 和 ErrorType）
  - `get_recovery_strategy(error_type)` - 获取恢复策略
  - `notify_user(error, level)` - 统一用户提示（状态栏/弹窗）
  - `log_error(error, context)` - 统一错误日志记录
  - `parse_simulation_error(ngspice_output)` - 解析 ngspice 输出，识别具体错误类型
- [ ] **恢复策略（细粒度）**：
  | 错误类型 | 分类 | 恢复策略 |
  |----------|------|----------|
  | `NETWORK_TIMEOUT` | RECOVERABLE | 指数退避重试（最多3次） |
  | `NETWORK_CONNECTION` | RECOVERABLE | 检查网络后重试 |
  | `LLM_AUTH_FAILED` | USER_ACTIONABLE | 提示用户检查 API Key |
  | `LLM_RATE_LIMIT` | RECOVERABLE | 等待后重试，提示升级配额 |
  | `LLM_RESPONSE_PARSE` | RECOVERABLE | 重试或降级处理 |
  | `LLM_CONTEXT_OVERFLOW` | USER_ACTIONABLE | 提示压缩上下文 |
  | `SIM_SYNTAX_ERROR` | USER_ACTIONABLE | 显示错误行号，提示 LLM 修正 |
  | `SIM_CONVERGENCE_DC` | USER_ACTIONABLE | 建议：检查电源连接、添加初始条件、降低精度 |
  | `SIM_CONVERGENCE_TRAN` | USER_ACTIONABLE | 建议：减小时间步长、检查非线性元件 |
  | `SIM_MODEL_MISSING` | USER_ACTIONABLE | 提示缺失的模型名称，建议添加 .model 或 .lib |
  | `SIM_NODE_FLOATING` | USER_ACTIONABLE | 显示浮空节点名，建议添加接地或偏置 |
  | `SIM_TIMEOUT` | RECOVERABLE | 自动降低仿真精度重试一次 |
  | `SIM_NGSPICE_CRASH` | USER_ACTIONABLE | 记录崩溃日志，建议简化电路 |
  | `FILE_NOT_FOUND` | USER_ACTIONABLE | 提示具体路径 |
  | `FILE_PERMISSION` | USER_ACTIONABLE | 提示权限问题和解决方法 |
  | `FILE_LOCKED` | RECOVERABLE | 等待锁释放后重试 |
  | `DISK_SPACE` | USER_ACTIONABLE | 提示清理空间 |
- [ ] **仿真错误解析规则**：通过正则匹配 ngspice 输出关键词，自动识别错误类型（语法错误行号、收敛失败、模型缺失、浮空节点等）
- [ ] **用户提示策略**：
  - `RECOVERABLE` → 状态栏短暂提示，自动恢复
  - `USER_ACTIONABLE` → 非阻塞弹窗，提供操作建议和具体修复步骤
  - `FATAL` → 模态弹窗，记录日志后安全退出
- [ ] **与EventBus集成**：
  - 发布 `EVENT_ERROR_OCCURRED` 事件，携带 `error_type` 和 `recovery_hint`
  - 各模块可订阅特定错误类型
- [ ] **防御性编程原则**：所有外部调用（LLM API、文件系统、仿真引擎）的错误都应通过此模块处理，禁止静默捕获后忽略
- [ ] **循环依赖防护**：
  - ErrorHandler 内部的错误处理不应再调用 `handle_error()`，使用 `_internal_log()` 直接写日志
  - 通过 EventBus 发布错误事件时，若 EventBus 不可用则静默降级
  - 维护 `_is_handling` 标志位，检测并阻止递归调用
  - 内部错误信息使用硬编码英文，不依赖 I18nManager
  - ErrorHandler 不应在 `__init__` 中调用 `ServiceLocator.get()` 获取 EventBus，应在首次处理错误时获取
- [ ] **被调用方**：所有可能产生错误的模块

#### 1.4.5 `async_task_registry.py` - 异步任务注册表

> **⚠️ 架构变更说明**：原 `worker_manager.py` 已重命名为 `async_task_registry.py`，职责从"线程管理器"转变为"异步任务注册表"。所有 I/O 密集型任务通过 qasync 在主线程协程中执行，不再使用 QThread。

> **初始化顺序**：Phase 3.1（延迟初始化），依赖 EventBus，在事件循环中异步执行

- [ ] **文件路径**：`shared/async_task_registry.py`
- [ ] **职责**：管理异步任务的注册、状态追踪、取消，作为任务生命周期的中央协调器
- [ ] **设计原则**：
  - 所有 I/O 密集型任务（LLM 调用、网络请求、文件读写）在主线程的 asyncio 协程中执行
  - 不创建或管理 QThread，避免双循环同步问题
  - 通过 `asyncio.Task` 管理任务生命周期
- [ ] **任务状态枚举 `TaskState`**：
  - `PENDING` - 等待执行
  - `RUNNING` - 执行中
  - `COMPLETED` - 已完成
  - `CANCELLED` - 已取消
  - `FAILED` - 执行失败
- [ ] **任务信息数据类 `TaskInfo`**：
  - `task_id: str` - 任务唯一标识
  - `task_type: str` - 任务类型（如 "llm"、"rag"、"file_watch"）
  - `task: asyncio.Task` - asyncio 任务对象
  - `state: TaskState` - 当前状态
  - `created_at: datetime` - 创建时间
  - `result: Any` - 执行结果（完成时）
  - `error: Optional[Exception]` - 错误信息（失败时）
- [ ] **核心功能**：
  - `register_task_type(task_type, handler_class)` - 注册任务类型和对应的处理器类
  - `submit(task_type, task_id, coro)` - 提交异步任务
  - `cancel(task_id)` - 取消指定任务
  - `cancel_by_type(task_type)` - 取消指定类型的所有任务
  - `cancel_all()` - 取消所有运行中的任务
  - `get_task_state(task_id)` - 获取任务状态
  - `get_running_tasks(task_type=None)` - 获取运行中的任务列表
  - `is_task_running(task_type)` - 检查指定类型是否有任务在运行
- [ ] **任务类型常量**：
  ```python
  TASK_LLM = "llm"                    # LLM 生成任务
  TASK_RAG_INDEX = "rag_index"        # RAG 索引任务
  TASK_RAG_SEARCH = "rag_search"      # RAG 检索任务
  TASK_FILE_WATCH = "file_watch"      # 文件监听任务
  TASK_SIMULATION = "simulation"      # 仿真任务（子进程）
  ```
- [ ] **调度策略**：
  - 同类任务互斥：同一 `task_type` 同时只能有一个任务运行，新任务排队等待
  - 异类任务并行：不同 `task_type` 的任务可同时运行
  - 任务优先级：用户触发的任务优先于自动触发的任务
- [ ] **与 StopController 集成**：
  - 订阅 `EVENT_STOP_REQUESTED` 事件
  - 收到停止信号时调用 `cancel_all()` 取消所有运行中的任务
  - 任务内部通过 `asyncio.CancelledError` 响应取消
- [ ] **与 EventBus 集成**：
  - 任务状态变更发布事件：`EVENT_TASK_STARTED`、`EVENT_TASK_COMPLETED`、`EVENT_TASK_FAILED`、`EVENT_TASK_CANCELLED`
  - 支持外部订阅任务完成/错误事件
- [ ] **被调用方**：`LLMExecutor`、`RAGService`、`SimulationService`、`DesignWorkflow`

#### 1.4.5.1 `cpu_task_executor.py` - CPU 密集型任务执行器

> **初始化顺序**：Phase 3.1.1，依赖 EventBus，在 async_task_registry 之后初始化

- [ ] **文件路径**：`shared/cpu_task_executor.py`
- [ ] **职责**：管理 CPU 密集型任务的执行，使用 QThreadPool 避免阻塞主线程事件循环
- [ ] **适用场景**：
  - 大文件哈希计算（SHA-256）
  - FFT 频谱分析后处理
  - 嵌入向量批量计算
  - 图像处理（电路图渲染）
- [ ] **核心类 `CpuTaskExecutor(QObject)`**：
  - **信号定义**：
    - `task_completed(str, object)` - 任务完成（task_id, result）
    - `task_failed(str, str)` - 任务失败（task_id, error_msg）
    - `task_progress(str, int)` - 任务进度（task_id, percent）
  - **核心方法**：
    - `submit(task_id, callable, *args, **kwargs)` - 提交 CPU 任务
    - `submit_with_progress(task_id, callable, progress_callback)` - 提交带进度回调的任务
    - `cancel(task_id)` - 取消任务（尽力而为，不保证立即停止）
    - `get_pool_stats()` - 获取线程池统计信息
- [ ] **实现方式**：
  - 使用 `QThreadPool.globalInstance()` 获取全局线程池
  - 任务封装为 `QRunnable` 子类
  - 结果通过 `pyqtSignal` 返回主线程
  - 不使用 asyncio，与主线程协程完全隔离
- [ ] **线程池配置**：
  - 最大线程数：`QThread.idealThreadCount()` 或配置值
  - 任务超时：默认 300 秒，可配置
- [ ] **被调用方**：`SnapshotManager`（文件哈希）、`SimulationService`（FFT 后处理）、`EmbeddingService`（向量计算）

#### 1.4.6 三层状态分离架构

> **⚠️ 核心架构决策**：本项目采用三层状态分离架构，彻底解决"多头马车"状态不一致问题。
>
> **设计原则**：
> - **单向数据流**：GraphState → SessionState → UI，禁止反向修改
> - **职责清晰**：每层状态有明确的职责边界，不越界
> - **投影机制**：SessionState 是 GraphState 的只读投影，由 GraphStateProjector 自动同步

```
┌─────────────────────────────────────────────────────────────────┐
│  Layer 1: UIState (presentation/ui_state.py)                    │
│  - 纯 UI 状态：窗口几何、面板可见性、编辑器光标位置              │
│  - 不影响业务逻辑，可随时丢弃重建                                │
│  - Presentation 层内部使用，不跨层传递                           │
└─────────────────────────────────────────────────────────────────┘
                              ↑ 订阅事件
                              │
┌─────────────────────────────────────────────────────────────────┐
│  Layer 2: SessionState (application/session_state.py)           │
│  - 应用级业务状态：项目路径、会话ID、工作模式、工作流锁定        │
│  - 是 GraphState 的"只读投影"，由 GraphStateProjector 同步       │
│  - UI 组件只读此层，不直接访问 GraphState                        │
└─────────────────────────────────────────────────────────────────┘
                              ↑ 自动投影
                              │
┌─────────────────────────────────────────────────────────────────┐
│  Layer 3: GraphState (application/graph/state.py)               │
│  - LangGraph 工作流的唯一真理来源                                │
│  - 文件指针、轻量摘要、流转控制、消息聚合                        │
│  - 由 SqliteSaver 持久化，撤回时通过 initialize_project 重建     │
└─────────────────────────────────────────────────────────────────┘
```

##### 1.4.6.1 `presentation/ui_state.py` - UI 状态容器

> **初始化顺序**：Phase 2.2，在 MainWindow 创建时初始化

- [ ] **文件路径**：`presentation/ui_state.py`
- [ ] **职责**：管理纯 UI 状态，不影响业务逻辑
- [ ] **设计原则**：
  - 仅存储 UI 展示相关的临时状态
  - 可随时丢弃重建，不需要持久化
  - 不跨层传递，仅 Presentation 层内部使用
- [ ] **状态字段**：
  - `window_geometry: QRect` - 窗口位置和大小
  - `panel_visibility: Dict[str, bool]` - 各面板可见性
  - `current_tab: str` - 右栏当前选中的标签页
  - `editor_cursor_positions: Dict[str, int]` - 各文件的光标位置
  - `editor_scroll_positions: Dict[str, int]` - 各文件的滚动位置
  - `input_draft: str` - 对话输入框草稿内容
  - `is_generating: bool` - 是否正在生成（控制发送/停止按钮显示）
  - `init_phase: int` - 启动阶段跟踪
  - `init_complete: bool` - 初始化是否完成
- [ ] **核心方法**：
  - `get(key, default)` - 获取状态值
  - `set(key, value)` - 设置状态值
  - `save_to_config()` - 保存窗口布局到配置文件
  - `restore_from_config()` - 从配置文件恢复窗口布局
- [ ] **被调用方**：MainWindow、各 Panel 组件

##### 1.4.6.2 `application/session_state.py` - 会话状态容器

> **初始化顺序**：Phase 3.5，依赖 EventBus，在 GraphStateProjector 之前初始化

> **⚠️ 命名说明：SessionState vs SessionStateManager**：
> - **SessionState**（本节定义）：GraphState 的只读投影，供 UI 层读取业务状态（如 workflow_locked、work_mode、project_root）
> - **SessionStateManager**（阶段三定义）：会话生命周期管理器，负责对话会话的新建、切换、保存、删除等 CRUD 操作
> - 两者职责不同，可以共存：SessionState 投影"业务状态"，SessionStateManager 管理"对话会话"

- [ ] **文件路径**：`application/session_state.py`
- [ ] **职责**：作为 GraphState 的只读投影，供 UI 层读取业务状态
- [ ] **设计原则**：
  - **只读投影**：所有字段由 GraphStateProjector 从 GraphState 同步，禁止直接修改
  - **UI 友好**：提供 UI 层需要的业务状态视图
  - **事件驱动**：状态变更时发布事件，UI 组件订阅响应
- [ ] **状态字段**（全部从 GraphState 投影）：
  - `project_root: Optional[str]` - 当前项目路径
  - `session_id: str` - 当前会话 ID
  - `work_mode: str` - 工作模式（"workflow" | "free_chat"）
  - `workflow_locked: bool` - 工作流是否锁定（派生自 current_node）
  - `current_node: str` - 当前执行的节点名称
  - `iteration_count: int` - 迭代次数
  - `checkpoint_count: int` - 检查点计数
  - `active_circuit_file: str` - 当前激活的电路文件路径
  - `last_metrics: Dict` - 最新仿真指标摘要
- [ ] **派生状态**（由投影器计算）：
  - `workflow_locked` = `current_node not in ["", "start", "end", "free_work"]`
  - `is_project_open` = `project_root is not None`
- [ ] **核心方法**：
  - `get(key, default)` - 获取状态值（只读）
  - `subscribe_change(key, handler)` - 订阅状态变更
  - `unsubscribe_change(key, handler)` - 取消订阅
- [ ] **禁止的操作**：
  - 禁止直接调用 `set()` 方法修改状态
  - 禁止在 UI 组件中直接修改 SessionState
  - 所有状态变更必须通过图节点执行后由 GraphStateProjector 同步
- [ ] **被调用方**：所有需要读取业务状态的 UI 组件

##### 1.4.6.3 `application/graph_state_projector.py` - 状态投影器

> **初始化顺序**：Phase 3.6，依赖 SessionState、EventBus

- [ ] **文件路径**：`application/graph_state_projector.py`
- [ ] **职责**：监听 GraphState 变更，自动投影到 SessionState，发布变更事件
- [ ] **设计原则**：
  - 单向数据流的核心组件
  - 自动计算派生状态（如 workflow_locked）
  - 变更时发布细粒度事件，UI 组件按需订阅
- [ ] **核心方法**：
  - `on_graph_state_changed(old_state, new_state)` - GraphState 变更回调
  - `project_field(field_name, old_value, new_value)` - 投影单个字段
  - `compute_derived_state(state)` - 计算派生状态
- [ ] **投影规则**：
  - `session_id` → 直接投影
  - `work_mode` → 直接投影，发布 `EVENT_WORK_MODE_CHANGED`
  - `current_node` → 直接投影，同时计算 `workflow_locked`
  - `circuit_file_path` → 投影为 `active_circuit_file`，发布 `EVENT_ACTIVE_FILE_CHANGED`
  - `last_metrics` → 直接投影，发布 `EVENT_METRICS_UPDATED`
  - `iteration_count` → 直接投影，发布 `EVENT_ITERATION_UPDATED`
- [ ] **工作流锁定计算**：
  - 锁定条件：`current_node not in ["", "start", "end", "free_work"]`
  - 锁定时发布 `EVENT_WORKFLOW_LOCKED`
  - 解锁时发布 `EVENT_WORKFLOW_UNLOCKED`
- [ ] **被调用方**：LangGraph 运行时（图节点执行后）

##### 1.4.6.4 状态变更流程示例

**用户切换电路文件**：
```
[用户在文件浏览器点击 amplifier.cir]
       │
       ↓
[UI 检查 SessionState.workflow_locked]
       │
       ├─ True → 弹窗提示"工作流执行中，无法切换文件"
       │
       └─ False → 发布 EVENT_UI_FILE_SELECTED 事件
              │
              ↓
       [DesignWorkflow 订阅事件，执行 set_active_file 命令]
              │
              ↓
       [图节点返回 {"circuit_file_path": "amplifier.cir"}]
              │
              ↓
       [GraphState 更新]
              │
              ↓
       [GraphStateProjector.on_graph_state_changed() 被调用]
              │
              ↓
       [SessionState.active_circuit_file 更新]
              │
              ↓
       [发布 EVENT_ACTIVE_FILE_CHANGED]
              │
              ↓
       [编辑器面板订阅事件，打开文件]
```

**工作模式切换**：
```
[用户点击模式切换按钮]
       │
       ↓
[UI 检查 SessionState.workflow_locked]
       │
       ├─ True → 按钮禁用，无响应
       │
       └─ False → 发布 EVENT_UI_MODE_SWITCH_REQUESTED
              │
              ↓
       [DesignWorkflow 执行 switch_mode 命令]
              │
              ↓
       [图节点返回 {"work_mode": "workflow"}]
              │
              ↓
       [GraphStateProjector 投影并发布 EVENT_WORK_MODE_CHANGED]
              │
              ↓
       [对话面板订阅事件，更新模式指示器]
```

#### 1.4.7 `i18n_manager.py` - 国际化管理器

> **初始化顺序**：Phase 1.3，依赖 ConfigManager（读取 language 配置）

- [ ] **职责**：统一管理多语言文本和语言切换，从外部 JSON 文件加载文本
- [ ] **核心功能**：
  - `load_language_file(lang_code)` - 从 JSON 文件加载指定语言的文本
  - `get_text(key, default)` - 根据键名获取当前语言的文本
  - `set_language(lang_code)` - 切换语言（触发UI刷新）
  - `get_current_language()` - 获取当前语言代码
  - `get_available_languages()` - 扫描 i18n 目录返回支持的语言列表
  - `reload_texts()` - 重新加载当前语言文件（支持热更新）
- [ ] **支持语言**：
  - `en_US` - 英文（默认启动语言）
  - `zh_CN` - 简体中文
- [ ] **文本文件存储**：
  - 存储位置：`resources/i18n/` 目录
  - 文件格式：JSON
  - 文件命名：`{lang_code}.json`（如 `en_US.json`、`zh_CN.json`）
  - 详细设计见 1.5.5 节
- [ ] **文本键命名规范**：
  - 按模块分组：`menu.*`、`btn.*`、`dialog.*`、`status.*`、`error.*`、`panel.*`
  - 使用点号分隔层级
  - 全小写，单词间用下划线
- [ ] **语言切换流程**：
  1. 用户点击菜单栏"语言"菜单，选择目标语言
  2. `MenuManager` 调用 `i18n_manager.set_language(lang_code)`
  3. 加载对应的 JSON 文件到内存
  4. 更新 `config.json` 中的 `language` 字段
  5. 通过 EventBus 发布 `EVENT_LANGUAGE_CHANGED` 事件
  6. 所有 UI 组件收到事件后调用各自的 `retranslate_ui()` 方法
  7. `MenuManager` 更新语言菜单的勾选状态
- [ ] **配置持久化**：
  - 语言设置保存到 `~/.circuit_design_ai/config.json`
  - 启动时读取配置，若无配置则默认 `en_US`
- [ ] **与 ConfigManager 集成**：
  - 通过 `config_manager.get("language")` 读取语言设置
  - 通过 `config_manager.set("language", lang_code)` 保存语言设置
- [ ] **回退机制**：
  - 若指定语言文件不存在，回退到 `en_US.json`
  - 若键名在当前语言中不存在，返回 default 参数或键名本身
- [ ] **被调用方**：所有表示层组件（`main_window.py`、各面板、各对话框）

---

### 1.5 UI 资源模块 (`resources/`)

> **设计目标**：参考 Cursor、Trae、VS Code 等现代化 IDE 的视觉风格，打造专业、简洁、高效的用户界面。本项目仅实现浅色主题，主色为白色，副色为浅蓝色点缀。

#### 1.5.1 主题配色定义
- [ ] **职责**：定义全局色彩规范，供 QSS 样式表和组件使用
- [ ] **基础色彩**：
  - 主背景：`#ffffff`（纯白）
  - 面板背景：`#f8f9fa`（浅灰白）
  - 边框/分隔线：`#e0e0e0`
  - 主文本：`#333333`
  - 次要文本：`#666666`
- [ ] **强调色（浅蓝色系）**：
  - 主题强调色：`#4a9eff`（浅蓝色，用于按钮、链接、选中状态）
  - 强调色悬停：`#3d8ce6`（深一度浅蓝）
  - 选中高亮背景：`#e3f2fd`（极浅蓝）
  - 悬停高亮背景：`#f0f7ff`（淡蓝白）
- [ ] **状态色**：
  - 成功色：`#4caf50`（绿色）
  - 警告色：`#ff9800`（橙色）
  - 错误色：`#f44336`（红色）
  - 禁用色：`#bdbdbd`（灰色）

#### 1.5.2 `main.qss` - 主样式表
- [ ] **职责**：定义全局 UI 样式，统一管理界面外观
- [ ] **文件位置**：`resources/styles/main.qss`
- [ ] **加载时机**：在 `bootstrap.py` 的 Phase 2.1 阶段加载
- [ ] **加载方式**：通过 `QApplication.setStyleSheet()` 应用全局样式
- [ ] **样式命名规范**：
  - 使用 `objectName` 属性标识特定组件
  - 类选择器用于通用样式（如 `QPushButton`）
  - ID 选择器用于特定组件（如 `#primaryButton`）
- [ ] **字体规范**：
  - 界面字体：系统默认 UI 字体（Segoe UI / SF Pro / Noto Sans）
  - 代码字体：等宽字体（Consolas / JetBrains Mono / Fira Code）
  - 字号：界面 13px，代码 14px，标题 16-18px
- [ ] **组件样式**：
  - 按钮：圆角 4-6px，主按钮填充浅蓝色，次要按钮边框样式
  - 输入框：圆角 4px，聚焦时显示浅蓝色边框
  - 面板标题栏：高度 28-32px，小字号，浅灰背景
  - 分隔线：1px 细线，颜色 `#e0e0e0`
  - 滚动条：细窄样式（6-8px）

#### 1.5.3 SVG 图标资源
- [ ] **职责**：提供矢量图标，不使用 emoji 或位图图标
- [ ] **目录结构**：
  - `resources/icons/toolbar/` - 工具栏图标（24x24）
  - `resources/icons/menu/` - 菜单图标（16x16）
  - `resources/icons/panel/` - 面板图标（20x20）
  - `resources/icons/status/` - 状态图标（16x16）
  - `resources/icons/file/` - 文件类型图标（16x16）
  - `resources/icons/ui/` - UI 控件图标（复选框、下拉框等）
- [ ] **工具栏图标清单**：
  - `folder_open.svg` - 打开文件夹
  - `save.svg` - 保存
  - `save_all.svg` - 全部保存
  - `play.svg` - 自动运行（自动检测主电路后运行）
  - `folder_play.svg` - 选择运行（弹出对话框选择仿真文件）
  - `stop.svg` - 停止
  - `undo.svg` - 撤销
  - `redo.svg` - 重做
- [ ] **对话面板图标清单**（存放于 `resources/icons/panel/`，通过 `get_panel_icon()` 加载）：
  - `image.svg` - 上传图片按钮（16x16）
  - `paperclip.svg` - 附加文件按钮（16x16）
  - `close.svg` - 附件删除按钮（12x12）
  - `plus.svg` - 新建对话按钮（16x16）
  - `history.svg` - 历史对话按钮（16x16）
  - `trash.svg` - 清空对话按钮（16x16）
  - `compress.svg` - 压缩上下文按钮（16x16）
  - `thinking.svg` - 思考过程图标（16x16）
  - `edit.svg` - 编辑会话名称图标（12x12）
  - 所有图标使用本地 SVG 文件，通过 `resource_loader.get_panel_icon()` 加载
- [ ] **文件类型图标**（使用系统图标）：
  - 文件浏览器使用 `QFileSystemModel`，自动调用操作系统的图标提供器
  - 无需手动创建 SVG 图标文件，图标与用户操作系统风格一致
  - 自动支持所有文件类型（包括 .cir、.py、.json、.png 等）
  - 若需为特定文件类型（如 .cir 电路文件）使用自定义图标，可继承 `QFileIconProvider` 实现
- [ ] **UI 控件图标**（存放于 `resources/icons/ui/`）：
  - `checkmark.svg` - 复选框打钩图标（14x14，白色描边）
  - `dropdown.svg` - 下拉框箭头图标（12x12，灰色描边）
  - 用于 Qt 样式表中的 `image: url()` 属性
- [ ] **消息视图图标**（存放于 `resources/icons/panel/` 和 `resources/icons/status/`）：
  - `robot.svg` - AI 助手头像（24x24）
  - `thinking.svg` - 思考过程图标（16x16）
  - `clipboard.svg` - 操作记录图标（16x16）
  - `globe.svg` - 联网搜索图标（16x16）
  - `success.svg` - 成功状态图标（16x16）
  - `progress.svg` - 进行中状态图标（16x16，橙色）
  - `error.svg` - 错误状态图标（16x16）
  - 通过 `_load_svg_icon()` 函数加载，支持后备内联 SVG
- [ ] **命名规范**：小写字母加下划线，格式 `{功能}_{状态}.svg`
- [ ] **颜色规范**：
  - 默认状态：`#666666`（深灰）
  - 激活状态：`#4a9eff`（主题蓝）
  - 禁用状态：`#bdbdbd`（浅灰）
  - 使用 `currentColor` 属性支持动态着色
- [ ] **加载方式**：通过 `QIcon` 加载 SVG 文件

#### 1.5.4 `resources.qrc` - Qt 资源文件
- [ ] **职责**：将图标和样式表打包到应用中
- [ ] **文件位置**：`resources/resources.qrc`
- [ ] **用途**：支持通过 `:/icons/xxx.svg` 路径访问资源
- [ ] **编译方式**：使用 `pyrcc6` 编译为 Python 模块
- [ ] **被调用方**：`bootstrap.py`（加载样式表）、所有 UI 组件（加载图标）

#### 1.5.5 国际化文本文件 (`resources/i18n/`)

> **设计目标**：将 UI 文本从代码中分离，便于翻译人员编辑、支持热加载、便于添加新语言。

- [ ] **职责**：存储各语言的 UI 文本，供 `i18n_manager.py` 加载
- [ ] **目录结构**：
  ```
  resources/i18n/
  ├── en_US.json          # 英文文本（默认语言）
  └── zh_CN.json          # 简体中文文本
  ```
- [ ] **文件格式**：JSON，扁平化键值对结构
- [ ] **JSON 文件结构示例**（`en_US.json`）：
  ```json
  {
    "app.title": "Circuit AI Design Assistant",
    "menu.file": "File",
    "menu.file.open": "Open Workspace",
    "menu.file.close": "Close Workspace",
    "menu.file.save": "Save",
    "menu.file.save_all": "Save All",
    "menu.file.recent": "Recent Projects",
    "menu.file.exit": "Exit",
    "menu.edit": "Edit",
    "menu.edit.undo": "Undo",
    "menu.edit.redo": "Redo",
    "menu.view": "View",
    "btn.save": "Save",
    "btn.send": "Send",
    "btn.cancel": "Cancel",
    "btn.confirm": "Confirm",
    "status.ready": "Ready",
    "status.open_workspace": "Please open a workspace folder",
    "panel.chat": "Chat",
    "panel.simulation": "Simulation Results",
    "dialog.open_workspace.title": "Open Workspace",
    "dialog.error.title": "Error",
    "dialog.confirm.title": "Confirm",
    "dialog.design_goals.title_confirm": "Confirm Design Goals",
    "dialog.design_goals.title_edit": "Edit Design Goals",
    "dialog.design_goals.hint": "The following design goals were extracted from your requirements. Please review and modify if needed.",
    "error.file_not_found": "File not found: {path}",
    "error.permission_denied": "Permission denied: {path}"
  }
  ```
- [ ] **文本键命名规范**：
  - 按模块分组：`app.*`、`menu.*`、`btn.*`、`dialog.*`、`status.*`、`error.*`、`panel.*`
  - 使用点号分隔层级
  - 全小写，单词间用下划线
- [ ] **变量占位符**：
  - 使用 `{variable_name}` 格式
  - 示例：`"error.file_not_found": "File not found: {path}"`
  - 调用时：`i18n_manager.get_text("error.file_not_found", path=file_path)`
- [ ] **添加新语言的步骤**：
  1. 复制 `en_US.json` 为新文件（如 `ja_JP.json`）
  2. 翻译所有文本值，保持键名不变
  3. 在 `settings.py` 的 `SUPPORTED_LANGUAGES` 中添加新语言代码
  4. 重启应用或调用 `i18n_manager.reload_texts()` 生效
- [ ] **热加载支持**：
  - 开发模式下支持修改 JSON 文件后立即生效
  - 调用 `i18n_manager.reload_texts()` 重新加载当前语言文件
  - 生产环境建议禁用热加载以提高性能
- [ ] **被调用方**：`i18n_manager.py`

---

### 1.6 主窗口框架 (`presentation/`)

#### 1.6.1 主窗口模块组

> **模块组设计说明**：主窗口功能复杂，包含布局管理、状态持久化、会话恢复、动作处理等职责。为遵循单一职责原则，将其拆分为多个协作模块：
> - `main_window.py` - 主窗口类，负责布局协调和组件初始化
> - `window_state_manager.py` - 窗口状态管理器，负责窗口位置/尺寸/分割比例的保存与恢复
> - `session_manager.py` - 会话管理器，负责项目路径和打开文件的保存与恢复
> - `action_handlers.py` - 动作处理器集合，负责菜单/工具栏动作的具体实现
>
> 此设计与阶段三的 `conversation_panel` 模块组保持一致的颗粒度，便于测试和维护。

##### 1.6.1.1 `presentation/window_state_manager.py` - 窗口状态管理器

- [ ] **文件路径**：`presentation/window_state_manager.py`
- [ ] **职责**：专注于窗口状态（位置、尺寸、分割比例、面板可见性）的保存与恢复
- [ ] **核心方法**：
  - `__init__(main_window)` - 接收主窗口引用
  - `save_window_state()` - 保存窗口状态到 ConfigManager
  - `restore_window_state()` - 从 ConfigManager 恢复窗口状态
  - `save_splitter_sizes(splitters)` - 保存分割器比例
  - `restore_splitter_sizes(splitters)` - 恢复分割器比例
  - `save_panel_visibility(panels)` - 保存面板可见性
  - `restore_panel_visibility(panels)` - 恢复面板可见性
- [ ] **配置键**：
  - `window_geometry` - 窗口位置和尺寸 `[x, y, width, height]`
  - `splitter_sizes` - 分割器比例 `{"horizontal": [...], "vertical": [...]}`
  - `panel_visibility` - 面板可见性 `{"file_browser": true, ...}`
- [ ] **校验逻辑**：
  - 恢复分割器比例时校验最小尺寸约束
  - 无效数据时使用默认值
- [ ] **被调用方**：`main_window.py`

##### 1.6.1.2 `presentation/session_manager.py` - 会话管理器（presentation 层）

> **设计说明**：presentation 层的 SessionManager 负责两类会话状态的管理：
> - **编辑器会话**：项目路径、打开的文件列表、当前激活文件
> - **对话会话**：委托给 domain 层的 SessionStateManager 处理
>
> 编辑器会话在阶段一实现，对话会话在阶段三通过 SessionStateManager 实现。

- [x] **文件路径**：`presentation/session_manager.py`
- [x] **职责**：专注于编辑器会话状态的保存与恢复，对话会话委托给 SessionStateManager
- [x] **核心方法**：
  - `__init__(main_window, panels)` - 接收主窗口引用和面板字典
  - `save_session_state()` - 保存编辑器会话状态
  - `restore_session_state(open_project_callback)` - 恢复编辑器会话状态（延迟执行）
  - `_restore_open_files()` - 恢复编辑器中打开的文件
  - `_reset_all_modification_states(editor_panel)` - 重置所有文件的修改状态
  - `restore_full_session()` - 完整会话恢复，委托给 SessionStateManager.on_app_startup()
  - `save_current_conversation()` - 保存对话会话，委托给 SessionStateManager.on_app_shutdown()
- [x] **配置键（编辑器会话）**：
  - `last_project_path` - 上次打开的项目路径
  - `open_files` - 打开的文件列表
  - `active_file` - 当前激活的文件路径
- [x] **恢复流程**：
  1. 检查 `last_project_path` 是否存在且有效
  2. 调用 `open_project_callback(path)` 初始化项目
  3. 延迟 200ms 后恢复打开的文件
  4. 切换到上次激活的文件
  5. 延迟 100ms 后重置修改状态
  6. 延迟 100ms 后调用 `restore_full_session()` 恢复对话会话
- [x] **保存流程（关闭时）**：
  1. `main_window.closeEvent()` 调用 `save_session_state()` 保存编辑器会话
  2. 调用 `save_current_conversation()` 保存对话会话
  3. `save_current_conversation()` 从 `ContextManager._get_internal_state()` 获取当前状态
  4. 调用 `SessionStateManager.mark_dirty()` 确保保存
  5. 调用 `SessionStateManager.on_app_shutdown()` 执行保存
- [x] **职责边界说明**：
  - presentation 层的 SessionManager 只负责编辑器会话和启动/关闭时的协调
  - 对话会话的状态管理由 domain 层的 SessionStateManager 负责
  - 不再持有 `current_session_name`，从 SessionStateManager 获取
- [x] **被调用方**：`main_window.py`

##### 1.6.1.3 `presentation/action_handlers.py` - 动作处理器集合

- [ ] **文件路径**：`presentation/action_handlers.py`
- [ ] **职责**：集中管理菜单和工具栏动作的具体实现逻辑
- [ ] **核心类**：`ActionHandlers`
- [ ] **核心方法**：
  - `__init__(main_window)` - 接收主窗口引用
  - `get_callbacks()` - 返回所有回调函数的字典，供 MenuManager/ToolbarManager 使用
- [ ] **文件操作回调**：
  - `on_open_workspace()` - 打开工作文件夹
  - `on_close_workspace()` - 关闭工作文件夹
  - `on_save_file()` - 保存当前文件
  - `on_save_all_files()` - 保存所有文件
  - `on_recent_project_clicked(path)` - 点击最近项目
  - `on_clear_recent_projects()` - 清除最近项目记录
- [ ] **编辑操作回调**：
  - `on_editor_undo()` - 编辑器撤销
  - `on_editor_redo()` - 编辑器重做
  - `on_undo_iteration()` - 撤回本次迭代（阶段四实现）
- [ ] **视图操作回调**：
  - `on_toggle_panel(panel_name, visible)` - 切换面板显示
- [ ] **工具操作回调**：
  - `on_model_config()` - 打开模型配置对话框
  - `on_help_docs()` - 打开文档
  - `on_about()` - 打开关于对话框
- [ ] **设计原则**：
  - 回调方法内部调用 `project_service`、`code_editor_panel` 等组件完成实际操作
  - 不包含业务逻辑，仅作为 UI 动作到服务层的桥接
- [ ] **被调用方**：`main_window.py`、`menu_manager.py`、`toolbar_manager.py`

##### 1.6.1.4 `presentation/main_window.py` - 主窗口类

> **初始化顺序**：Phase 2.2，依赖 ServiceLocator（获取 I18nManager 等）

- [ ] **文件路径**：`presentation/main_window.py`
- [ ] **职责**：窗口布局管理、面板协调、组件初始化、事件订阅与分发
- [ ] **委托关系**：
  - 菜单栏创建委托给 `MenuManager`
  - 工具栏创建委托给 `ToolbarManager`
  - 状态栏创建委托给 `StatusbarManager`
  - 窗口状态管理委托给 `WindowStateManager`
  - 会话管理委托给 `SessionManager`
  - 动作处理委托给 `ActionHandlers`
  - 面板管理委托给 `PanelManager`（1.7.3 节定义）
  - 右栏标签页管理委托给 `TabController`（1.7.4 节定义）
- [ ] **本阶段实现**：
  - 创建主窗口类，设置窗口标题、最小尺寸（1200x800）
  - 建立三栏+下栏的 `QSplitter` 嵌套布局结构
  - 初始化各管理器并创建菜单栏、工具栏、状态栏
  - 各面板区域使用 `QWidget` 占位
- [ ] **布局结构**（QSplitter 嵌套）：
  - 外层：垂直 QSplitter，分割上部主区域和下部仿真结果区
  - 上部：水平 QSplitter，分割左栏、中栏、右栏
  - 初始比例：左栏 10%、中栏 60%、右栏 30%、下栏 20% 高度
  - 最小尺寸约束：左栏 150px、中栏 400px、右栏 250px、下栏 100px
- [ ] **初始化流程**：
  1. 设置窗口基本属性
  2. 创建中央部件和布局（包含 QSplitter 嵌套结构）
  3. 创建左栏（FileBrowserPanel）、中栏（CodeEditorPanel）面板
  4. 创建右栏 `QTabWidget` 容器
  5. 初始化 `TabController` 并绑定右栏 `QTabWidget`
  6. 创建 `ConversationPanel` 并注册到 `TabController`
  7. 根据配置创建 `DevToolsPanel` 并注册到 `TabController`（阶段1.5）
  8. 创建下栏（SimulationPanel 占位）
  9. 初始化 `ActionHandlers` 获取回调字典
  10. 初始化 `MenuManager`、`ToolbarManager`、`StatusbarManager`
  11. 初始化 `PanelManager` 并注册所有面板
  12. 连接面板信号
  13. 初始化 `WindowStateManager` 并恢复窗口状态
  14. 初始化 `SessionManager` 并延迟恢复会话
  15. 订阅事件
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法，调用各管理器的 `retranslate_ui()` 方法
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件，语言切换时调用 `retranslate_ui()`
- [ ] **首次运行引导**（无项目时的空状态提示）：
  - 启动时检查 SessionState 中是否有已打开的项目
  - 若无项目，代码编辑器面板显示空状态欢迎界面
  - 空状态界面内容：居中显示大号"打开工作区"按钮
  - 用户点击按钮后弹出文件夹选择对话框
  - 选择工作文件夹后，空状态界面消失，显示正常编辑器内容
  - 不使用遮罩层，不阻挡其他面板的正常使用
- [ ] **事件订阅**：
  - `EVENT_LANGUAGE_CHANGED` → 调用 `retranslate_ui()`
  - `EVENT_STATE_PROJECT_OPENED` → 更新菜单/工具栏状态、状态栏显示
  - `EVENT_STATE_PROJECT_CLOSED` → 禁用相关功能、清空面板
- [ ] **面板显示/隐藏控制**：
  - 视图菜单中的面板项为可勾选项
  - 勾选状态与面板可见性同步
  - 通过 `PanelManager.toggle_panel()` 控制面板显示/隐藏
  - 通过 `WindowStateManager` 保存/恢复可见性状态
- [ ] **右栏标签页管理**：
  - 右栏使用 `QTabWidget` 承载多个面板（对话、调试、信息、元器件）
  - 通过 `TabController` 管理标签页切换和徽章显示
  - 标签页切换时发布 `EVENT_TAB_CHANGED` 事件
  - 新消息/新信息时通过 `TabController.set_badge()` 显示未读徽章
  - 调试面板（DevToolsPanel）根据 `debug.show_devtools_panel` 配置决定是否显示
- [ ] **右栏初始化流程**（在 `_create_panels()` 方法中）：
  1. 创建 `QTabWidget` 作为右栏容器
  2. 初始化 `TabController` 并绑定 `QTabWidget`
  3. 创建 `ConversationPanel` 并通过 `TabController.register_tab()` 注册
  4. 检查 `debug.show_devtools_panel` 配置，若为 true 则创建并注册 `DevToolsPanel`
  5. 将 `QTabWidget` 添加到水平分割器
  6. 后续阶段（阶段九、阶段十）按需注册 InfoPanel、ComponentPanel
- [ ] **右栏初始化代码示例**：
  ```python
  def _create_panels(self):
      # ... 左栏、中栏创建代码 ...
      
      # 右栏 - 使用 QTabWidget 承载多个面板
      from PyQt6.QtWidgets import QTabWidget
      from presentation.core.tab_controller import (
          TabController, TAB_CONVERSATION, TAB_DEVTOOLS
      )
      
      # 创建标签页容器
      right_tab_widget = QTabWidget()
      right_tab_widget.setMinimumWidth(250)
      
      # 初始化标签页控制器
      self._tab_controller = TabController()
      self._tab_controller.bind_tab_widget(right_tab_widget)
      
      # 注册对话面板
      from presentation.panels.conversation_panel import ConversationPanel
      chat_panel = ConversationPanel()
      self._tab_controller.register_tab(
          TAB_CONVERSATION,
          chat_panel,
          self._get_text("panel.conversation", "对话"),
          "resources/icons/panel/chat.svg"
      )
      self._panels["chat"] = chat_panel
      
      # 注册调试面板（根据配置，阶段1.5）
      if self._should_show_devtools():
          from presentation.panels.devtools_panel import DevToolsPanel
          devtools_panel = DevToolsPanel()
          self._tab_controller.register_tab(
              TAB_DEVTOOLS,
              devtools_panel,
              self._get_text("panel.devtools", "调试"),
              "resources/icons/panel/bug.svg"
          )
          self._panels["devtools"] = devtools_panel
      
      # 添加到分割器
      self._splitters["horizontal"].addWidget(right_tab_widget)
      self._panels["right_tabs"] = right_tab_widget
  
  def _should_show_devtools(self) -> bool:
      """检查是否应显示调试面板"""
      if self.config_manager:
          return self.config_manager.get("debug.show_devtools_panel", True)
      return True  # 默认显示
  ```
- [ ] **关闭事件处理**：
  - `closeEvent()` 中调用 `WindowStateManager.save_window_state()`
  - 调用 `SessionManager.save_session_state()`
- [ ] **被调用方**：`bootstrap.py`

#### 1.6.2 `menu_manager.py` - 菜单栏管理器

- [ ] **职责**：集中管理所有菜单的创建、动作绑定和国际化
- [ ] **核心方法**：
  - `__init__(main_window)` - 接收主窗口引用，用于获取服务和回调
  - `setup_menus()` - 创建所有菜单和菜单项
  - `retranslate_ui()` - 刷新所有菜单文本
  - `update_recent_menu()` - 更新最近项目子菜单
  - `get_action(name)` - 获取指定动作对象
  - `set_action_enabled(name, enabled)` - 设置动作启用状态
- [ ] **菜单结构**：
  - **文件菜单**：打开工作文件夹、关闭工作文件夹（灰显）、最近打开子菜单、保存（灰显）、全部保存（灰显）、分隔线、退出
  - **编辑菜单**：撤销（灰显，编辑器级别）、重做（灰显，编辑器级别）、分隔线、撤回本次迭代（灰显，阶段四启用）、分隔线、剪切（灰显）、复制（灰显）、粘贴（灰显）
  - **视图菜单**：文件浏览器（勾选）、代码编辑器（勾选）、对话面板（勾选）、仿真结果（勾选）
  - **设计菜单**：设计目标（打开设计目标编辑对话框）
  - **仿真菜单**：运行仿真（灰显）、停止仿真（灰显）—— 阶段四启用
  - **知识库菜单**：导入文档（灰显）、重建索引（灰显）—— 阶段四启用
  - **模型菜单**：模型配置（打开模型配置对话框）
  - **工具菜单**：压缩上下文（灰显）
  - **语言菜单**：English（单选）、简体中文（单选）—— 当前语言显示勾选标记
  - **帮助菜单**：文档、关于
- [ ] **语言菜单实现**：
  - 使用 `QActionGroup` 实现单选互斥
  - 菜单项文本固定显示语言原生名称（English、简体中文），不随语言切换变化
  - 当前语言的菜单项显示勾选标记
  - 点击后调用 `i18n_manager.set_language(lang_code)`，立即生效
- [ ] **设计原则**：
  - 动作处理器回调由 `MainWindow` 提供，管理器只负责 UI 创建和文本刷新
  - 菜单项文本使用 `i18n_manager.get_text("menu.xxx")` 获取
- [ ] **被调用方**：`main_window.py`

#### 1.6.3 `toolbar_manager.py` - 工具栏管理器

- [ ] **职责**：集中管理工具栏的创建、动作绑定和国际化
- [ ] **核心方法**：
  - `__init__(main_window)` - 接收主窗口引用
  - `setup_toolbar()` - 创建工具栏
  - `retranslate_ui()` - 刷新所有按钮文本
  - `get_action(name)` - 获取指定动作对象
  - `set_action_enabled(name, enabled)` - 设置动作启用状态
- [ ] **工具栏按钮**：
  - `[打开]` - 打开工作文件夹（功能实现），图标 `folder_open.svg`
  - `[保存]` - 保存当前文件（阶段二启用），图标 `save.svg`
  - `[全部保存]` - 保存所有已修改文件（阶段二启用），图标 `save_all.svg`
  - `[▶ 自动运行]` - 自动检测主电路并运行仿真（灰显，阶段四启用），图标 `play.svg`
  - `[📂 选择运行]` - 弹出对话框选择仿真文件（灰显，阶段四启用），图标 `folder_play.svg`
  - `[停止]` - 停止仿真（灰显，阶段四启用），图标 `stop.svg`
  - `[撤销]` - 撤销操作（灰显，阶段五启用），图标 `undo.svg`
  - `[重做]` - 重做操作（灰显，阶段五启用），图标 `redo.svg`
- [ ] **仿真按钮设计**（阶段四实现）：
  - **三层分离说明**：
    - 按钮控制的是"文件选择方式"（自动扫描 vs 手动选择）
    - 与"仿真执行方式"（SPICE vs Python）无关
    - 系统根据选中文件的扩展名自动选择对应的执行器
  - **两种仿真触发方式**：
    - `[▶ 自动运行]` 按钮：使用 `AutoScanStrategy` 自动扫描并执行
    - `[📂 选择运行]` 按钮：使用 `ManualSelectStrategy` 弹出对话框选择
  - **`[▶ 自动运行]` 按钮行为**：
    - 点击时调用 `simulation_service.run_with_auto_detect()`
    - 使用被引用分析法扫描项目中的可仿真文件
    - 检测到唯一主电路时，直接启动仿真
    - 检测到多个主电路时，自动弹出选择对话框让用户选择
    - 适用场景：常规仿真运行
  - **`[📂 选择运行]` 按钮行为**：
    - 点击时调用 `simulation_service.run_with_manual_select()`
    - 弹出 `select_simulation_file_dialog` 对话框
    - 对话框显示所有支持的文件类型（从 `executor_registry` 获取）
    - 用户选择文件后，根据扩展名自动选择执行器并启动仿真
    - 适用场景：用户希望明确指定仿真文件，或运行 Python 脚本
  - **按钮状态管理**：
    - 仿真运行中两个运行按钮均禁用，停止按钮启用
    - 工作流锁定时（`workflow_locked = True`）两个运行按钮均禁用
- [ ] **设计原则**：
  - 工具栏按钮使用 `QAction`，图标从 `resources/icons/toolbar/` 加载 SVG
  - 动作处理器回调由 `MainWindow` 提供
- [ ] **被调用方**：`main_window.py`

#### 1.6.4 `statusbar_manager.py` - 状态栏管理器

- [ ] **职责**：集中管理状态栏的多分区布局和状态更新
- [ ] **核心方法**：
  - `__init__(main_window)` - 接收主窗口引用
  - `setup_statusbar()` - 创建状态栏布局
  - `retranslate_ui()` - 刷新状态栏文本
  - `set_status(text)` - 设置任务状态文本
  - `set_iteration_info(iteration, total)` - 设置迭代信息
  - `set_worker_status(worker_type, status)` - 设置 Worker 状态指示
  - `set_project_info(path)` - 设置项目路径信息
- [ ] **状态栏布局**（多分区）：
  - 左侧：任务状态文本（如"就绪"、"运行中..."、"等待确认..."）
  - 中间：当前工作流状态（如"检查点：请确认下一步操作"，阶段五显示）
  - 右侧：Worker 状态指示器（阶段三显示）
- [ ] **设计原则**：
  - 状态栏文本使用 `i18n_manager.get_text("status.xxx")` 获取
- [ ] **被调用方**：`main_window.py`

#### 1.6.5 `presentation/dialogs/model_config_dialog.py` - 模型配置对话框

> **设计说明**：采用两级选择模式（厂商 → 模型），厂商专属功能（如智谱联网搜索）仅在选择对应厂商后显示。通用联网搜索（Google/Bing）独立配置，与厂商无关。

- [ ] **文件路径**：`presentation/dialogs/model_config_dialog.py`
- [ ] **职责**：管理 LLM 厂商和模型配置，包括 API 密钥、模型选择、厂商专属功能
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法，刷新对话框标题、标签、按钮文本
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件

##### 1.6.5.1 对话框整体布局
- [ ] **布局结构**：使用 `QStackedWidget` 或分组框实现分区
  - 第一区：厂商选择区
  - 第二区：厂商配置区（根据选择的厂商动态显示）
  - 第三区：厂商专属功能区（仅支持的厂商显示）
  - 第四区：通用联网搜索配置区（独立于厂商）
  - 底部：测试连接、保存/取消按钮

##### 1.6.5.2 厂商选择区
- [ ] **厂商选择**：`QComboBox`
  - 选项：智谱 AI、本地模型（Ollama）、DeepSeek、通义千问、OpenAI、Anthropic
  - 本地模型选项始终可用（无需 API Key）
  - 未实现的云端厂商显示"（即将支持）"后缀，选择后配置区显示占位提示
  - 切换厂商时自动更新模型列表和默认 Base URL
- [ ] **厂商状态指示**：
  - 已实现：正常显示
  - 本地模型：显示 Ollama 服务状态图标（绿色/红色/灰色）
  - 占位：灰色文字 + "即将支持"标签

##### 1.6.5.3 厂商配置区（云端模型）
- [ ] **显示条件**：仅当选择云端厂商时显示
- [ ] **API Key**：`QLineEdit`（密码模式，掩码显示）
- [ ] **Base URL**：`QLineEdit`
  - 根据厂商自动填充默认值（从 `PROVIDER_DEFAULTS` 获取）
  - 用户可自定义修改
- [ ] **模型选择**：`QComboBox`
  - 选项根据厂商动态加载（从 `ModelRegistry.list_model_names(provider_id)` 获取）
  - 默认选择厂商的默认模型
- [ ] **流式输出**：`QCheckBox`（默认启用）
- [ ] **超时设置**：`QSpinBox`（秒，默认60）
- [ ] **占位提示**（未实现的厂商）：
  - 显示"该厂商支持即将推出，敬请期待"
  - 配置控件禁用或隐藏

##### 1.6.5.3a 本地模型配置区
- [ ] **显示条件**：仅当选择 `LLM_PROVIDER_LOCAL` 时显示
- [ ] **Ollama 服务地址**：`QLineEdit`
  - 默认值：`http://localhost:11434`
  - 用户可自定义修改（支持远程 Ollama 服务）
- [ ] **服务状态指示器**：`QLabel` + 图标
  - 运行中：绿色圆点 + "Ollama 服务运行中"
  - 未启动：红色圆点 + "Ollama 服务未启动"
  - 未安装：灰色圆点 + "Ollama 未安装"
  - 检测中：旋转加载图标 + "检测中..."
- [ ] **模型选择**：`QComboBox`
  - 选项从 Ollama API 动态加载（`/api/tags`）
  - 显示格式：`模型名称 (参数量, 大小)`
  - 服务不可用时显示"请先启动 Ollama 服务"
- [ ] **刷新模型列表按钮**：`QPushButton`
  - 点击后重新调用 Ollama API 获取模型列表
  - 刷新期间显示加载状态
- [ ] **流式输出**：`QCheckBox`（默认启用）
- [ ] **超时设置**：`QSpinBox`（秒，默认120，本地模型推理较慢）
- [ ] **安装指引**：
  - 服务未安装时显示"安装 Ollama"链接，点击打开官网
  - 服务未启动时显示"启动命令：ollama serve"提示
  - 无模型时显示"下载模型：ollama pull qwen2.5:7b"提示

##### 1.6.5.4 厂商专属功能区
- [ ] **显示条件**：仅当选择的厂商支持专属功能时显示
  - 深度思考支持：通过 `ModelRegistry.list_models(provider_id)` 检查是否有任何模型支持 `supports_thinking`
  - 联网搜索支持：从 `PROVIDER_DEFAULTS[provider]["supports_web_search"]` 获取
- [ ] **深度思考配置**（智谱、DeepSeek、Anthropic 支持）：
  - **深度思考开关**：`QCheckBox`（默认启用）
  - **深度思考超时**：`QSpinBox`（秒，默认300，仅开关启用时显示）
  - 启用时参数由 ModelRegistry 提供：`max_tokens` 使用 `model_config.max_tokens_thinking`，`temperature` 使用 `model_config.thinking_temperature`
- [ ] **厂商专属联网搜索**（仅智谱支持）：
  - **联网搜索开关**：`QCheckBox`（默认关闭）
  - 说明文字："使用智谱内置联网搜索，无需额外配置"
  - 仅当 `llm_provider == "zhipu"` 时显示此区域
  - **互斥约束**：启用时自动禁用通用联网搜索

##### 1.6.5.5 通用联网搜索配置区
- [ ] **设计说明**：与厂商无关，始终显示，用于配置 Google/Bing 搜索
- [ ] **通用联网搜索开关**：`QCheckBox`（默认关闭）
  - **互斥约束**：启用时自动禁用厂商专属联网搜索
- [ ] **搜索供应商**：`QComboBox`（Google / Bing）
- [ ] **搜索 API Key**：`QLineEdit`（密码模式）
- [ ] **Google 搜索引擎 ID**：`QLineEdit`（仅选择 Google 时显示）

##### 1.6.5.5a 联网搜索互斥机制
- [ ] **设计原因**：避免搜索结果冲突和重复计费
  - 厂商内置搜索与通用搜索可能返回不同结果，混合使用会导致上下文混乱
  - 同时启用两种搜索会产生双倍 API 调用费用
- [ ] **互斥规则**：
  - 厂商专属联网搜索与通用联网搜索只能二选一
  - 启用厂商专属搜索时，通用搜索开关自动关闭并禁用
  - 启用通用搜索时，厂商专属搜索开关自动关闭并禁用
  - 两者都关闭时，两个开关都可用
- [ ] **UI 交互**：
  - 被禁用的开关显示灰色，鼠标悬停显示提示"已启用其他搜索方式"
  - 切换厂商时，若新厂商不支持专属搜索，通用搜索开关恢复可用

##### 1.6.5.6 验证与保存
- [ ] **测试连接按钮**：`QPushButton`（本阶段仅UI，功能待阶段三实现）
- [ ] **验证状态指示器**：`QLabel` + 图标
  - 未验证：灰色圆点 + "未验证"
  - 验证中：旋转加载图标 + "验证中..."
  - 验证成功：绿色勾选 + "连接成功"
  - 验证失败：红色叉号 + 错误信息摘要
- [ ] **保存/取消按钮**

##### 1.6.5.7 核心功能
- [ ] **核心方法**：
  - `load_config()` - 加载当前配置和凭证到界面
  - `save_config()` - 保存配置到 config.json，凭证到 credentials.json
  - `on_provider_changed(provider)` - 厂商切换时加载该厂商的已保存凭证
  - `update_model_list(provider)` - 根据厂商更新模型列表
  - `update_feature_visibility(provider)` - 根据厂商更新功能区显示
  - `test_connection()` - 测试 API Key 有效性（阶段三实现）
  - `update_validation_status(status, message)` - 更新验证状态显示
- [ ] **凭证管理交互**：
  - 切换厂商时，从 CredentialManager 加载该厂商的已保存凭证
  - 若该厂商有已保存凭证，自动填充 API Key 输入框
  - 保存时，将 API Key 通过 CredentialManager 存储到对应厂商
  - 用户可以预先配置多个厂商的凭证，切换时不会丢失

##### 1.6.5.8 厂商模型说明
- [ ] **智谱 AI（已实现，仅支持以下三个模型）**：
  - `GLM-4.7`：最新旗舰文本模型，面向 Agentic Coding 场景强化，支持深度思考，200K 上下文
  - `GLM-4.6V`：旗舰视觉模型，支持图像理解和深度思考，128K 上下文
  - `GLM-4.6V-Flash`：轻量视觉模型，免费额度，支持图像理解，128K 上下文
- [ ] **本地模型（已实现，通过 Ollama 运行时）**：
  - 模型列表从 Ollama 动态发现，以下为推荐模型：
  - `qwen2.5:7b`：通义千问 2.5，7B 参数，中英文能力强，推荐入门
  - `qwen2.5:14b`：通义千问 2.5，14B 参数，更强推理能力
  - `deepseek-coder:6.7b`：DeepSeek Coder，代码生成专用
  - `llama3.1:8b`：Meta Llama 3.1，8B 参数，通用能力
  - `mistral:7b`：Mistral 7B，轻量高效
  - `llava:7b`：视觉模型，支持图像理解
- [ ] **DeepSeek（占位）**：
  - `deepseek-chat`：通用对话模型
  - `deepseek-coder`：代码生成模型
- [ ] **通义千问（占位）**：
  - `qwen-max`：旗舰模型
  - `qwen-plus`：平衡模型
  - `qwen-turbo`：快速模型
- [ ] **OpenAI（占位）**：
  - `gpt-4o`：最新多模态模型
  - `gpt-4o-mini`：轻量版
  - `gpt-4-turbo`：高性能版
- [ ] **Anthropic（占位）**：
  - `claude-3-5-sonnet`：平衡模型
  - `claude-3-5-haiku`：快速模型

##### 1.6.5.9 校验与交互
- [ ] **保存位置**：
  - 非敏感配置：`~/.circuit_design_ai/config.json`（厂商选择、模型、超时等）
  - 敏感凭证：`~/.circuit_design_ai/credentials.json`（API Key，加密存储）
  - 本地模型配置：`~/.circuit_design_ai/config.json`（服务地址、默认模型）
- [ ] **校验逻辑**：
  - 厂商必须选择
  - 云端厂商：API Key 不能为空（已实现的厂商）
  - 本地模型：服务地址格式有效（URL 格式校验）
  - 本地模型：模型必须选择（若服务可用）
- [ ] **本地模型特殊处理**：
  - 无需 API Key，跳过凭证校验
  - 保存时不写入 credentials.json
  - 服务不可用时允许保存配置（用户可能稍后启动 Ollama）
  - 超时值必须 > 0
- [ ] **验证交互流程**（阶段三实现）：
  - 用户点击"测试连接"按钮
  - 按钮禁用，状态显示"验证中..."
  - 后台发送简单请求测试连接
  - 成功/失败显示对应状态
  - 厂商或 API Key 变更时重置验证状态
- [ ] **验证状态持久化**：
  - 验证成功后保存时间戳到配置：`llm_verified_at_{provider_id}`
  - 重新打开对话框时检查：若该厂商有验证时间戳且 API Key 未变更，显示"已验证"状态
  - API Key 变更后清除验证状态，需重新验证
- [ ] **被调用方**：`main_window.py`（模型菜单 → 模型配置）

##### 1.6.5.10 UI 样式规范
- [ ] **复选框样式**：
  - 使用打钩（✓）样式而非蓝色填充
  - 选中状态：白色背景 + 蓝色边框 + 蓝色打钩图标
  - 未选中状态：白色背景 + 灰色边框
  - 悬停状态：边框变为蓝色
  - 禁用状态：灰色背景 + 浅灰边框
- [ ] **下拉框样式**：
  - 右侧显示下拉箭头（▼）指示可展开
  - 悬停时边框变为蓝色
  - 下拉箭头使用 SVG 图标，悬停时变色
  - 下拉列表项选中时使用浅蓝色背景
- [ ] **样式实现**：
  - 图标文件位置：`resources/icons/ui/checkmark.svg`（打钩）、`resources/icons/ui/dropdown.svg`（下拉箭头）
  - 在 `_get_icon_paths()` 方法中获取本地图标路径，若不存在则创建临时文件作为后备
  - 通过 `setStyleSheet()` 引用文件路径设置样式
  - 对话框关闭时通过 `closeEvent()` 清理临时文件（仅在使用临时目录时）
  - 注意：Qt 样式表不支持 `data:` URL 格式，必须使用文件路径

#### 1.6.6 `about_dialog.py` - 关于对话框
- [ ] **职责**：显示软件版本、许可证信息、第三方组件声明
- [ ] **触发方式**：帮助菜单 → 关于
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件
- [ ] **UI组件**：
  - 软件名称和图标
  - 版本号
  - 版权声明
  - 第三方许可证声明（含 ngspice BSD-3-Clause）
  - `[关闭]` 按钮
- [ ] **被调用方**：`main_window.py`（帮助菜单 → 关于）

---

### 1.7 UI层架构设计 (`presentation/core/`)

> **设计目标**：建立统一的UI层架构，确保所有面板、对话框、交互组件遵循一致的设计模式，实现UI与业务逻辑的清晰分离。

> **架构原则**：
> - **MVVM模式**：所有复杂面板采用 Model-View-ViewModel 模式，View 只负责渲染，ViewModel 负责状态管理和业务逻辑调用
> - **事件驱动**：UI组件通过 EventBus 订阅状态变更，避免直接依赖业务模块
> - **统一面板管理**：所有面板通过 PanelManager 统一管理生命周期和可见性
> - **标签页控制**：右栏标签页通过 TabController 统一管理切换逻辑

#### 1.7.1 UI层目录结构

```
presentation/
├── core/                           # UI层核心基础设施（新增）
│   ├── __init__.py
│   ├── base_view_model.py          # ViewModel 基类
│   ├── panel_manager.py            # 面板管理器
│   ├── tab_controller.py           # 标签页控制器
│   ├── ui_event_bridge.py          # UI事件桥接器
│   └── panel_registry.py           # 面板注册表
├── panels/                         # 各功能面板
│   ├── conversation/               # 对话面板模块组（阶段三）
│   ├── simulation/                 # 仿真面板模块组（阶段四）
│   ├── info/                       # 信息面板模块组（阶段九）
│   ├── component/                  # 元器件面板模块组（阶段十）
│   ├── file_browser_panel.py       # 文件浏览器面板
│   └── code_editor_panel.py        # 代码编辑器面板
├── dialogs/                        # 对话框
├── widgets/                        # 可复用小组件
├── main_window.py                  # 主窗口
├── menu_manager.py                 # 菜单管理器
├── toolbar_manager.py              # 工具栏管理器
├── statusbar_manager.py            # 状态栏管理器
└── session_manager.py              # 会话管理器
```

#### 1.7.2 `base_view_model.py` - ViewModel 基类

- [ ] **文件路径**：`presentation/core/base_view_model.py`
- [ ] **职责**：定义所有 ViewModel 的基类，提供状态管理、事件订阅、属性变更通知的统一接口
- [ ] **核心功能**：
  - `__init__(event_bus)` - 初始化，注入 EventBus
  - `subscribe(event_type, handler)` - 订阅事件
  - `unsubscribe(event_type, handler)` - 取消订阅
  - `notify_property_changed(property_name, value)` - 通知属性变更
  - `dispose()` - 清理资源，取消所有订阅
- [ ] **属性变更信号**：
  - `property_changed = pyqtSignal(str, object)` - 属性变更信号（属性名，新值）
  - View 层连接此信号以响应 ViewModel 状态变化
- [ ] **生命周期管理**：
  - `initialize()` - 初始化 ViewModel（延迟初始化，在 View 准备好后调用）
  - `is_initialized` - 初始化状态标志
  - `dispose()` - 销毁时清理订阅和资源
- [ ] **被继承方**：`ConversationViewModel`、`SimulationViewModel`、`InfoPanelViewModel`、`ComponentViewModel`

#### 1.7.3 `panel_manager.py` - 面板管理器

- [ ] **文件路径**：`presentation/core/panel_manager.py`
- [ ] **职责**：统一管理所有面板的生命周期、可见性、布局状态
- [ ] **核心功能**：
  - `register_panel(panel_id, panel_instance, region)` - 注册面板到指定区域
  - `get_panel(panel_id)` - 获取面板实例
  - `show_panel(panel_id)` - 显示面板
  - `hide_panel(panel_id)` - 隐藏面板
  - `toggle_panel(panel_id)` - 切换面板可见性
  - `get_visible_panels(region)` - 获取指定区域的可见面板列表
  - `save_layout_state()` - 保存布局状态到配置
  - `restore_layout_state()` - 从配置恢复布局状态
- [ ] **区域定义**：
  - `LEFT` - 左栏（文件浏览器）
  - `CENTER` - 中栏（代码编辑器）
  - `RIGHT` - 右栏（对话/信息/元器件标签页）
  - `BOTTOM` - 下栏（仿真结果）
- [ ] **面板状态事件**：
  - 面板显示/隐藏时发布 `EVENT_PANEL_VISIBILITY_CHANGED`
  - 携带数据：`panel_id`、`visible`、`region`
- [ ] **布局持久化**：
  - 保存到 `~/.circuit_design_ai/layout.json`
  - 包含：各面板可见性、分割器位置、窗口大小
- [ ] **被调用方**：`main_window.py`、`menu_manager.py`（视图菜单）
- [ ] **面板访问规范**：
  - 外部代码通过 `PanelManager.get_panel(panel_id)` 获取面板实例
  - `MainWindow._panels` 字典仅供内部使用，不对外暴露
  - `ActionHandlers` 中的面板操作委托给 `MainWindow._on_toggle_panel()`
  - 禁止在 `ActionHandlers` 中直接操作 `self._panels` 字典

#### 1.7.4 `tab_controller.py` - 标签页控制器

- [ ] **文件路径**：`presentation/core/tab_controller.py`
- [ ] **职责**：管理右栏标签页的切换逻辑、徽章显示、自动切换策略
- [ ] **核心功能**：
  - `register_tab(tab_id, widget, title, icon)` - 注册标签页
  - `switch_to_tab(tab_id)` - 切换到指定标签页
  - `get_current_tab()` - 获取当前标签页ID
  - `set_badge(tab_id, count)` - 设置标签页徽章数字（未读消息等）
  - `clear_badge(tab_id)` - 清除徽章
  - `set_auto_switch_policy(policy)` - 设置自动切换策略
- [ ] **标签页定义**：
  - `TAB_CONVERSATION` - 对话标签页
  - `TAB_INFO` - 信息标签页（阶段九）
  - `TAB_DEVTOOLS` - 调试工具标签页（阶段1.5）
  - `TAB_COMPONENT` - 元器件标签页（阶段十）
- [ ] **自动切换策略**：
  - `POLICY_NONE` - 不自动切换
  - `POLICY_ON_NEW_MESSAGE` - 收到新消息时切换到对话
  - `POLICY_ON_SIMULATION_COMPLETE` - 仿真完成时切换到信息
  - `POLICY_ON_SEARCH_RESULT` - 搜索结果返回时切换到信息
- [ ] **徽章显示**：
  - 当标签页非活跃且有新内容时显示数字徽章
  - 切换到该标签页时自动清除徽章
- [ ] **事件发布**：
  - 标签切换时发布 `EVENT_TAB_CHANGED`
  - 携带数据：`previous_tab`、`current_tab`
- [ ] **被调用方**：`main_window.py`、各面板 ViewModel

#### 1.7.5 `ui_event_bridge.py` - UI事件桥接器

- [ ] **文件路径**：`presentation/core/ui_event_bridge.py`
- [ ] **职责**：桥接业务层事件与UI层响应，确保事件处理在主线程执行
- [ ] **核心功能**：
  - `bridge_event(event_type, ui_handler)` - 桥接事件到UI处理器
  - `unbind_event(event_type, ui_handler)` - 解除桥接
  - `ensure_main_thread(handler)` - 确保处理器在主线程执行
- [ ] **线程安全**：
  - 使用 `QMetaObject.invokeMethod` 确保 UI 更新在主线程
  - 自动检测当前线程，非主线程时自动切换
- [ ] **常用桥接**：
  - `EVENT_SESSION_CHANGED` → 更新对话面板标题
  - `EVENT_SIMULATION_COMPLETE` → 更新仿真结果标签页
  - `EVENT_WORK_MODE_CHANGED` → 更新状态栏模式指示器
  - `EVENT_CONTEXT_COMPRESS_REQUESTED` → 显示压缩确认对话框
  - `EVENT_REPORT_GENERATION_PROGRESS` → 更新报告生成标签页进度
- [ ] **被调用方**：各面板的 ViewModel

#### 1.7.6 `panel_registry.py` - 面板注册表

- [ ] **文件路径**：`presentation/core/panel_registry.py`
- [ ] **职责**：集中定义所有面板的元信息，支持面板的延迟加载
- [ ] **面板元信息**：
  ```python
  PANEL_DEFINITIONS = {
      "file_browser": {
          "class": "FileBrowserPanel",
          "module": "presentation.panels.file_browser_panel",
          "region": "LEFT",
          "default_visible": True,
          "title_key": "panel.file_browser",  # i18n key
          "icon": "icons/panel/folder.svg",
      },
      "code_editor": {
          "class": "CodeEditorPanel",
          "module": "presentation.panels.code_editor_panel",
          "region": "CENTER",
          "default_visible": True,
          "title_key": "panel.code_editor",
          "icon": "icons/panel/code.svg",
      },
      "conversation": {
          "class": "ConversationPanel",
          "module": "presentation.panels.conversation.conversation_panel",
          "region": "RIGHT",
          "default_visible": True,
          "title_key": "panel.conversation",
          "icon": "icons/panel/chat.svg",
          "tab_id": "TAB_CONVERSATION",
      },
      "info": {
          "class": "InfoPanel",
          "module": "presentation.panels.info.info_panel",
          "region": "RIGHT",
          "default_visible": False,
          "title_key": "panel.info",
          "icon": "icons/panel/info.svg",
          "tab_id": "TAB_INFO",
          "phase": 9,  # 阶段九实现
      },
      "devtools": {
          "class": "DevToolsPanel",
          "module": "presentation.panels.devtools_panel",
          "region": "RIGHT",
          "default_visible": False,
          "title_key": "panel.devtools",
          "icon": "icons/panel/bug.svg",
          "tab_id": "TAB_DEVTOOLS",
          "config_key": "debug.show_devtools_panel",
          "phase": 1.5,  # 阶段1.5实现
      },
      "simulation": {
          "class": "SimulationPanel",
          "module": "presentation.panels.simulation.simulation_panel",
          "region": "BOTTOM",
          "default_visible": True,
          "title_key": "panel.simulation",
          "icon": "icons/panel/chart.svg",
      },
      "component": {
          "class": "ComponentPanel",
          "module": "presentation.panels.component.component_panel",
          "region": "RIGHT",
          "default_visible": False,
          "title_key": "panel.component",
          "icon": "icons/panel/chip.svg",
          "tab_id": "TAB_COMPONENT",
          "phase": 10,  # 阶段十实现
      },
  }
  ```
- [ ] **延迟加载**：
  - 面板类在首次访问时动态导入
  - 减少启动时间，按需加载
- [ ] **被调用方**：`panel_manager.py`、`main_window.py`

#### 1.7.7 UI交互流程规范

> **设计说明**：定义用户操作到UI响应的标准流程，确保所有面板遵循一致的交互模式。

##### 1.7.7.1 用户操作 → 业务处理 → UI更新流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        UI 交互标准流程                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [用户操作]                                                              │
│       │                                                                 │
│       ▼                                                                 │
│  View 层（Panel/Dialog）                                                 │
│       │                                                                 │
│       ├──► 简单操作（纯UI）：直接处理                                     │
│       │                                                                 │
│       └──► 业务操作：调用 ViewModel 方法                                  │
│                 │                                                       │
│                 ▼                                                       │
│            ViewModel 层                                                  │
│                 │                                                       │
│                 ├──► 状态变更：更新内部状态 → 发射 property_changed 信号   │
│                 │                                                       │
│                 └──► 业务调用：调用 Domain/Application 层服务             │
│                           │                                             │
│                           ▼                                             │
│                      业务层处理                                          │
│                           │                                             │
│                           ▼                                             │
│                      EventBus.publish(EVENT_XXX)                        │
│                           │                                             │
│                           ▼                                             │
│                      UIEventBridge.ensure_main_thread()                 │
│                           │                                             │
│                           ▼                                             │
│                      ViewModel.on_event_xxx()                           │
│                           │                                             │
│                           ▼                                             │
│                      ViewModel.notify_property_changed()                │
│                           │                                             │
│                           ▼                                             │
│                      View.on_property_changed() → 更新 UI               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

##### 1.7.7.2 面板间通信规范

- [ ] **禁止直接调用**：面板 A 不得直接调用面板 B 的方法
- [ ] **通过事件通信**：面板间通信必须通过 EventBus
- [ ] **通过 TabController 切换**：需要切换标签页时调用 TabController，不直接操作 QTabWidget
- [ ] **示例场景**：
  - 仿真完成后切换到信息面板：
    1. SimulationService 发布 `EVENT_SIMULATION_COMPLETE`
    2. InfoPanelViewModel 订阅事件，更新内部状态
    3. TabController 根据策略自动切换到信息标签页
    4. InfoPanel 的 View 层响应 ViewModel 状态变更，渲染结果

##### 1.7.7.3 面板初始化时序

```
Phase 2.2: MainWindow 创建
    │
    ├──► PanelManager 初始化（空注册表）
    ├──► TabController 初始化（空标签页）
    ├──► 创建面板骨架（不初始化 ViewModel）
    │
    ▼
Phase 3.7: EVENT_INIT_COMPLETE 发布
    │
    ├──► 各面板 ViewModel 初始化
    │       ├──► ConversationViewModel.initialize()
    │       ├──► SimulationViewModel.initialize()
    │       └──► InfoPanelViewModel.initialize()
    │
    ├──► 面板注册到 PanelManager
    ├──► 标签页注册到 TabController
    │
    ▼
Phase 3.8: 会话恢复
    │
    ├──► SessionStateManager.restore_on_startup()
    ├──► EVENT_SESSION_CHANGED 发布
    └──► ConversationPanel 响应事件，加载历史消息
```

---
