## 阶段 2.5：状态管理与文件快照架构 (0.5周)

> **目标**：建立"基于引用的单一数据源"架构，GraphState 作为唯一真理来源，存储文件路径和轻量摘要，业务数据存储在文件系统，领域服务提供无状态的读写接口

> **⚠️ 核心架构原则：Reference-Based Single Source of Truth**
> - **GraphState 是目录**：仅存储文件路径（指针）和轻量摘要，不存储重数据
> - **文件系统是仓库**：仿真结果、设计目标、对话历史等业务数据存储在文件中
> - **领域服务是搬运工**：无状态的纯函数式服务，输入 → 处理 → 输出到文件 → 返回路径
> - **SnapshotService 是撤回的唯一真理来源**：文件快照为主，GraphState 从磁盘重建

> **⚠️ 线性撤回架构（简化设计）**：
> - **放弃 LangGraph Time Travel 分支机制**：避免检查点历史分叉带来的复杂性
> - **文件快照为主**：SnapshotService 管理线性快照栈，撤回时恢复文件
> - **GraphState 重建为辅**：撤回后通过 `initialize_project` 从磁盘文件重建 GraphState
> - **RecoveryLog 保障一致性**：WAL 日志处理崩溃恢复场景

> **⚠️ 三层状态分离架构**：
> - **GraphState（Domain 层）**：LangGraph 工作流的唯一真理来源，本阶段定义
> - **SessionState（Application 层）**：GraphState 的只读投影，供 UI 层读取业务状态（阶段一定义）
> - **UIState（Presentation 层）**：纯 UI 状态，不影响业务逻辑（阶段一定义）
> - **GraphStateProjector**：监听 GraphState 变更，自动投影到 SessionState（阶段七实现）
> - **单向数据流**：GraphState → SessionState → UI，禁止反向修改

> **⚠️ 与旧架构的区别**：
> - **废弃**：有状态的领域状态管理器（DesignStateManager、SimulationStateManager 等）
> - **废弃**：StateCoordinator 协调内存状态
> - **废弃**：OrphanedDataCleaner（不再需要，因为不依赖检查点历史）
> - **废弃**：依赖 LangGraph Time Travel 的分支回滚
> - **新增**：无状态的领域服务（DesignService、SimulationService 等）
> - **新增**：GraphState 存储文件路径和摘要字段
> - **新增**：RecoveryLogService（WAL 恢复日志服务）

> **⚠️ 跨阶段依赖**：
> - 阶段三：ContextService（对话历史读写）
> - 阶段四：SimulationService（仿真执行与结果存储）
> - 阶段五：RAGService（检索执行）
> - 阶段七：DesignService（设计目标读写）、GraphState 定义
> - 阶段八：撤回机制（SnapshotService + RecoveryLog + GraphState 重建）

---

### 2.5.1 架构概览

#### 2.5.1.1 核心架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    LangGraph 工作流层                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              GraphState (单一数据源)                      │   │
│  │                                                         │   │
│  │  流转控制：session_id, work_mode, current_node, intent  │   │
│  │  文件指针：circuit_file_path, sim_result_path           │   │
│  │  轻量摘要：design_goals_summary, last_metrics           │   │
│  │  消息聚合：messages (LangGraph 内部使用)                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              │ SqliteSaver 持久化               │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │           checkpoints.sqlite3 (GraphState 版本)          │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 图节点调用
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    无状态领域服务层                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │DesignService │  │SimulationSvc │  │ ContextService       │  │
│  │ (设计目标)   │  │ (仿真执行)   │  │ (对话历史)           │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
│         │                 │                    │                │
│         │ 读写文件        │ 读写文件           │ 读写文件       │
│         ↓                 ↓                    ↓                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    文件系统 (业务数据仓库)                │   │
│  │  .circuit_ai/design_goals.json                          │   │
│  │  .circuit_ai/sim_results/run_001.json                   │   │
│  │  .circuit_ai/conversations/{session_id}.json            │   │
│  │  amplifier.cir, parameters.json, ...                    │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 文件快照
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    全量快照服务                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              SnapshotService (shutil.copytree)           │   │
│  │                                                         │   │
│  │  create_snapshot() - 全量拷贝项目文件到快照目录          │   │
│  │  restore_snapshot() - 从快照目录恢复项目文件             │   │
│  │  cleanup_old_snapshots() - 保留最近 N 个快照             │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```



#### 2.5.1.2 数据分类原则

- [ ] **存入 GraphState 的数据**（轻量，决定流程走向）：
  - 流转控制：`session_id`、`work_mode`、`current_node`、`user_intent`
  - 文件指针：`circuit_file_path`、`sim_result_path`、`design_goals_path`
  - 轻量摘要：`design_goals_summary`、`last_metrics`、`error_context`
  - 计数器：`iteration_count`、`checkpoint_count`、`stagnation_count`
- [ ] **存入文件系统的数据**（重量，通过路径引用）：
  - 仿真波形数据：序列化为 JSON/NumPy，存入 `.circuit_ai/sim_results/`
  - 设计目标详情：存入 `.circuit_ai/design_goals.json`
  - 完整对话历史：存入 `.circuit_ai/conversations/{session_id}.json`
  - 电路文件：用户项目目录中的 `.cir`、`.sp` 文件
- [ ] **视图投影数据**（从 GraphState 历史派生，不独立存储）：
  - 迭代历史：从 SqliteSaver 的检查点历史中查询，是 GraphState 版本的视图投影
  - 避免双写一致性问题，UI 需要时实时查询
- [ ] **不存储的数据**（按需获取）：
  - RAG 检索结果：每次检索时实时获取
  - ChromaDB 向量索引：由 ChromaDB 自己管理

#### 2.5.1.3 线性撤回机制原理

> **⚠️ 简化设计**：放弃 LangGraph Time Travel 的分支机制，采用"文件快照为主，GraphState 重建为辅"的线性撤回方案
> - **SnapshotService**：管理线性快照栈，撤回时恢复文件
> - **RecoveryLogService**：WAL 日志保障崩溃恢复
> - **GraphState 重建**：撤回后通过 `initialize_project` 从磁盘文件重建

```
[用户请求撤回到上一个迭代]
       │
       ├─→ 1. 预检查（Pre-flight Check）
       │   └─→ 验证目标快照存在且完整
       │   └─→ 验证磁盘空间足够
       │   └─→ 验证文件系统可写
       │
       ├─→ 2. 写入恢复意图日志（原子操作）
       │   └─→ RecoveryLogService.write_log({action: "undo", phase: "started"})
       │   └─→ 使用 "写临时文件 + os.replace" 保证原子性
       │
       ├─→ 3. 恢复文件快照
       │   └─→ SnapshotService.restore_snapshot(snapshot_id)
       │   └─→ 从快照目录全量恢复项目文件
       │   └─→ 更新日志：phase = "files_restored"
       │
       ├─→ 4. 重建 GraphState
       │   └─→ 调用 initialize_project() 从磁盘文件重建状态
       │   └─→ 更新日志：phase = "state_rebuilt"
       │
       └─→ 5. 清理恢复日志
           └─→ RecoveryLogService.delete_log()
           └─→ 撤回完成

[结果]
- 项目文件恢复到目标快照版本
- GraphState 从磁盘文件重建，保持一致性
- 无分支历史，线性简洁
```

#### 2.5.1.4 崩溃恢复机制

> **设计目标**：处理撤回操作中途崩溃的场景，确保最终一致性

```
[应用启动时]
       │
       ├─→ 检查 .circuit_ai/recovery.json 是否存在
       │
       ├─→ 若不存在：正常启动
       │
       └─→ 若存在：检测到未完成的恢复操作
           │
           ├─→ phase = "files_restored"
           │   └─→ 文件已恢复，状态未重建
           │   └─→ 静默完成状态重建
           │   └─→ 显示通知："已自动恢复到迭代 N"
           │
           └─→ phase = "started"
               └─→ 恢复刚开始就失败，文件可能不一致
               └─→ 弹出对话框让用户选择：
                   [从备份恢复] [保持现状并手动检查]
```

---

### 2.5.2 GraphState 字段设计 (`application/graph/state.py`)

> **设计原则**：GraphState 是唯一真理来源，存储指针和摘要，不存储重数据

- [ ] **文件路径**：`application/graph/state.py`
- [ ] **职责**：定义 LangGraph 工作流的状态结构

#### 2.5.2.1 GraphState 字段定义

- [ ] **会话与模式控制**：
  - `session_id: str` - 会话标识，格式 YYYYMMDD_HHMMSS
  - `work_mode: str` - 工作模式（"workflow" | "free_work"）
  - `project_root: str` - 项目根目录路径
- [ ] **流转控制**：
  - `current_node: str` - 当前执行的节点名称
  - `previous_node: str` - 上一个执行的节点名称
  - `user_input: str` - 用户最新输入消息
  - `user_intent: str` - 用户意图类型
  - `is_completed: bool` - 是否完成
  - `termination_reason: str` - 终止原因
- [ ] **文件指针**（核心：存路径不存内容）：
  - `circuit_file_path: str` - 主电路文件相对路径
  - `sim_result_path: str` - 最新仿真结果文件相对路径
  - `design_goals_path: str` - 设计目标文件相对路径
- [ ] **轻量摘要**（用于条件边判断和 UI 显示）：
  - `design_goals_summary: dict` - 设计目标摘要（指标名称和目标值）
  - `last_metrics: dict` - 最新仿真指标摘要（如 `{"gain": "20dB", "bandwidth": "10MHz"}`）
  - `error_context: str` - 错误上下文（仿真失败时的错误信息）
- [ ] **计数器**：
  - `iteration_count: int` - 迭代次数
  - `checkpoint_count: int` - 检查点计数
  - `stagnation_count: int` - 停滞计数（连续未改善次数）
- [ ] **消息聚合**（LangGraph 内部使用）：
  - `messages: Annotated[list[AnyMessage], add_messages]` - 消息序列

#### 2.5.2.2 状态修改规范

- [ ] **图节点返回值模式**：
  - 图节点通过返回字典修改 GraphState
  - 返回值只包含需要更新的字段
  - 示例：`return {"sim_result_path": "sim_results/run_003.json", "last_metrics": {...}}`
- [ ] **禁止的操作**：
  - 禁止直接修改传入的 `state` 参数
  - 禁止在 GraphState 中存储大型数据（如完整仿真波形）
  - 禁止在异步任务中直接修改 GraphState

---

### 2.5.3 无状态领域服务设计

> **设计原则**：领域服务是纯函数式的"搬运工"，输入 → 处理 → 输出到文件 → 返回路径/摘要

#### 2.5.3.1 领域服务目录结构

```
domain/services/
├── __init__.py
├── design_service.py              # 设计目标读写服务
├── simulation_service.py          # 仿真执行服务（阶段四实现）
├── context_service.py             # 对话历史读写服务（阶段三实现）
├── rag_service.py                 # RAG 检索服务（阶段五实现）
├── iteration_history_service.py   # 迭代历史视图服务（从 SqliteSaver 查询）
├── snapshot_service.py            # 全量快照服务（线性快照栈）
└── recovery_log_service.py        # WAL 恢复日志服务（崩溃恢复）
```



#### 2.5.3.2 `design_service.py` - 设计目标服务

- [ ] **文件路径**：`domain/services/design_service.py`
- [ ] **职责**：提供设计目标的读写接口，数据存储在文件中
- [ ] **设计原则**：无状态，不持有任何内存数据
- [ ] **核心方法**：
  - `save_design_goals(project_root, goals) -> str` - 保存设计目标到文件，返回文件路径
  - `load_design_goals(project_root, file_path) -> dict` - 从文件加载设计目标
  - `get_goals_summary(goals) -> dict` - 提取设计目标摘要（用于存入 GraphState）
- [ ] **存储路径**：
  - 设计目标：`.circuit_ai/design_goals.json`
- [ ] **被调用方**：`design_goals_node`、`analysis_node`

#### 2.5.3.3 `simulation_service.py` - 仿真执行服务

- [ ] **文件路径**：`domain/services/simulation_service.py`
- [ ] **职责**：执行仿真并将结果存储到文件
- [ ] **设计原则**：无状态，仿真结果直接写入文件
- [ ] **核心方法**：
  - `run_simulation(project_root, circuit_file) -> tuple[str, dict]` - 执行仿真，返回 (结果文件路径, 指标摘要)
  - `load_sim_result(project_root, result_path) -> dict` - 从文件加载仿真结果
  - `extract_metrics(sim_data, goals) -> dict` - 提取性能指标摘要
- [ ] **存储路径**：
  - 仿真结果：`.circuit_ai/sim_results/{uuid}.json`
- [ ] **被调用方**：`simulation_node`

#### 2.5.3.4 `context_service.py` - 对话历史服务

- [ ] **文件路径**：`domain/services/context_service.py`
- [ ] **职责**：管理对话历史的读写
- [ ] **设计原则**：无状态，对话历史存储在文件/SQLite 中
- [ ] **核心方法**：
  - `save_messages(project_root, session_id, messages) -> None` - 保存消息到文件
  - `load_messages(project_root, session_id) -> list` - 加载消息历史
  - `append_message(project_root, session_id, message) -> None` - 追加单条消息
  - `get_recent_messages(project_root, session_id, limit) -> list` - 获取最近 N 条消息
- [ ] **存储路径**：
  - 对话历史：`.circuit_ai/conversations/{session_id}.json`
- [ ] **被调用方**：所有需要对话历史的图节点

#### 2.5.3.5 `rag_service.py` - RAG 检索服务

- [ ] **文件路径**：`domain/services/rag_service.py`
- [ ] **职责**：执行 RAG 检索，返回检索结果
- [ ] **设计原则**：无状态，检索结果不缓存在内存中
- [ ] **核心方法**：
  - `retrieve(query, top_k) -> list[SearchResult]` - 执行检索，返回结果列表
  - `get_index_status() -> dict` - 获取索引状态
- [ ] **存储**：
  - 向量索引由 ChromaDB 管理，不在本服务中持有
- [ ] **被调用方**：`rag_node`、`free_work_node`

#### 2.5.3.6 `iteration_history_service.py` - 迭代历史视图服务

> **设计理念**：迭代历史是 GraphState 历史版本的视图投影，不独立存储，避免双写一致性问题

- [ ] **文件路径**：`domain/services/iteration_history_service.py`
- [ ] **职责**：从 SqliteSaver 查询 GraphState 历史，提供迭代历史视图
- [ ] **设计原则**：
  - 只读服务，不写入任何数据
  - 迭代历史是 GraphState 检查点的派生视图
  - 每次查询实时从 SqliteSaver 获取，保证数据一致性
- [ ] **核心方法**：
  - `get_iteration_history(checkpointer, thread_id) -> list[IterationRecord]` - 获取迭代历史列表
  - `get_iteration_detail(checkpointer, thread_id, checkpoint_id) -> IterationRecord` - 获取单次迭代详情
  - `get_latest_iteration(checkpointer, thread_id) -> IterationRecord` - 获取最新迭代
- [ ] **IterationRecord 数据结构**：
  - `checkpoint_id: str` - 检查点 ID
  - `iteration_count: int` - 迭代次数
  - `metrics: dict` - 仿真指标摘要（从 `last_metrics` 提取）
  - `goals_summary: dict` - 设计目标摘要
  - `timestamp: str` - 创建时间
  - `node_name: str` - 当时执行的节点名称
- [ ] **查询逻辑**：
  - 调用 `checkpointer.list()` 获取检查点列表
  - 从每个检查点的 GraphState 中提取 `iteration_count`、`last_metrics` 等字段
  - 组装为 `IterationRecord` 返回
- [ ] **被调用方**：迭代历史面板 UI、`analysis_node`（用于判断停滞）

---

### 2.5.4 全量快照服务

> **设计理念**：使用 Python 标准库 shutil 实现全量文件快照，简单可靠，避免重造轮子
> 
> **为什么不用增量快照**：电路设计项目文件通常在 KB 级别，全量拷贝在毫秒级完成。自制增量快照（内容寻址、哈希去重、变更追踪）本质上是重新实现 Git，复杂度高、边缘情况多、维护成本大，收益却很小。
>
> **线性快照栈**：快照按时间顺序形成线性栈，撤回时弹出栈顶，不支持分支

#### 2.5.4.1 快照服务目录结构

```
domain/services/
├── ...
├── snapshot_service.py     # 全量快照服务
└── recovery_log_service.py # WAL 恢复日志服务
```

#### 2.5.4.2 `snapshot_service.py` - 全量快照服务

- [ ] **文件路径**：`domain/services/snapshot_service.py`
- [ ] **职责**：提供项目文件的全量快照创建、恢复、清理功能，管理线性快照栈
- [ ] **设计原则**：
  - 使用 `shutil.copytree` 实现全量拷贝，依赖标准库的可靠性
  - 无状态设计，不持有内存数据
  - 线性快照栈：快照按时间顺序排列，撤回时恢复上一个快照
  - 简单的保留策略：只保留最近 N 个快照（默认 10 个）
- [ ] **同步核心方法**（底层实现，禁止 UI 线程直接调用）：
  - `create_snapshot(project_root, snapshot_id) -> str` - 创建全量快照，返回快照路径
  - `restore_snapshot(project_root, snapshot_id, backup_current) -> None` - 从快照恢复项目文件
  - `list_snapshots(project_root) -> List[SnapshotInfo]` - 列出所有快照（按时间倒序）
  - `delete_snapshot(project_root, snapshot_id) -> None` - 删除指定快照
  - `cleanup_old_snapshots(project_root, keep_count) -> int` - 清理旧快照，返回删除数量
  - `get_previous_snapshot(project_root) -> Optional[SnapshotInfo]` - 获取上一个快照（用于撤回）
  - `pop_snapshot(project_root) -> Optional[str]` - 弹出并删除最新快照（撤回后清理）
- [ ] **异步包装方法**（应用层接口，供 LangGraph 节点和 UI 调用）：
  - `create_snapshot_async(project_root, snapshot_id) -> str` - 异步创建快照
  - `restore_snapshot_async(project_root, snapshot_id, backup_current) -> None` - 异步恢复快照
  - `list_snapshots_async(project_root) -> List[SnapshotInfo]` - 异步列出快照
  - `delete_snapshot_async(project_root, snapshot_id) -> None` - 异步删除快照
  - `cleanup_old_snapshots_async(project_root, keep_count) -> int` - 异步清理旧快照
- [ ] **异步实现原理**：
  - 使用 `asyncio.to_thread()` 将 `shutil.copytree` 等阻塞操作卸载到线程池
  - 主线程（事件循环）不阻塞，UI 保持响应
  - 快照操作可能涉及大量文件，异步化尤为重要
- [ ] **SnapshotInfo 数据结构**：
  - `snapshot_id: str` - 快照标识
  - `timestamp: str` - 创建时间（ISO 格式）
  - `size_bytes: int` - 快照大小（字节）
  - `file_count: int` - 文件数量
  - `iteration_count: int` - 对应的迭代次数
- [ ] **快照 ID 命名规则**：
  - 格式：`iter_{iteration_count:03d}_{timestamp}`
  - 示例：`iter_001_20241220_143022`
  - 按字典序排列即为时间顺序
- [ ] **忽略规则**：
  - 快照时忽略：`.circuit_ai/snapshots/`、`__pycache__/`、`.git/`、`*.pyc`
  - 使用 `shutil.ignore_patterns()` 实现
- [ ] **存储路径**：
  - 快照目录：`.circuit_ai/snapshots/{snapshot_id}/`
  - 每个快照是项目文件的完整副本
- [ ] **错误处理**：
  - 快照创建失败时清理不完整的快照目录
  - 恢复失败时保留原文件不变
  - 磁盘空间不足时抛出明确异常
- [ ] **被调用方**：`user_checkpoint_node`、`undo_node`（必须使用异步方法）

#### 2.5.4.3 `recovery_log_service.py` - WAL 恢复日志服务

> **设计理念**：使用 Write-Ahead Log 模式处理撤回操作中途崩溃的场景，确保最终一致性

- [ ] **文件路径**：`domain/services/recovery_log_service.py`
- [ ] **职责**：管理撤回操作的恢复日志，支持崩溃恢复
- [ ] **设计原则**：
  - 原子写入：使用 "写临时文件 + os.replace" 保证日志文件完整性
  - 简单结构：JSON 格式，包含操作类型、阶段、目标快照等信息
  - 启动时检查：应用启动时检测未完成的恢复操作
- [ ] **核心方法**：
  - `write_log(project_root, log_data) -> None` - 原子写入恢复日志
  - `read_log(project_root) -> Optional[RecoveryLog]` - 读取恢复日志
  - `delete_log(project_root) -> None` - 删除恢复日志
  - `has_pending_recovery(project_root) -> bool` - 检查是否有未完成的恢复
  - `update_phase(project_root, phase) -> None` - 更新恢复阶段
- [ ] **RecoveryLog 数据结构**：
  ```python
  {
      "action": str,           # 操作类型（"undo"）
      "target_snapshot": str,  # 目标快照 ID
      "phase": str,            # 当前阶段（"started" | "files_restored" | "state_rebuilt" | "completed" | "failed"）
      "started_at": str,       # 开始时间（ISO 格式）
      "error": Optional[str],  # 错误信息（失败时）
  }
  ```
- [ ] **恢复阶段定义**：
  - `started` - 恢复操作刚开始
  - `files_restored` - 文件已恢复，状态未重建
  - `state_rebuilt` - 状态已重建，即将完成
  - `completed` - 恢复完成（日志将被删除）
  - `failed` - 恢复失败
- [ ] **原子写入实现**：
  ```python
  def write_log(project_root: str, log_data: dict) -> None:
      log_path = Path(project_root) / ".circuit_ai" / "recovery.json"
      tmp_path = log_path.with_suffix(".json.tmp")
      
      content = json.dumps(log_data, indent=2)
      tmp_path.write_text(content, encoding="utf-8")
      os.replace(tmp_path, log_path)  # 原子操作
  ```
- [ ] **存储路径**：
  - 恢复日志：`.circuit_ai/recovery.json`
- [ ] **被调用方**：`undo_node`、`bootstrap.py`（启动时检查）



---

### 2.5.5 与 LangGraph Checkpointer 的协作

> **简化设计**：LangGraph SqliteSaver 仅用于工作流执行期间的状态持久化，撤回操作不依赖 Time Travel 机制

#### 2.5.5.1 检查点创建流程

```
[图节点执行完成]
       │
       ├─→ 图节点调用领域服务
       │   └─→ 领域服务将数据写入文件
       │       └─→ 返回文件路径和摘要
       │
       ├─→ 图节点返回 GraphState 更新
       │   └─→ {"sim_result_path": "...", "last_metrics": {...}}
       │
       ├─→ LangGraph 运行时调用 SqliteSaver
       │   └─→ 保存 GraphState 到 SQLite
       │
       └─→ 在检查点节点调用 SnapshotService
           └─→ 使用 shutil.copytree 创建项目文件的全量快照
           └─→ 自动清理超出保留数量的旧快照
```

#### 2.5.5.2 线性撤回流程

> **⚠️ 关键设计**：撤回操作不使用 LangGraph Time Travel，而是通过文件快照恢复 + GraphState 重建实现

```
[用户请求撤回]
       │
       ├─→ 1. 预检查
       │   └─→ 验证上一个快照存在
       │   └─→ 验证磁盘空间足够
       │
       ├─→ 2. 写入恢复日志
       │   └─→ RecoveryLogService.write_log({phase: "started"})
       │
       ├─→ 3. 恢复文件快照
       │   └─→ SnapshotService.restore_snapshot(previous_snapshot_id)
       │   └─→ 更新日志：phase = "files_restored"
       │
       ├─→ 4. 重建 GraphState
       │   └─→ 停止当前工作流
       │   └─→ 调用 initialize_project() 从磁盘文件重建状态
       │   └─→ 更新日志：phase = "state_rebuilt"
       │
       ├─→ 5. 清理
       │   └─→ 删除当前快照（已被恢复的快照替代）
       │   └─→ 删除恢复日志
       │
       └─→ 6. 恢复工作流
           └─→ 从 user_checkpoint_node 继续
```

#### 2.5.5.3 快照 ID 与迭代的关联

- [ ] **ID 生成规则**：
  - 格式：`iter_{iteration_count:03d}_{timestamp}`
  - 示例：`iter_001_20241220_143022`
- [ ] **线性栈管理**：
  - 快照按时间顺序形成线性栈
  - 撤回时恢复上一个快照，删除当前快照
  - 不支持跳跃撤回（只能撤回到上一个迭代）
- [ ] **快照保留策略**：
  - 默认保留最近 10 个快照
  - 每次创建新快照后自动清理超出数量的旧快照
  - 可通过配置调整保留数量

---

### 2.5.6 存储目录结构

```
{project_root}/
├── amplifier.cir                    # 用户电路文件（快照管理）
├── parameters.json                  # 用户参数文件（快照管理）
└── .circuit_ai/
    ├── checkpoints.sqlite3          # LangGraph GraphState 版本（SqliteSaver 管理）
    │                                # 仅用于工作流执行期间，撤回不依赖此文件
    ├── recovery.json                # 恢复日志（RecoveryLogService 管理）
    │                                # 仅在撤回操作期间存在，完成后删除
    ├── design_goals.json            # 设计目标（单文件覆盖更新）
    ├── sim_results/                 # 仿真结果目录
    │   ├── run_001.json
    │   └── run_002.json
    ├── conversations/               # 对话历史目录
    │   └── 20241220_143022.json
    └── snapshots/                   # 全量快照目录（SnapshotService 管理）
        ├── iter_001_20241220_143022/  # 迭代 1 快照（完整项目副本）
        │   ├── amplifier.cir
        │   ├── parameters.json
        │   └── .snapshot_meta.json    # 快照元数据
        └── iter_002_20241220_143500/  # 迭代 2 快照（完整项目副本）
            ├── amplifier.cir
            ├── parameters.json
            └── .snapshot_meta.json
```

> **目录管理职责划分**：
> - **快照管理**（SnapshotService）：项目根目录下的用户文件（.cir、.json 等）
> - **恢复日志**（RecoveryLogService）：`.circuit_ai/recovery.json`
> - **LangGraph 管理**：`.circuit_ai/checkpoints.sqlite3`
> - **自管理**：`.circuit_ai/snapshots/`（由 SnapshotService 的 cleanup_old_snapshots 管理）

> **磁盘空间估算**：假设每个快照 500KB，保留 10 个快照约 5MB，完全可接受
> 
> **迭代历史说明**：迭代历史不再作为独立文件存储，而是从 `checkpoints.sqlite3` 中的 GraphState 历史版本派生。这避免了 SQLite 和 JSON 文件之间的双写一致性问题。

---

### 2.5.7 阶段检查点

#### 2.5.7.1 架构验证检查项

- [ ] GraphState 字段定义完整，包含文件指针和摘要字段
- [ ] 领域服务为无状态设计，不持有内存数据
- [ ] 领域服务正确读写文件
- [ ] 图节点通过返回值更新 GraphState
- [ ] 迭代历史从 SqliteSaver 查询，不独立存储

#### 2.5.7.2 快照服务验证检查项

- [ ] `create_snapshot()` 正确创建项目文件的全量副本
- [ ] `restore_snapshot()` 正确恢复项目文件
- [ ] `cleanup_old_snapshots()` 正确清理超出保留数量的旧快照
- [ ] `get_previous_snapshot()` 正确返回上一个快照
- [ ] `pop_snapshot()` 正确弹出并删除最新快照
- [ ] 快照忽略规则正确（不拷贝 `.circuit_ai/snapshots/`、`__pycache__/` 等）
- [ ] 快照创建失败时正确清理不完整的快照目录
- [ ] 快照 ID 命名规则正确（`iter_{count}_{timestamp}`）

#### 2.5.7.3 恢复日志服务验证检查项

- [ ] `write_log()` 使用原子写入（写临时文件 + os.replace）
- [ ] `read_log()` 正确解析恢复日志
- [ ] `has_pending_recovery()` 正确检测未完成的恢复
- [ ] `update_phase()` 正确更新恢复阶段
- [ ] `delete_log()` 正确删除恢复日志
- [ ] 日志文件损坏时正确处理（JSON 解析失败）

#### 2.5.7.4 迭代历史视图服务验证检查项

- [ ] `get_iteration_history()` 正确从 SqliteSaver 查询检查点列表
- [ ] `IterationRecord` 正确提取 `iteration_count`、`last_metrics` 等字段
- [ ] 查询结果与 GraphState 历史版本一致
- [ ] 无独立的 `iteration_history.json` 文件存在

#### 2.5.7.5 集成验证检查项

- [ ] LangGraph SqliteSaver 正常持久化 GraphState
- [ ] 快照 ID 与迭代次数正确关联
- [ ] 撤回后项目文件内容正确恢复
- [ ] 撤回后 GraphState 正确重建
- [ ] 崩溃恢复机制正常工作

#### 2.5.7.6 崩溃恢复验证检查项

- [ ] 启动时正确检测 `recovery.json` 存在
- [ ] `phase = "files_restored"` 时静默完成状态重建
- [ ] `phase = "started"` 时弹出对话框让用户选择
- [ ] 恢复完成后正确删除恢复日志
- [ ] 恢复失败时正确记录错误信息

#### 2.5.7.7 性能验证检查项

- [ ] 快照创建时间在毫秒级（小项目，KB 级文件）
- [ ] 快照恢复时间在毫秒级（小项目）
- [ ] 10 个快照的磁盘占用在合理范围内（< 10MB）
- [ ] 迭代历史查询响应时间可接受（< 100ms）
