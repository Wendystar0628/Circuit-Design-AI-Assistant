## 阶段二：文件管理与代码编辑 (2周)

> **目标**：实现文件系统操作、项目初始化，完成文件浏览器和代码编辑器面板
> 
> **启动流程**：扩展 Phase 3（文件相关领域服务）、Phase 5（file_watcher_worker）

> **⚠️ 本阶段统一管理提示**：
> - 本阶段建立 FileManager，后续所有文件操作必须通过它进行
> - 文件变更需发布 `EVENT_FILE_CHANGED` 事件，禁止直接使用 `open()`
> - 智能文件搜索通过 `file_search_service` 进行，禁止直接遍历文件系统
> - 符号定位通过 `location_service` 进行，禁止直接解析文件
> - 新增 UI 面板需实现 `retranslate_ui()` 方法

> **⚠️ 异步 I/O 架构原则**：
> - **双层接口设计**：`FileManager` 提供同步底层接口，`AsyncFileOps` 提供异步应用层接口
> - **UI 线程禁止同步 I/O**：UI 层和 LangGraph 节点必须使用 `AsyncFileOps` 的异步方法
> - **线程安全**：通过 `asyncio.to_thread()` 将阻塞操作卸载到线程池，避免阻塞事件循环
> - **锁竞争规避**：UI 线程不直接调用同步方法，避免与工作线程竞争 `FileLock`

> **⚠️ 与其他阶段的职责边界**：
> - **本阶段**：轻量级文件解析（符号提取、结构大纲）、精确搜索（正则/模糊/符号）、符号定位
> - **阶段3**：电路依赖图分析（`domain/llm/context_retrieval/dependency_analyzer.py`）用于 LLM 上下文构建
> - **阶段5**：深度文档分块、向量索引、语义检索、**统一搜索门面**（`UnifiedSearchService`）
> - 本阶段的 `FileSearchService` 是底层精确搜索引擎，阶段5的 `UnifiedSearchService` 统一对外暴露搜索能力
> - LLM 工具调用统一通过阶段5的 `UnifiedSearchService`，不直接调用本阶段的 `FileSearchService`

> **⚠️ 跨阶段依赖检查**：
> - 开始本阶段前，必须确认阶段一的以下模块已正确实现：
>   - `shared/service_locator.py` - 确认 `register()`、`get()` 接口
>   - `shared/event_bus.py` - 确认 `publish()`、`subscribe()` 接口
>   - `infrastructure/utils/logger.py` - 确认 `get_logger()` 接口
> - 读取上述源码，确认接口签名与文档一致

### 2.1 持久化模块 (`infrastructure/persistence/`)

> **模块组织**：持久化模块包含以下文件：
> - `file_manager.py` - 统一文件操作管理器（同步底层接口）
> - `async_file_ops.py` - 异步文件操作门面（应用层接口，含 JSON 操作）
> - `file_exceptions.py` - 文件操作异常类定义
> - `file_lock.py` - 文件锁管理（进程内并发控制）
> - `content_hash.py` - 内容哈希计算器（标准化哈希计算）
> - `file_version_tracker.py` - 文件版本追踪器（TOCTOU 竞态条件检测）
>
> **JSON 操作说明**：
> - JSON 序列化/反序列化使用 `infrastructure/utils/json_utils.py` 提供的工具函数
> - 异步 JSON 文件操作通过 `AsyncFileOps` 的 `load_json_async` / `save_json_async` 方法
> - 不再使用独立的 `JsonRepository` 类，减少抽象层级

#### 2.1.1 `file_exceptions.py` - 文件操作异常类

- [ ] **职责**：集中定义文件操作相关的异常类，供 `file_manager.py` 和外部调用方使用
- [ ] **异常类清单**：
  - `FileManagerError` - 文件管理器基础异常（所有异常的父类）
  - `PathSecurityError` - 路径安全校验失败
  - `FileExistsError` - 文件已存在且内容不同
  - `DirectoryCreationError` - 目录创建失败
  - `SearchNotFoundError` - 搜索内容未找到
  - `MultipleMatchError` - 搜索内容匹配多处
  - `LineRangeError` - 行号范围错误
  - `FileLockTimeoutError` - 文件锁获取超时
  - `FileOperationError` - 文件操作失败
- [ ] **被调用方**：`file_manager.py`、`tool_executor.py`、各需要捕获文件异常的模块

#### 2.1.2 `file_lock.py` - 文件锁管理

- [ ] **职责**：提供进程内文件锁定机制，防止同一进程内的并发写入导致数据损坏
- [ ] **核心类**：`FileLock`
- [ ] **核心功能**：
  - `acquire()` - 获取文件锁，支持超时等待
  - `release()` - 释放文件锁
  - 支持上下文管理器（`with` 语句）
- [ ] **实现方式**：使用 `threading.Lock` 实现进程内锁定
- [ ] **默认超时**：5 秒
- [ ] **职责边界说明**：
  - FileLock 解决的问题：同一进程内多个线程同时写入同一文件
  - FileLock 不解决的问题：LLM "读取-思考-写入"期间用户修改文件的竞态条件
  - TOCTOU 竞态条件由 `FileVersionTracker`（2.1.6 节）通过乐观锁机制解决
- [ ] **线程安全说明**：
  - `FileLock` 基于 `threading.Lock`，锁的获取和释放必须在同一线程内闭环
  - 通过 `asyncio.to_thread()` 调用时，锁操作在工作线程内完成，不会跨线程
  - UI 线程禁止直接调用持有锁的同步方法，避免与工作线程竞争
  - 若 UI 线程需要访问文件，必须通过 `AsyncFileOps` 异步接口
- [ ] **被调用方**：`file_manager.py`（内部使用）

#### 2.1.3 `file_manager.py` - 统一文件操作管理器（同步底层接口）

> **初始化顺序**：Phase 3.2（延迟初始化），依赖 Logger、EventBus，阶段一预留占位

> **⚠️ 接口层级说明**：
> - 本模块是**同步底层接口**，所有方法都是阻塞的
> - **禁止 UI 线程直接调用**本模块的任何方法
> - 应用层（UI、LangGraph 节点）必须通过 `AsyncFileOps` 访问文件
> - 仅供 `AsyncFileOps` 内部调用，或在已确认非 UI 线程的场景使用

- [ ] **职责**：提供统一、安全的文件系统操作接口（同步实现）
- [ ] **依赖**：`file_exceptions.py`（异常类）、`file_lock.py`（文件锁）
- [ ] **工作目录管理**：
  - `set_work_dir(path)` - 设置当前工作目录（由 `ProjectService` 在打开项目时调用）
  - `get_work_dir()` - 获取当前工作目录
  - `resolve_path(relative_path)` - 将相对路径转换为绝对路径（基于工作目录）
  - `to_relative_path(absolute_path)` - 将绝对路径转换为相对路径（用于显示和存储）
- [ ] **相对路径转换机制**：
  - 所有对外接口接受相对路径，内部自动转换为绝对路径执行操作
  - LLM 生成的路径（如 `subcircuits/opamp.cir`）自动解析为 `{work_dir}/subcircuits/opamp.cir`
  - 返回给 LLM 的路径统一使用相对路径格式
  - 此机制确保项目可移植，不同用户打开同一项目时路径自动适配
- [ ] **核心功能**：
  - `read_file(path)` - 读取文件内容（文本/二进制）
  - `write_file(path, content)` - 写入文件（原子性写入：先写临时文件再重命名）
  - `create_file(path, content)` - 创建新文件，支持幂等性检查
  - `patch_file(path, search, replace, occurrence, fuzzy)` - 定位修改文件内容（优先使用，支持模糊匹配）
  - `patch_file_by_line(path, start_line, end_line, new_content)` - 按行号范围修改文件内容
  - `rewrite_file(path, content)` - 小文件整体重写（≤150行时优先使用）
  - `update_file(path, content)` - 整体替换文件内容（降级方案）
  - `delete_file(path)` - 删除文件
  - `ensure_directory(path)` - 确保目录存在
  - `list_directory(path, pattern)` - 列出目录内容，支持glob模式
  - `file_exists(path)` - 检查文件是否存在
  - `get_file_info(path)` - 获取文件元信息（大小、修改时间）
  - `acquire_lock(path)` - 获取文件锁（防止并发写入）
  - `release_lock(path)` - 释放文件锁
  - `cleanup_temp_files()` - 清理临时文件
- [ ] **`create_file` 方法详细设计**：
  - 功能：创建新文件，若文件已存在则进行幂等性检查
  - 参数：`path`（文件路径）、`content`（文件内容）
  - 返回值：成功时返回 True
  - 执行流程：
    1. 校验路径安全性
    2. 检查文件是否已存在
    3. 若文件存在 → 执行幂等性检查
    4. 若文件不存在 → 确保父目录存在，创建文件
    5. 原子性写入文件
    6. 发布 `EVENT_FILE_CHANGED` 事件
  - 幂等性检查流程：
    1. 计算现有文件内容的哈希值
    2. 计算目标内容的哈希值
    3. 若哈希相同 → 返回成功（文件已存在且内容一致），不执行写入
    4. 若哈希不同 → 抛出 `FileExistsError`，提示文件已存在但内容不同
  - 失败场景处理：
    - 文件已存在且内容不同：抛出 `FileExistsError`，由 LLM 决定是否改用 `update_file`
    - 父目录创建失败：抛出 `DirectoryCreationError`
- [ ] **`patch_file` 方法详细设计**：
  - 功能：在文件中查找指定内容并替换为新内容
  - 参数：
    - `path`（文件路径）
    - `search`（搜索内容）
    - `replace`（替换内容）
    - `occurrence`（匹配第几处，默认1，0表示全部）
    - `fuzzy`（是否启用模糊匹配，默认 False）
  - 返回值：成功时返回替换次数，失败时抛出异常
  - **模糊匹配模式**（`fuzzy=True` 时启用）：
    - 忽略空白字符差异（连续空格、制表符、行尾空格）
    - 忽略空行差异
    - 使用相似度匹配（阈值 0.9），找到最相似的内容块
    - 适用场景：SPICE 文件格式不规范、手动编辑后空白字符变化
    - 匹配成功后返回实际匹配到的原始内容，便于调试
  - 执行流程：
    1. 校验路径安全性（在工作目录内）
    2. 获取文件锁
    3. 读取文件完整内容
    4. 执行幂等性检查（见下方）
    5. 查找 search 内容的所有匹配位置
    6. 根据 occurrence 参数决定替换哪些匹配
    7. 执行替换操作
    8. 原子性写入文件（先写 .tmp 再重命名）
    9. 释放文件锁
    10. 发布 `EVENT_FILE_CHANGED` 事件
  - 幂等性检查流程：
    1. 检查 search 内容是否存在于文件中
    2. 若 search 不存在，检查 replace 内容是否已存在
    3. 若 replace 已存在 → 返回成功（内容已是目标状态），不执行写入
    4. 若 search 和 replace 都不存在 → 抛出 `SearchNotFoundError`
    5. 若 search 存在 → 继续执行替换
  - 失败场景处理：
    - 搜索内容不存在且 replace 也不存在：抛出 `SearchNotFoundError`，包含搜索内容摘要
    - 匹配多处但未指定 occurrence：抛出 `MultipleMatchError`，包含匹配数量和位置
    - 文件不存在：抛出 `FileNotFoundError`
    - 文件锁获取超时：抛出 `FileLockTimeoutError`
  - 与 `update_file` 的关系：`patch_file` 失败时，LLM 可降级使用 `update_file` 整体替换
- [ ] **`patch_file_by_line` 方法详细设计**：
  - 功能：通过行号范围定位并替换文件内容
  - 适用场景：文件中存在重复内容（如多个同名参数），仅靠内容匹配无法精确定位
  - 参数：
    - `path`（文件路径）
    - `start_line`（起始行号，从 1 开始）
    - `end_line`（结束行号，包含该行）
    - `new_content`（替换内容）
  - 返回值：成功时返回被替换的原始内容，失败时抛出异常
  - 执行流程：
    1. 校验路径安全性
    2. 获取文件锁
    3. 读取文件完整内容，按行分割
    4. 校验行号范围有效性（不超出文件总行数）
    5. 提取指定行范围的原始内容
    6. 执行幂等性检查（原始内容与 new_content 比对）
    7. 若内容相同 → 返回成功，不执行写入
    8. 若内容不同 → 替换指定行范围
    9. 原子性写入文件
    10. 释放文件锁
    11. 发布 `EVENT_FILE_CHANGED` 事件
  - 失败场景处理：
    - 行号超出范围：抛出 `LineRangeError`，包含文件总行数
    - 文件不存在：抛出 `FileNotFoundError`
    - 文件锁获取超时：抛出 `FileLockTimeoutError`
  - 使用建议：LLM 应先用 `read_file` 查看文件内容和行号，再使用此方法精确修改
- [ ] **`rewrite_file` 方法详细设计**：
  - 功能：小文件整体重写，直接用新内容替换整个文件
  - 适用场景：文件行数 ≤150 行时优先使用，降低 LLM 生成 search 内容出错的概率
  - 参数：`path`（文件路径）、`content`（完整的新文件内容）
  - 返回值：成功时返回 True
  - 与 `update_file` 的区别：
    - `update_file` 要求文件必须存在
    - `rewrite_file` 文件不存在时自动创建
  - 执行流程：
    1. 校验路径安全性
    2. 确保父目录存在
    3. 若文件存在 → 执行幂等性检查（比对哈希）
    4. 若哈希相同 → 返回成功，不执行写入
    5. 若哈希不同或文件不存在 → 原子性写入文件
    6. 发布 `EVENT_FILE_CHANGED` 事件
  - 行数阈值说明：
    - 150 行代码约 750-1500 tokens，在 LLM 输出上限内安全
    - SPICE 文件结构简单，可放宽至 200 行
    - 配置文件（JSON/YAML）建议 100 行
- [ ] **`update_file` 方法详细设计**：
  - 功能：用新内容完全替换整个文件
  - 参数：`path`（文件路径）、`content`（完整的新文件内容）
  - 返回值：成功时返回 True
  - 执行流程：
    1. 校验路径安全性
    2. 获取文件锁
    3. 执行幂等性检查（比对现有内容哈希与目标内容哈希）
    4. 若哈希相同 → 返回成功，不执行写入
    5. 若哈希不同 → 原子性写入文件
    6. 释放文件锁
    7. 发布 `EVENT_FILE_CHANGED` 事件
  - 使用场景：`patch_file` 失败时的降级方案、文件结构大幅变更时
- [ ] **统一访问原则**：
  - 本模块是同步底层实现，禁止 UI 线程直接调用
  - 应用层必须通过 `AsyncFileOps` 进行文件操作
  - 文件变更自动触发 `EVENT_FILE_CHANGED` 事件
- [ ] **文件锁定机制**：
  - 写入前自动获取文件锁（防止进程内并发写入）
  - 支持超时等待（默认5秒）
  - 锁定失败返回明确错误
  - 注意：FileLock 仅防止进程内并发，不解决 LLM 工具调用的 TOCTOU 问题
  - TOCTOU 竞态条件由 `FileVersionTracker` 在工具执行层解决
- [ ] **安全校验**：
  - 用户可选择电脑上任意目录作为工作目录（类似 VSCode 的打开文件夹功能）
  - 安全校验仅拒绝操作系统关键目录（如 Windows 系统目录、Linux /etc 等）
  - 拒绝操作 `.git/objects`、`.git/hooks` 等 Git 内部目录
  - 符号链接指向的目标路径同样需要通过安全校验
- [ ] **输入校验原则**：所有外部输入的路径在操作前必须校验，不信任 LLM 生成的路径
- [ ] **原子性写入实现**：写入 `{filename}.tmp` → `os.replace()` 重命名为目标文件
- [ ] **临时文件管理**：
  - 临时文件统一存放在 `.circuit_ai/temp/`
  - 应用启动时自动清理过期临时文件（超过24小时）
  - 提供手动清理接口
- [ ] **与EventBus集成**：
  - 文件创建/修改/删除时发布 `EVENT_FILE_CHANGED` 事件
  - `file_watcher_worker` 订阅事件进行增量索引
- [ ] **被调用方**：`async_file_ops.py`（异步包装层）、确认非 UI 线程的内部模块

#### 2.1.4 `async_file_ops.py` - 异步文件操作门面（应用层接口）

> **初始化顺序**：Phase 3.3，依赖 FileManager，注册到 ServiceLocator

> **⚠️ 这是应用层的唯一文件操作入口**：
> - UI 层、LangGraph 节点、LLM 工具调用必须使用本模块
> - 所有方法都是 `async def`，通过 `asyncio.to_thread()` 包装同步操作
> - 确保事件循环不被阻塞，UI 保持响应

- [ ] **文件路径**：`infrastructure/persistence/async_file_ops.py`
- [ ] **职责**：为应用层提供非阻塞的异步文件操作接口
- [ ] **依赖**：`file_manager.py`（同步底层实现）
- [ ] **核心类**：`AsyncFileOps`
- [ ] **核心功能**（所有方法均为 `async def`）：
  - `read_file_async(path, binary, encoding)` - 异步读取文件
  - `write_file_async(path, content, encoding)` - 异步写入文件
  - `create_file_async(path, content, encoding)` - 异步创建文件
  - `patch_file_async(path, search, replace, occurrence, fuzzy)` - 异步定位修改
  - `patch_file_by_line_async(path, start_line, end_line, new_content)` - 异步按行修改
  - `rewrite_file_async(path, content)` - 异步重写文件
  - `update_file_async(path, content)` - 异步更新文件
  - `delete_file_async(path)` - 异步删除文件
  - `file_exists_async(path)` - 异步检查文件存在
  - `list_directory_async(path, pattern, recursive)` - 异步列出目录
  - `get_file_info_async(path)` - 异步获取文件信息
  - `read_multiple_files_async(paths, max_workers)` - 并发读取多个文件
- [ ] **实现原理**：
  - 使用 `asyncio.to_thread()` 将同步 `FileManager` 方法卸载到线程池
  - 线程池内部执行时，锁的获取和释放在同一线程内闭环
  - 主线程（事件循环）不阻塞，UI 保持响应
- [ ] **并发文件读取**（`read_multiple_files_async`）：
  - 使用 `asyncio.gather()` 并发调度多个 `to_thread` 任务
  - 适用于上下文检索、批量文件分析等场景
  - 参数 `max_workers` 控制并发数（默认 10）
  - 返回 `Dict[str, Union[str, Exception]]`，失败的文件返回异常对象
- [ ] **错误处理**：
  - 异常从工作线程传播到调用方
  - 保持与 `FileManager` 相同的异常类型
  - 调用方可正常使用 `try/except` 捕获
- [ ] **使用示例**：
  ```python
  from infrastructure.persistence.async_file_ops import AsyncFileOps
  
  async_ops = AsyncFileOps()
  
  # 单文件读取
  content = await async_ops.read_file_async("main.cir")
  
  # 并发读取多个文件
  results = await async_ops.read_multiple_files_async([
      "main.cir", "subcircuits/opamp.cir", "parameters/values.json"
  ])
  ```
- [ ] **被调用方**：`tool_executor.py`（LLM工具调用）、`project_service.py`（项目初始化）、各领域服务、代码编辑器面板、LangGraph 节点
- [ ] **JSON 异步操作**（基于 `json_utils.py` 封装）：
  - `load_json_async(path, default=None)` - 异步加载 JSON 文件，解析失败返回默认值
  - `save_json_async(path, data, indent=2)` - 异步保存数据为 JSON 文件
- [ ] **JSON 操作实现原理**：
  - 读取：`read_file_async` + `json_utils.safe_json_loads`
  - 写入：`json_utils.safe_json_dumps` + `write_file_async`
  - 复合操作（读-改-写）由调用方在 Service 层组合实现，不在此层封装
- [ ] **JSON 使用场景**：
  - `design_goals.json` - 设计目标存储
  - `recent_projects.json` - 最近打开项目列表
- [ ] **JSON 操作说明**：
  - 对话历史由 Checkpointer 统一管理，不使用独立 JSON 文件
  - 迭代历史从 SqliteSaver 查询，不独立存储（避免双写一致性问题）

#### 2.1.5 `content_hash.py` - 内容哈希计算器

> **设计背景**：LLM 工具调用存在"读取-思考-写入"的时间窗口（可能长达 10-30 秒），期间用户可能在编辑器中修改并保存文件。若 LLM 基于旧内容生成修改方案并写入，会覆盖用户的修改。需要通过内容哈希校验检测此类冲突。

- [ ] **文件路径**：`infrastructure/persistence/content_hash.py`
- [ ] **职责**：提供标准化的内容哈希计算，确保不同来源的相同内容产生相同哈希
- [ ] **核心功能**：
  - `compute_content_hash(content: str) -> str` - 计算内容哈希（SHA-256）
  - `compute_file_hash(file_path: str) -> str` - 计算文件内容哈希
  - `normalize_content(content: str) -> str` - 规范化内容（处理换行符差异）
- [ ] **规范化规则**：
  - 统一换行符为 LF（`\r\n` → `\n`，`\r` → `\n`）
  - 不去除末尾换行符（保留 POSIX 规范的文件末尾换行）
  - 不去除行尾空格（保持内容原样，仅处理换行符）
- [ ] **规范化原因**：
  - Windows 上 Qt 编辑器可能使用 CRLF
  - Python `open()` 在不同模式下换行符处理不同
  - 不规范化会导致相同内容产生不同哈希，造成误报冲突
- [ ] **哈希算法**：SHA-256（安全性足够，性能可接受）
- [ ] **使用示例**：
  ```python
  from infrastructure.persistence.content_hash import compute_content_hash
  
  # 计算内容哈希
  hash1 = compute_content_hash("R1 10K\nR2 20K\n")
  hash2 = compute_content_hash("R1 10K\r\nR2 20K\r\n")
  assert hash1 == hash2  # 换行符差异被规范化
  ```
- [ ] **被调用方**：`file_version_tracker.py`、`file_manager.py`（幂等性检查）

#### 2.1.6 `file_version_tracker.py` - 文件版本追踪器

> **设计背景**：解决 LLM 工具调用中的 TOCTOU（Time-of-check to time-of-use）竞态条件。
> 当 LLM 读取文件后，用户可能在编辑器中修改并保存。LLM 写入时需要检测此类外部修改，避免覆盖用户的工作。

> **核心策略**：乐观锁 + 版本校验（Fail Fast）
> - 读取文件时记录内容哈希
> - 写入文件前校验当前哈希是否与读取时一致
> - 哈希不一致时返回结构化错误，由 LLM 决定下一步操作
> - 不尝试自动合并（三路合并复杂度高，容易产生语法错误）

- [ ] **文件路径**：`infrastructure/persistence/file_version_tracker.py`
- [ ] **职责**：追踪工具执行上下文中读取过的文件版本，写入前校验版本一致性
- [ ] **核心类**：`FileVersionTracker`
- [ ] **核心功能**：
  - `record_read(file_path: str, content: str) -> str` - 记录文件读取，返回内容哈希
  - `verify_before_write(file_path: str) -> VersionCheckResult` - 写入前校验版本
  - `clear()` - 清空追踪记录（新一轮工具调用开始时）
  - `get_tracked_files() -> List[str]` - 获取已追踪的文件列表
  - `get_version(file_path: str) -> Optional[str]` - 获取文件的记录哈希
- [ ] **`VersionCheckResult` 数据结构**：
  ```python
  @dataclass
  class VersionCheckResult:
      is_consistent: bool          # 版本是否一致
      file_path: str               # 文件路径
      recorded_hash: Optional[str] # 读取时记录的哈希
      current_hash: Optional[str]  # 当前文件哈希
      file_exists: bool            # 文件是否存在
      was_tracked: bool            # 是否在追踪列表中
  ```
- [ ] **校验逻辑**：
  1. 检查文件是否在追踪列表中
  2. 若不在追踪列表 → 返回 `is_consistent=True`（新文件或未读取过的文件）
  3. 若在追踪列表 → 计算当前文件哈希
  4. 比对当前哈希与记录哈希
  5. 哈希一致 → 返回 `is_consistent=True`
  6. 哈希不一致 → 返回 `is_consistent=False`
- [ ] **与 ToolExecutionContext 集成**：
  - `ToolExecutionContext` 持有 `FileVersionTracker` 实例
  - `read_file` 工具执行时自动调用 `record_read()`
  - `patch_file`/`rewrite_file` 工具执行前自动调用 `verify_before_write()`
- [ ] **冲突处理策略（Fail Fast）**：
  - 检测到版本不一致时，不尝试自动合并
  - 返回结构化错误信息给 LLM
  - LLM 根据错误信息决定：重新读取文件、调整修改方案、或询问用户
- [ ] **被调用方**：`tool_dispatcher.py`（文件操作工具执行时）

#### 2.1.7 文件操作异常类扩展

- [ ] **新增异常类**（在 `file_exceptions.py` 中）：
  - `FileModifiedExternallyError` - 文件被外部修改（版本校验失败）
- [ ] **`FileModifiedExternallyError` 结构**：
  ```python
  class FileModifiedExternallyError(FileManagerError):
      """文件在读取后被外部修改"""
      def __init__(self, file_path: str, recorded_hash: str, current_hash: str):
          self.file_path = file_path
          self.recorded_hash = recorded_hash
          self.current_hash = current_hash
          super().__init__(
              f"文件 '{file_path}' 在读取后被外部修改，"
              f"请重新读取文件内容后再进行修改"
          )
  ```
- [ ] **错误反馈结构**（返回给 LLM）：
  ```python
  {
      "success": False,
      "error_type": "file_modified_externally",
      "error_message": "文件在读取后被外部修改",
      "file_path": "amplifier.cir",
      "suggestions": [
          "请使用 read_file 重新读取文件内容",
          "然后基于最新内容重新生成修改方案"
      ]
  }
  ```

#### 2.1.8 UI 冲突提示机制

> **设计原则**：当工具执行器检测到版本冲突并拒绝写入时，除了返回错误给 LLM，还需在 UI 上给用户轻量级反馈。

- [ ] **提示触发条件**：`FileModifiedExternallyError` 异常被捕获时
- [ ] **提示方式**：状态栏闪烁 + Toast 提示（非阻塞）
- [ ] **提示文案**："AI 检测到文件变更，正在重新调整修改方案..."
- [ ] **提示持续时间**：3 秒后自动消失
- [ ] **事件发布**：
  - 发布 `EVENT_FILE_CONFLICT_DETECTED` 事件
  - 事件数据：`{"file_path": str, "action": "retry"}`
- [ ] **被调用方**：`tool_executor.py` 捕获异常后发布事件，`statusbar_manager.py` 订阅事件显示提示

---

### 2.2 智能文件操作能力增强 (`infrastructure/file_intelligence/`)

> **设计理念**：参考 Cursor、Windsurf、Trae 等主流 AI 编程软件的文件操作能力，实现智能文件搜索、内容分析、符号定位等高级功能，并提供完善的降级机制确保操作可靠性。
>
> **架构原则**：
> - 所有智能文件操作都基于 `file_manager.py` 的基础能力构建
> - 提供多策略回退机制，确保操作在各种场景下都能完成
> - 与 LLM 工具调用深度集成，提升 AI 辅助编程体验

#### 2.2.0 智能文件操作目录结构

> **架构说明**：本模块专注于 IDE 级别的文件操作能力（搜索、定位），与阶段5的 RAG 知识检索模块职责分离。
> - `search/` - 实时文件搜索，不依赖向量索引
> - `analysis/` - 轻量级符号提取，用于跳转定义和查找引用
> - `location/` - 符号定位服务，支持多种定位策略

```
infrastructure/file_intelligence/
├── __init__.py
├── search/                          # 智能搜索模块组
│   ├── __init__.py
│   ├── file_search_service.py       # 文件搜索服务门面类
│   ├── content_searcher.py          # 文件内容搜索
│   └── fuzzy/                       # 模糊匹配子模块（职责分离）
│       ├── __init__.py
│       ├── fuzzy_matcher.py         # 模糊匹配器门面类
│       ├── similarity_algorithms.py # 相似度算法封装层
│       ├── text_normalizer.py       # 文本规范化器
│       └── match_scorer.py          # 匹配评分器
├── analysis/                        # 轻量级文件分析（IDE 功能）
│   ├── __init__.py
│   ├── file_analyzer.py             # 文件分析器门面类
│   ├── spice_symbol_extractor.py    # SPICE 符号提取器（轻量级）
│   └── python_symbol_extractor.py   # Python 符号提取器（轻量级）
├── location/                        # 智能定位模块组
│   ├── __init__.py
│   ├── location_service.py          # 定位服务门面类
│   ├── symbol_locator.py            # 符号定位器
│   └── reference_finder.py          # 引用查找器
└── models/                          # 数据模型
    ├── __init__.py
    ├── search_result.py             # 搜索结果数据类
    └── symbol_info.py               # 符号信息数据类
```

> **与阶段3/5的关系**：
> - **阶段3 复用本模块**：`context_retriever.py` 通过 `FileSearchService` 执行工作区文件搜索，禁止重复实现文件遍历
> - 电路依赖图分析由阶段3的 `domain/llm/context_retrieval/dependency_analyzer.py` 负责
> - 深度文档分块和向量索引由阶段5的 `domain/knowledge/` 模块负责
> - 本模块的符号提取器是轻量级实现，仅提取符号名称和位置，不做深度语义分析

#### 2.2.1 智能搜索模块组 (`infrastructure/file_intelligence/search/`)

##### 2.2.1.1 `file_search_service.py` - 精确文件搜索服务

> **初始化顺序**：Phase 3 延迟初始化，依赖 FileManager、Logger，注册到 ServiceLocator

> **⚠️ 职责边界**：本模块是底层精确搜索引擎，专注于正则匹配、模糊匹配、符号定位等确定性搜索。
> 语义搜索由阶段5的 `RetrievalService` 负责。两者通过阶段5的 `UnifiedSearchService` 统一对外暴露。

- [x] **文件路径**：`infrastructure/file_intelligence/search/file_search_service.py`
- [x] **职责**：提供实时精确文件搜索能力（正则、模糊、符号），不依赖向量索引
- [x] **核心功能**：
  - `search_by_name(pattern, fuzzy)` - 按文件名搜索，支持模糊匹配
  - `search_by_content(query, options)` - 按内容精确搜索（正则/字符串匹配）
  - `search_symbols(symbol_name, symbol_type)` - 符号搜索（委托给 `file_analyzer`）
  - `search_in_file(file_path, query, options)` - 在单个文件内搜索（委托给 `ContentSearcher`）
- [ ] **搜索选项 `ExactSearchOptions`**：
  - `query: str` - 搜索查询
  - `search_type: str` - 搜索类型（name/content/regex/symbol）
  - `file_types: List[str]` - 限定文件类型
  - `max_results: int` - 最大结果数（默认 50）
  - `case_sensitive: bool` - 是否区分大小写（默认 False）
  - `fuzzy_threshold: float` - 模糊匹配阈值（默认 0.6）
  - `include_context: bool` - 是否包含上下文行（默认 True）
  - `context_lines: int` - 上下文行数（默认 2）
- [ ] **返回结构 `ExactSearchResult`**：
  - `file_path: str` - 文件路径
  - `line_number: int` - 行号
  - `column: int` - 列号
  - `match_text: str` - 匹配的文本
  - `context_before: List[str]` - 上文行
  - `context_after: List[str]` - 下文行
  - `match_type: str` - 匹配类型（exact/fuzzy/regex/symbol）
  - `score: float` - 匹配分数（模糊匹配时有意义）
- [ ] **性能优化**：
  - 文件名索引缓存（项目打开时构建）
  - 增量更新索引（文件变更时）
  - 大文件跳过内容搜索（>1MB）
- [ ] **被调用方**：`UnifiedSearchService`（阶段五统一搜索门面）、`file_browser_panel.py`（UI 搜索）、`location_service.py`（符号定位）

##### 2.2.1.1.1 `search_in_file` 方法详细设计

> **设计背景**：支持 `UnifiedSearchService.search_in_file()` 的精确搜索部分，在单个文件内执行正则/模糊匹配。

- [x] **方法签名**：`search_in_file(file_path: str, query: str, options: ContentSearchOptions = None) -> List[SearchMatch]`
- [x] **实现方式**：委托给 `ContentSearcher.search_in_file()`，复用已有的内容搜索逻辑
- [x] **与 `search_by_content` 的区别**：
  - `search_by_content`：在整个项目中搜索，遍历多个文件
  - `search_in_file`：仅在指定的单个文件中搜索，跳过索引构建，直接读取文件
- [x] **被调用方**：`UnifiedSearchService.search_in_file()`（阶段五）

##### 2.2.1.2 `content_searcher.py` - 文件内容搜索

- [ ] **文件路径**：`infrastructure/file_intelligence/search/content_searcher.py`
- [ ] **职责**：在文件内容中搜索指定文本
- [ ] **核心功能**：
  - `search_in_file(file_path, query, options)` - 单文件搜索
  - `search_in_directory(dir_path, query, options)` - 目录递归搜索
  - `get_context(file_path, line_number, context_lines)` - 获取匹配上下文
- [ ] **搜索结果结构**：
  - `file_path` - 文件路径
  - `line_number` - 行号
  - `match_text` - 匹配的文本
  - `context_before` / `context_after` - 上下文行
- [ ] **被调用方**：`file_search_service.py`

##### 2.2.1.3 模糊匹配子模块 (`infrastructure/file_intelligence/search/fuzzy/`)

> **设计理念**：模糊匹配是一个复杂的功能领域，涉及文本预处理、相似度计算、评分策略等多个职责。为遵循单一职责原则和功能解耦原则，将其拆分为独立的子模块。
>
> **技术选型**：底层使用成熟的 `rapidfuzz` 库（MIT 许可证），该库使用 C++ 实现核心算法，性能比纯 Python 实现快 10-100 倍，已在大量项目中验证。上层封装保持接口一致性，便于未来切换底层实现。

###### 2.2.1.3.1 `similarity_algorithms.py` - 相似度算法封装层

- [ ] **文件路径**：`infrastructure/file_intelligence/search/fuzzy/similarity_algorithms.py`
- [ ] **职责**：封装底层相似度算法库，提供统一的算法调用接口
- [ ] **依赖库**：`rapidfuzz`（需添加到 `requirements.txt`）
- [ ] **核心功能**：
  - `levenshtein_ratio(s1, s2)` - Levenshtein 编辑距离相似度（0-1）
  - `jaro_winkler_ratio(s1, s2)` - Jaro-Winkler 相似度（对前缀匹配更敏感）
  - `partial_ratio(s1, s2)` - 部分匹配相似度（适合长文本中查找短文本）
  - `token_sort_ratio(s1, s2)` - 词序无关相似度（适合词序可能变化的场景）
  - `token_set_ratio(s1, s2)` - 词集合相似度（忽略重复词）
- [ ] **算法选择建议**：
  - 文件名匹配：`jaro_winkler_ratio`（前缀敏感）
  - 代码内容匹配：`partial_ratio`（部分匹配）
  - 参数名匹配：`levenshtein_ratio`（精确度高）
- [ ] **被调用方**：`fuzzy_matcher.py`、`match_scorer.py`

###### 2.2.1.3.2 `text_normalizer.py` - 文本规范化器

- [ ] **文件路径**：`infrastructure/file_intelligence/search/fuzzy/text_normalizer.py`
- [ ] **职责**：文本预处理，确保匹配前文本格式一致
- [ ] **核心功能**：
  - `normalize_whitespace(text)` - 规范化空白字符（连续空格→单空格，移除行尾空格）
  - `normalize_case(text, case_sensitive)` - 大小写规范化
  - `normalize_unicode(text)` - Unicode 规范化（NFC 形式）
  - `remove_comments(text, language)` - 移除注释（可选，用于代码匹配）
  - `extract_tokens(text)` - 提取词元（按驼峰、下划线、空格分割）
  - `normalize_for_matching(text, options)` - 综合规范化入口
- [ ] **规范化选项**：
  - `ignore_whitespace: bool` - 是否忽略空白差异
  - `ignore_case: bool` - 是否忽略大小写
  - `ignore_empty_lines: bool` - 是否忽略空行
  - `strip_comments: bool` - 是否移除注释
- [ ] **被调用方**：`fuzzy_matcher.py`、`patch_strategies.py`

###### 2.2.1.3.3 `match_scorer.py` - 匹配评分器

- [ ] **文件路径**：`infrastructure/file_intelligence/search/fuzzy/match_scorer.py`
- [ ] **职责**：实现多种匹配评分策略，计算综合匹配分数
- [ ] **核心功能**：
  - `score_subsequence_match(query, target)` - 子序列匹配评分（如 `fm` 匹配 `file_manager`）
  - `score_word_boundary_match(query, target)` - 单词边界匹配评分（驼峰、下划线分隔）
  - `score_prefix_match(query, target)` - 前缀匹配评分
  - `score_continuous_match(query, target)` - 连续字符匹配评分
  - `calculate_composite_score(query, target, weights)` - 综合评分（加权组合）
- [ ] **评分权重配置**：
  - `subsequence_weight: float` - 子序列匹配权重（默认 0.3）
  - `word_boundary_weight: float` - 单词边界权重（默认 0.3）
  - `continuous_weight: float` - 连续匹配权重（默认 0.2）
  - `similarity_weight: float` - 相似度算法权重（默认 0.2）
- [ ] **评分结果结构**：
  - `score: float` - 综合分数（0-1）
  - `matched_positions: List[int]` - 匹配字符位置（用于高亮显示）
  - `match_type: str` - 主要匹配类型（subsequence/boundary/prefix/exact）
- [ ] **被调用方**：`fuzzy_matcher.py`

###### 2.2.1.3.4 `fuzzy_matcher.py` - 模糊匹配器门面类

- [ ] **文件路径**：`infrastructure/file_intelligence/search/fuzzy/fuzzy_matcher.py`
- [ ] **职责**：模糊匹配子模块的统一入口，组合调用各子模块完成匹配
- [ ] **依赖**：`similarity_algorithms.py`、`text_normalizer.py`、`match_scorer.py`
- [ ] **核心功能**：
  - `match(query, target, options)` - 计算单个目标的匹配度
  - `find_best_matches(query, candidates, top_k, options)` - 从候选列表中找出最佳匹配
  - `find_similar_content(query, content, threshold)` - 在长文本中查找相似内容块
  - `is_match(query, target, threshold)` - 判断是否匹配（布尔结果）
- [ ] **匹配选项**：
  - `threshold: float` - 匹配阈值（默认 0.6）
  - `algorithm: str` - 主算法选择（levenshtein/jaro_winkler/partial）
  - `normalize_options: dict` - 文本规范化选项
  - `scoring_weights: dict` - 评分权重配置
- [ ] **匹配结果结构**：
  - `target: str` - 匹配目标
  - `score: float` - 匹配分数
  - `matched_positions: List[int]` - 匹配位置
  - `normalized_query: str` - 规范化后的查询
  - `normalized_target: str` - 规范化后的目标
- [ ] **使用场景**：
  - 文件名搜索：`find_best_matches(query, file_names, top_k=10)`
  - 内容修改定位：`find_similar_content(search_text, file_content, threshold=0.85)`
  - 符号搜索：`find_best_matches(symbol_name, all_symbols, top_k=5)`
- [ ] **被调用方**：`file_search_service.py`、`patch_strategies.py`、`location_service.py`

#### 2.2.2 轻量级文件分析模块组 (`infrastructure/file_intelligence/analysis/`)

> **设计说明**：本模块提供轻量级的符号提取功能，专注于 IDE 功能（跳转定义、查找引用、结构大纲）。
> 与阶段5的 RAG 分块器不同，本模块不做深度语义分析，仅提取符号名称和位置信息。

##### 2.2.2.1 `file_analyzer.py` - 文件分析器门面类

- [ ] **文件路径**：`infrastructure/file_intelligence/analysis/file_analyzer.py`
- [ ] **职责**：提供统一的文件分析入口，根据文件类型选择符号提取器
- [ ] **核心功能**：
  - `get_symbols(file_path)` - 提取文件中的符号定义
  - `get_structure(file_path)` - 获取文件结构大纲（用于 UI 显示）
  - `find_symbol(file_path, symbol_name)` - 查找符号定义位置
  - `get_file_summary(file_path, max_tokens)` - 获取文件摘要（用于 LLM 工具）
- [ ] **文件类型路由**：
  - `.cir`/`.sp`/`.spice`/`.net`/`.ckt` → `SpiceSymbolExtractor`
  - `.py` → `PythonSymbolExtractor`
  - 其他 → 返回空结果
- [ ] **大文件保护机制**：
  - 在执行分析前检查文件大小，超过 `ANALYZE_FILE_MAX_BYTES`（5MB）时拒绝分析
  - 返回 `FileStructure` 对象，`error` 字段包含错误信息和建议
  - 错误信息格式：`"文件过大（{size}MB），无法分析。建议使用 read_file(start_line, end_line) 分段读取"`
- [ ] **被调用方**：`location_service.py`、`file_search_service.py`、`tool_dispatcher.py`（阶段六）

##### 2.2.2.2 `spice_symbol_extractor.py` - SPICE 符号提取器

- [ ] **文件路径**：`infrastructure/file_intelligence/analysis/spice_symbol_extractor.py`
- [ ] **职责**：从 SPICE 文件中提取符号信息（轻量级，用于 IDE 功能）
- [ ] **核心功能**：
  - `extract_symbols(file_path)` - 提取所有符号
  - `find_symbol(file_path, name)` - 查找符号定义位置
  - `get_includes(file_path)` - 获取 .include 引用列表
- [ ] **提取的符号类型**：
  - `subcircuit` - 子电路定义（.subckt ... .ends）
  - `parameter` - 参数定义（.param）
  - `model` - 模型定义（.model）
- [ ] **符号信息结构**：
  - `name` - 符号名称
  - `type` - 符号类型
  - `line_start` - 起始行号
  - `line_end` - 结束行号（子电路）
- [ ] **大文件保护机制**：
  - 在 `extract_symbols` 方法入口检查文件大小
  - 超过 `ANALYZE_FILE_MAX_BYTES`（5MB）时返回空的 `FileStructure`，`error` 字段包含错误信息
  - 基于正则的逐行扫描，不构建完整 AST，内存占用可控
- [ ] **与阶段5的区别**：
  - 本模块仅提取符号名称和位置，用于跳转定义
  - 阶段5的 `spice_chunker.py` 做语法感知分块，用于 RAG 索引
- [ ] **被调用方**：`file_analyzer.py`、`symbol_locator.py`

##### 2.2.2.3 `python_symbol_extractor.py` - Python 符号提取器

- [ ] **文件路径**：`infrastructure/file_intelligence/analysis/python_symbol_extractor.py`
- [ ] **职责**：使用 Python AST 模块提取符号信息
- [ ] **核心功能**：
  - `extract_symbols(file_path)` - 提取所有符号
  - `find_symbol(file_path, name)` - 查找符号定义位置
- [ ] **提取的符号类型**：
  - `class` - 类定义
  - `function` - 函数定义
  - `variable` - 全局变量
- [ ] **符号信息结构**：
  - `name` - 符号名称
  - `type` - 符号类型
  - `line_start` - 起始行号
  - `line_end` - 结束行号
  - `signature` - 函数签名（如适用）
- [ ] **大文件保护机制**：
  - 在 `extract_symbols` 方法入口检查文件大小
  - 超过 `ANALYZE_FILE_MAX_BYTES`（5MB）时返回空的 `FileStructure`，`error` 字段包含错误信息
  - Python AST 解析对大文件内存占用较高，必须有此保护
- [ ] **被调用方**：`file_analyzer.py`、`symbol_locator.py`

> **依赖分析说明**：电路文件的依赖关系分析（.include 解析、依赖图构建）由阶段3的 `domain/llm/context_retrieval/dependency_analyzer.py` 负责，本阶段不重复实现。

#### 2.2.3 智能定位模块组 (`infrastructure/file_intelligence/location/`)

##### 2.2.3.1 `location_service.py` - 定位服务门面类

- [ ] **文件路径**：`infrastructure/file_intelligence/location/location_service.py`
- [ ] **职责**：提供统一的符号定位和导航入口
- [ ] **核心功能**：
  - `go_to_definition(file_path, line, column)` - 跳转到定义
  - `find_references(symbol_name, file_path)` - 查找所有引用
  - `find_symbol(symbol_name, scope)` - 在指定范围查找符号
- [ ] **定位结果结构**：
  - `file_path` - 文件路径
  - `line` - 行号
  - `symbol_name` - 符号名称
  - `symbol_type` - 符号类型
  - `preview` - 代码预览（定义行内容）
- [ ] **被调用方**：`tool_executor.py`、`code_editor_panel.py`

##### 2.2.3.2 `symbol_locator.py` - 符号定位器

- [ ] **文件路径**：`infrastructure/file_intelligence/location/symbol_locator.py`
- [ ] **职责**：定位符号的定义位置
- [ ] **核心功能**：
  - `locate_definition(symbol_name, context_file)` - 定位符号定义
  - `locate_in_file(symbol_name, file_path)` - 在指定文件中定位
  - `locate_in_project(symbol_name)` - 在整个项目中定位
- [ ] **定位策略**：
  - 优先在当前文件查找（调用 `file_analyzer.find_symbol()`）
  - 其次在 .include 引用的文件中查找
  - 最后在整个项目中查找
- [ ] **被调用方**：`location_service.py`

##### 2.2.3.3 `reference_finder.py` - 引用查找器

- [ ] **文件路径**：`infrastructure/file_intelligence/location/reference_finder.py`
- [ ] **职责**：查找符号的所有引用位置
- [ ] **核心功能**：
  - `find_all_references(symbol_name, definition_file)` - 查找所有引用
  - `find_references_in_file(symbol_name, file_path)` - 在指定文件中查找
- [ ] **实现方式**：
  - 使用正则表达式在文件内容中搜索符号名称
  - 排除注释中的匹配
  - 返回所有匹配位置
- [ ] **被调用方**：`location_service.py`

#### 2.2.4 智能文件操作事件定义

- [ ] **文件路径**：`shared/events/file_intelligence_events.py`
- [ ] **事件常量定义**：
  ```python
  class FileIntelligenceEvents:
      """智能文件操作相关事件定义"""
      
      # 搜索事件
      SEARCH_INDEX_UPDATED = "file_intelligence.search_index_updated"
  ```

---

### 2.3 工具函数扩展 (`infrastructure/utils/`)

#### 2.3.1 `file_utils.py` - 跨平台文件操作
- [ ] **职责**：提供跨平台（Windows/macOS/Linux）的文件路径处理工具
- [ ] **核心功能**：
  - `normalize_path(path)` - 规范化路径（处理 `~`、相对路径、路径分隔符）
  - `get_relative_path(path, base)` - 获取相对路径
  - `is_subpath(path, parent)` - 检查路径是否在父目录下
  - `get_file_extension(path)` - 获取文件扩展名
  - `is_spice_file(path)` - 判断是否为SPICE文件（.cir/.sp/.spice/.net/.ckt）
  - `is_python_file(path)` - 判断是否为 Python 文件（.py）
  - `is_simulatable_file(path, executor_registry)` - 判断是否为可仿真文件（根据已注册执行器）
  - `is_image_file(path)` - 判断是否为图片文件（.png/.jpg/.webp）
  - `is_markdown_file(path)` - 判断是否为 Markdown 文件（.md）
  - `is_word_file(path)` - 判断是否为 Word 文档（.docx）
  - `is_pdf_file(path)` - 判断是否为 PDF 文档（.pdf）
  - `is_document_file(path)` - 判断是否为文档文件（.md/.docx/.pdf）
  - `get_safe_filename(name)` - 生成安全的文件名（移除非法字符）
- [ ] **被调用方**：`file_manager.py`、`file_browser_panel.py`、`code_editor_panel.py`

---

### 2.4 依赖健康检查模块组 (`domain/dependency/`)

> **设计背景**：用户打开包含第三方 `.lib` 引用的旧项目时，若引用的库文件本地不存在，当前设计是"仿真前检查"才发现问题，这太晚了。应该在项目打开时就进行依赖健康检查，让用户尽早发现并解决依赖问题。
>
> **核心设计原则**：
> - **早发现**：项目打开时立即启动本地扫描，不等到仿真时才报错
> - **异步执行**：扫描任务通过 `AsyncTaskRegistry` 提交，不阻塞主线程
> - **保守策略**：自动修复仅限于项目内路径修正，外部依赖下载必须用户确认
> - **离线友好**：本地扫描与外部源查询分离，离线环境下跳过外部查询
>
> **与其他模块的职责边界**：
> - **本模块**：依赖扫描、健康报告生成、解析策略协调
> - **阶段3 `dependency_analyzer.py`**：电路依赖图分析，用于 LLM 上下文构建（复用本模块的解析结果）
> - **阶段4 `circuit_analyzer.py`**：电路文件分析，复用本模块的 `include_parser.py` 进行语句解析
> - **阶段10 `model_downloader.py`**：SPICE 模型下载，作为外部解析策略的实现

#### 2.4.0 依赖健康检查目录结构

```
domain/dependency/
├── __init__.py
├── models/                          # 数据模型定义
│   ├── __init__.py
│   ├── dependency_item.py           # 依赖项数据类
│   ├── health_report.py             # 健康报告数据类
│   └── resolution_result.py         # 解析结果数据类
├── scanner/                         # 依赖扫描模块
│   ├── __init__.py
│   ├── dependency_scanner.py        # 依赖扫描器（入口）
│   ├── include_parser.py            # .include/.lib 语句解析
│   └── scan_config.py               # 扫描配置（黑名单、深度限制）
├── resolver/                        # 依赖解析策略
│   ├── __init__.py
│   ├── resolution_strategy.py       # 解析策略基类
│   ├── local_resolver.py            # 本地路径解析（自动）
│   └── external_resolver.py         # 外部源解析（需用户确认）
├── service/
│   ├── __init__.py
│   └── dependency_health_service.py # 依赖健康服务门面类
└── events/
    ├── __init__.py
    └── dependency_events.py         # 依赖相关事件定义
```

#### 2.4.1 依赖数据模型 (`domain/dependency/models/`)

##### 2.4.1.1 `dependency_item.py` - 依赖项数据类

- [ ] **文件路径**：`domain/dependency/models/dependency_item.py`
- [ ] **职责**：定义单个依赖项的数据结构
- [ ] **依赖状态枚举 `DependencyStatus`**：
  - `FOUND` - 依赖文件存在且可访问
  - `MISSING` - 依赖文件不存在
  - `AMBIGUOUS` - 存在多个同名文件，需用户选择
  - `RESOLVED` - 缺失依赖已被解析（用户确认后）
  - `IGNORED` - 用户选择忽略此依赖
- [ ] **依赖类型枚举 `DependencyType`**：
  - `INCLUDE` - `.include` 语句引用
  - `LIB` - `.lib` 语句引用
  - `MODEL` - `.model` 语句引用的外部模型
- [ ] **数据类 `DependencyItem`**：
  - `raw_path: str` - 原始路径字符串（保持用户书写格式）
  - `resolved_path: Optional[str]` - 解析后的绝对路径
  - `dependency_type: DependencyType` - 依赖类型
  - `status: DependencyStatus` - 依赖状态
  - `source_file: str` - 引用此依赖的源文件路径
  - `line_number: int` - 引用语句所在行号
  - `resolution_source: Optional[str]` - 解析来源（local/global_lib/lcsc/manual）
  - `resolution_candidates: List[str]` - 可能的解析候选路径列表
- [ ] **核心方法**：
  - `to_dict()` - 序列化为字典
  - `from_dict(data)` - 从字典反序列化
  - `is_resolved()` - 判断是否已解析
  - `is_missing()` - 判断是否缺失
- [ ] **被调用方**：`dependency_scanner.py`、`health_report.py`

##### 2.4.1.2 `health_report.py` - 健康报告数据类

- [ ] **文件路径**：`domain/dependency/models/health_report.py`
- [ ] **职责**：定义依赖健康检查报告的数据结构
- [ ] **报告状态枚举 `HealthStatus`**：
  - `HEALTHY` - 所有依赖都已找到
  - `WARNING` - 存在可自动修复的问题
  - `ERROR` - 存在缺失依赖，需用户处理
- [ ] **数据类 `DependencyHealthReport`**：
  - `project_root: str` - 项目根目录
  - `scan_timestamp: str` - 扫描时间（ISO 格式）
  - `status: HealthStatus` - 整体健康状态
  - `total_dependencies: int` - 依赖总数
  - `found_count: int` - 已找到数量
  - `missing_count: int` - 缺失数量
  - `ambiguous_count: int` - 歧义数量
  - `dependencies: List[DependencyItem]` - 所有依赖项列表
  - `scan_errors: List[str]` - 扫描过程中的错误信息
- [ ] **核心方法**：
  - `to_dict()` - 序列化为字典
  - `from_dict(data)` - 从字典反序列化
  - `get_missing_dependencies()` - 获取所有缺失依赖
  - `get_ambiguous_dependencies()` - 获取所有歧义依赖
  - `is_healthy()` - 判断是否健康
  - `get_summary()` - 获取摘要文本
- [ ] **被调用方**：`dependency_health_service.py`、UI 面板

##### 2.4.1.3 `resolution_result.py` - 解析结果数据类

- [ ] **文件路径**：`domain/dependency/models/resolution_result.py`
- [ ] **职责**：定义依赖解析尝试的结果
- [ ] **解析来源枚举 `ResolutionSource`**：
  - `PROJECT_LOCAL` - 项目内路径修正（自动）
  - `GLOBAL_LIBRARY` - 全局库目录匹配（需确认）
  - `LCSC_DOWNLOAD` - 嘉立创商城下载（需确认）
  - `PUBLIC_LIBRARY` - 公开模型库下载（需确认）
  - `MANUAL` - 用户手动指定
- [ ] **数据类 `ResolutionResult`**：
  - `dependency: DependencyItem` - 被解析的依赖项
  - `success: bool` - 是否解析成功
  - `source: ResolutionSource` - 解析来源
  - `resolved_path: str` - 解析后的路径
  - `requires_confirmation: bool` - 是否需要用户确认
  - `confidence: float` - 匹配置信度（0-1）
  - `metadata: Dict` - 额外元数据（如来源 URL、版本信息）
- [ ] **被调用方**：`local_resolver.py`、`external_resolver.py`

#### 2.4.2 依赖扫描模块 (`domain/dependency/scanner/`)

##### 2.4.2.1 `scan_config.py` - 扫描配置

- [ ] **文件路径**：`domain/dependency/scanner/scan_config.py`
- [ ] **职责**：定义依赖扫描的配置参数
- [ ] **配置类 `ScanConfig`**：
  - `max_recursion_depth: int` - 最大递归深度（默认 10）
  - `directory_blacklist: List[str]` - 目录黑名单
  - `file_extensions: List[str]` - 扫描的文件扩展名
  - `timeout_seconds: int` - 扫描超时时间（默认 30 秒）
- [ ] **默认目录黑名单**：
  - `.git`
  - `.circuit_ai`
  - `__pycache__`
  - `.venv`
  - `venv`
  - `node_modules`
  - `.idea`
  - `.vscode`
- [ ] **默认文件扩展名**：
  - `.cir`、`.sp`、`.spice`、`.net`、`.ckt`、`.lib`、`.sub`
- [ ] **被调用方**：`dependency_scanner.py`

##### 2.4.2.2 `include_parser.py` - 语句解析器

- [ ] **文件路径**：`domain/dependency/scanner/include_parser.py`
- [ ] **职责**：解析 SPICE 文件中的 `.include` 和 `.lib` 语句
- [ ] **核心功能**：
  - `parse_file(file_path)` - 解析单个文件，返回依赖项列表
  - `parse_line(line, line_number)` - 解析单行语句
  - `extract_path(statement)` - 从语句中提取路径字符串
- [ ] **支持的语句格式**：
  - `.include "path/to/file.cir"`
  - `.include 'path/to/file.cir'`
  - `.include path/to/file.cir`（无引号）
  - `.lib "path/to/lib.lib" section_name`
  - `.lib 'path/to/lib.lib' section_name`
- [ ] **路径提取规则**：
  - 支持双引号、单引号、无引号三种格式
  - 保留原始路径字符串，不做转换
  - 记录语句所在行号
- [ ] **被调用方**：`dependency_scanner.py`

##### 2.4.2.3 `dependency_scanner.py` - 依赖扫描器

- [ ] **文件路径**：`domain/dependency/scanner/dependency_scanner.py`
- [ ] **职责**：扫描项目中所有电路文件的依赖关系
- [ ] **依赖**：`include_parser.py`、`scan_config.py`
- [ ] **核心功能**：
  - `scan_project(project_root, config)` - 扫描整个项目
  - `scan_file(file_path, config)` - 扫描单个文件
  - `build_dependency_graph(project_root)` - 构建依赖关系图
  - `check_dependency_exists(dependency, project_root)` - 检查依赖是否存在
- [ ] **扫描流程**：
  1. 遍历项目目录，跳过黑名单目录
  2. 筛选符合扩展名的文件
  3. 对每个文件调用 `include_parser.parse_file()`
  4. 检查每个依赖项是否存在
  5. 检测循环依赖
  6. 生成依赖项列表
- [ ] **循环依赖检测**：
  - 使用已访问文件集合检测循环
  - 检测到循环时记录警告，不中断扫描
- [ ] **性能优化**：
  - 使用文件修改时间缓存，跳过未变更的文件
  - 支持增量扫描（仅扫描变更的文件）
- [ ] **被调用方**：`dependency_health_service.py`

#### 2.4.3 依赖解析策略 (`domain/dependency/resolver/`)

##### 2.4.3.1 `resolution_strategy.py` - 解析策略基类

- [ ] **文件路径**：`domain/dependency/resolver/resolution_strategy.py`
- [ ] **职责**：定义依赖解析策略的抽象接口
- [ ] **抽象基类 `ResolutionStrategy`**：
  - `get_name()` - 返回策略名称
  - `can_resolve(dependency)` - 判断是否能处理此依赖
  - `resolve(dependency, project_root)` - 尝试解析依赖
  - `requires_confirmation()` - 是否需要用户确认
- [ ] **被调用方**：`local_resolver.py`、`external_resolver.py`

##### 2.4.3.2 `local_resolver.py` - 本地路径解析器

- [ ] **文件路径**：`domain/dependency/resolver/local_resolver.py`
- [ ] **职责**：在本地文件系统中解析依赖路径
- [ ] **继承**：`ResolutionStrategy`
- [ ] **解析策略（按优先级）**：
  1. **相对路径修正**：基于源文件目录解析相对路径
  2. **项目内搜索**：在项目的 `subcircuits/`、`models/`、`lib/` 目录搜索同名文件
  3. **全局库目录**：在 `~/.circuit_design_ai/libraries/` 搜索
- [ ] **核心功能**：
  - `resolve(dependency, project_root)` - 执行本地解析
  - `search_in_project(filename, project_root)` - 在项目内搜索
  - `search_in_global_library(filename)` - 在全局库搜索
- [ ] **自动修复范围**（无需用户确认）：
  - 相对路径解析错误（如 `../models/xxx.lib` 实际在 `./models/xxx.lib`）
  - 大小写不匹配（Windows 不敏感，Linux 敏感）
- [ ] **需要用户确认的情况**：
  - 从全局库目录匹配到的文件
  - 存在多个同名文件
- [ ] **被调用方**：`dependency_health_service.py`

##### 2.4.3.3 `external_resolver.py` - 外部源解析器

- [ ] **文件路径**：`domain/dependency/resolver/external_resolver.py`
- [ ] **职责**：从外部源（商城、公开库）解析依赖
- [ ] **继承**：`ResolutionStrategy`
- [ ] **⚠️ 核心原则**：所有外部下载必须用户确认，绝不静默自动替换
- [ ] **解析策略（按优先级）**：
  1. **嘉立创商城**：通过元器件型号匹配 SPICE 模型
  2. **公开模型库**：LTspice 模型库、厂商官网模型库
- [ ] **核心功能**：
  - `resolve(dependency, project_root)` - 执行外部解析
  - `search_lcsc(model_name)` - 在嘉立创商城搜索
  - `search_public_libraries(model_name)` - 在公开库搜索
- [ ] **返回结果**：
  - 始终设置 `requires_confirmation = True`
  - 包含来源信息（URL、版本、文件大小）
  - 包含匹配置信度
- [ ] **离线模式**：
  - 检测网络连接状态
  - 离线时跳过外部查询，返回空结果
  - 不抛出异常，不阻塞流程
- [ ] **与阶段10集成**：
  - 调用 `model_downloader.search_model()` 执行实际搜索
  - 下载操作由用户在依赖健康面板中触发
- [ ] **被调用方**：`dependency_health_service.py`

#### 2.4.4 依赖健康服务 (`domain/dependency/service/`)

##### 2.4.4.1 `dependency_health_service.py` - 依赖健康服务门面类

> **初始化顺序**：Phase 3.5，依赖 AsyncTaskRegistry、EventBus、Logger，注册到 ServiceLocator

- [ ] **文件路径**：`domain/dependency/service/dependency_health_service.py`
- [ ] **职责**：依赖健康检查的统一入口，协调扫描和解析
- [ ] **依赖**：`dependency_scanner.py`、`local_resolver.py`、`external_resolver.py`
- [ ] **核心功能**：
  - `check_health_async(project_root)` - 异步执行健康检查（项目打开时调用）
  - `check_health_sync(project_root)` - 同步执行健康检查（仿真前调用）
  - `get_cached_report(project_root)` - 获取缓存的健康报告
  - `resolve_dependency(dependency, strategy)` - 解析单个依赖
  - `resolve_all_auto(report)` - 自动解析所有可自动修复的依赖
  - `confirm_resolution(dependency, resolution)` - 用户确认解析结果
  - `ignore_dependency(dependency)` - 用户选择忽略依赖
  - `invalidate_cache(project_root)` - 失效缓存（文件变更时）
- [ ] **异步检查流程**（`check_health_async`）：
  1. 通过 `AsyncTaskRegistry.submit()` 提交扫描任务
  2. 扫描完成后发布 `EVENT_DEPENDENCY_SCAN_COMPLETE` 事件
  3. 缓存报告到 `.circuit_ai/dependency_health.json`
  4. 若有缺失依赖，发布 `EVENT_DEPENDENCY_MISSING` 事件
- [ ] **同步检查流程**（`check_health_sync`）：
  1. 优先使用缓存报告（检查文件修改时间）
  2. 缓存过期则重新扫描
  3. 返回健康报告
- [ ] **缓存机制**：
  - 缓存文件：`.circuit_ai/dependency_health.json`
  - 缓存失效条件：任意电路文件修改时间晚于缓存时间
  - 订阅 `EVENT_FILE_CHANGED` 事件，增量更新缓存
- [ ] **与 ProjectService 集成**：
  - `ProjectService.initialize_project()` 完成后调用 `check_health_async()`
  - 不阻塞项目打开流程
- [ ] **被调用方**：`project_service.py`、`spice_executor.py`、UI 面板

#### 2.4.5 依赖事件定义 (`domain/dependency/events/`)

##### 2.4.5.1 `dependency_events.py` - 依赖相关事件

- [ ] **文件路径**：`domain/dependency/events/dependency_events.py`
- [ ] **事件常量定义**：
  ```python
  class DependencyEvents:
      """依赖相关事件定义"""
      
      # 扫描事件
      SCAN_STARTED = "dependency.scan_started"
      SCAN_PROGRESS = "dependency.scan_progress"
      SCAN_COMPLETE = "dependency.scan_complete"
      SCAN_ERROR = "dependency.scan_error"
      
      # 健康状态事件
      HEALTH_REPORT_READY = "dependency.health_report_ready"
      DEPENDENCY_MISSING = "dependency.missing"
      DEPENDENCY_RESOLVED = "dependency.resolved"
      
      # 用户操作事件
      RESOLUTION_CONFIRMED = "dependency.resolution_confirmed"
      RESOLUTION_REJECTED = "dependency.resolution_rejected"
      DEPENDENCY_IGNORED = "dependency.ignored"
  ```
- [ ] **被调用方**：所有依赖相关模块通过导入此常量类使用事件名

#### 2.4.6 阶段检查点 - 依赖健康检查

- [ ] **扫描功能验证**：
  - 项目打开时自动启动异步扫描
  - 扫描不阻塞主线程
  - 正确识别 `.include` 和 `.lib` 语句
  - 正确检测缺失依赖
  - 循环依赖检测正常工作
- [ ] **解析功能验证**：
  - 本地路径修正自动生效
  - 全局库匹配需要用户确认
  - 外部源查询需要用户确认
  - 离线模式下跳过外部查询
- [ ] **缓存功能验证**：
  - 缓存正确生成和读取
  - 文件变更时缓存正确失效
  - 增量更新正常工作
- [ ] **事件发布验证**：
  - 扫描完成时发布正确事件
  - 缺失依赖时发布警告事件
  - UI 面板正确响应事件

---

### 2.5 项目服务 (`application/`)

#### 2.5.1 `project_service.py` - 项目管理服务

> **初始化顺序**：阶段二启动时初始化，依赖 FileManager、SessionState、EventBus、DependencyHealthService，注册到 ServiceLocator

- [ ] **职责**：管理工作文件夹的初始化和状态，确保项目环境就绪
- [ ] **相对路径设计原则**：
  - 所有文件操作都基于用户打开的工作路径作为基准，而非绝对路径
  - 软件分发给其他用户后，每个用户打开不同的工作路径，系统会在各自的路径下创建结构
  - LLM 生成文件时使用相对路径（如 `subcircuits/opamp.cir`），由 `FileManager` 转换为实际路径
  - 仿真结果、设计目标等系统文件存储在 `.circuit_ai/` 相对目录下
  - 禁止在代码中硬编码绝对路径，所有路径操作都通过 `FileManager.resolve_path()` 转换
- [ ] **核心功能**：
  - `initialize_project(folder_path)` - 初始化工作文件夹
  - `close_project()` - 关闭当前项目并清理状态
  - `switch_project(new_folder_path)` - 切换到新的工作文件夹
  - `validate_folder(folder_path)` - 校验文件夹有效性与权限
  - `create_hidden_structure()` - 创建 `.circuit_ai/` 目录结构
  - `check_disk_space(required_mb)` - 检查磁盘空间
  - `get_project_status()` - 获取项目状态信息
  - `add_to_recent(folder_path)` - 添加到最近打开列表
  - `get_recent_projects()` - 获取最近打开的项目列表
- [ ] **初始化创建的目录结构**：
  ```
  {work_folder}/
  ├── .circuit_ai/                   # 系统隐藏目录（所有系统数据统一存储于此）
  │   ├── checkpoints.sqlite3        # LangGraph检查点
  │   ├── design_goals.json          # 设计目标
  │   ├── iteration_history.json     # 迭代历史
  │   ├── simulation_config.json     # 仿真配置
  │   ├── analysis_selection.json    # 分析选择配置
  │   ├── chart_selection.json       # 图表选择配置
  │   ├── sim_results/               # 仿真结果目录
  │   ├── snapshots/                 # 全量快照目录
  │   ├── undo_snapshots/            # 撤回快照目录
  │   ├── conversations/             # 对话历史目录
  │   └── temp/                      # 临时文件目录
  ├── parameters/                    # 参数文件目录（推荐结构）
  ├── subcircuits/                   # 子电路目录（推荐结构）
  └── uploads/                       # 用户上传文件
  ```
- [ ] **路径常量定义**：
  - 所有路径常量统一定义在 `shared/constants/paths.py`
  - 各模块通过 `from shared.constants.paths import SIM_RESULTS_DIR` 导入使用
  - 禁止在代码中硬编码路径字符串
- [ ] **推荐项目结构**：
  - 初始化时创建 `parameters/`、`subcircuits/`、`uploads/` 空目录
  - 为 LLM 提供清晰的文件组织框架
  - 用户可自行调整，不强制使用
- [ ] **LLM 文件生成路径规范**：
  - LLM 生成电路文件时，使用相对路径（如 `amplifier.cir` 或 `subcircuits/opamp.cir`）
  - LLM 生成参数文件时，放入 `parameters/` 目录
  - LLM 生成子电路时，放入 `subcircuits/` 目录
  - 系统生成仿真结果时，放入 `.circuit_ai/sim_results/{uuid}.json`
  - 所有路径都相对于用户打开的工作路径，确保项目可移植
- [ ] **目录结构自动检查与补全机制**：
  - 用户每次打开工作路径时，系统自动检查预设的文件夹结构
  - 若目录结构完全不存在，则创建完整结构
  - 若目录结构部分存在，则仅补全缺失的部分，不覆盖已有内容
  - 检查顺序：`.circuit_ai/` → `.circuit_ai/sim_results/` → `.circuit_ai/undo_snapshots/` → 推荐目录
  - 此机制确保 LLM 在具体的相对文件路径生成文件时，目标目录已存在
- [ ] **启动时恢复项目的目录补全机制**：
  - 软件启动时，`main_window._restore_session()` 读取 `last_project_path` 配置
  - 若有上次打开的项目路径，调用 `_open_project(last_project)` 恢复项目
  - `_open_project` 调用 `project_service.initialize_project()` 初始化项目
  - `initialize_project` 自动执行目录结构检查与补全
  - 此机制确保每次启动软件时，已打开项目的目录结构都会被检查和补全
- [ ] **启动检查**：
  - 校验工作目录有效性与读写权限
  - 若 `.circuit_ai/` 缺失则自动创建
  - 若推荐目录（`parameters/`、`subcircuits/` 等）缺失则自动补全
  - 空间不足或权限异常时返回提示信息，不阻塞UI
- [ ] **降级处理**：
  - 若 `project_service` 不可用，`main_window._create_project_structure_fallback()` 手动创建目录结构
  - 确保即使在降级模式下，目录结构也能正确创建
- [ ] **持久化降级**：
  - 初始化 `checkpoints.sqlite3` 失败时使用内存模式继续运行
  - 在状态栏与日志中提示降级状态
- [ ] **项目状态隔离原则**：
  - 每个工作文件夹拥有独立的状态存储（`.circuit_ai/` 目录）
  - 切换项目时，旧项目的所有状态（对话历史、仿真结果、设计目标等）不会带入新项目
  - 新项目从其自身的 `checkpoints.sqlite3` 加载状态，若无则从空白状态开始
- [ ] **打开已有项目时的状态加载**（`initialize_project()` 执行流程）：
  1. 校验文件夹有效性与权限
  2. 检查磁盘空间
  3. 创建或验证 `.circuit_ai/` 目录结构
  4. 检查 `checkpoints.sqlite3` 是否存在
  5. 若存在 → 初始化 Checkpointer 并加载最新 GraphState
  6. 若不存在 → 创建新的 Checkpointer，使用空白 GraphState
  7. 从 GraphState 恢复各组件状态：
     - 对话面板：加载 `messages` 和 `conversation_summary`
     - 仿真结果标签页：加载 `simulation_results`
     - 设计目标：加载 `design_goals`
     - 迭代历史：从 SqliteSaver 查询（通过 `iteration_history_service`）
  8. 设置 FileManager 工作目录
  9. GraphStateProjector 自动投影到 SessionState
  10. 发布 `EVENT_STATE_PROJECT_OPENED` 事件（携带是否为已有项目的标识）
  11. **启动异步依赖健康检查**：调用 `DependencyHealthService.check_health_async()`
      - 不阻塞主流程，扫描在后台执行
      - 扫描完成后发布 `EVENT_DEPENDENCY_HEALTH_REPORT_READY` 事件
      - 若有缺失依赖，状态栏显示警告图标
  12. **启动异步代码索引**：调用 `IndexTriggerService.trigger_project_index()`（阶段五 5.7.1）
      - 不阻塞主流程，索引在后台执行
      - 使用增量索引策略（比对文件哈希，仅索引变更文件）
      - 发布 `CODE_INDEX_STARTED` 事件，状态栏显示索引进度
      - 索引完成后发布 `CODE_INDEX_COMPLETE` 事件，状态栏进度消失
      - 索引完成后语义搜索功能可用
  13. 各 UI 面板订阅事件后刷新显示
- [ ] **关闭项目时的状态清理**（`close_project()` 执行流程）：
  1. 停止所有正在运行的 Worker（通过 `worker_manager.stop_all_workers()`）
  2. 保存当前 GraphState 到 Checkpointer（确保状态持久化）
  3. 清空 SessionState 中的项目相关字段（通过图节点执行清理命令）
  4. 释放 Checkpointer 数据库连接
  5. 清空各面板显示内容（文件浏览器、代码编辑器、对话面板、下栏面板）
  6. 发布 `EVENT_STATE_PROJECT_CLOSED` 事件
  7. 更新状态栏显示"未打开项目"
- [ ] **切换项目流程**（`switch_project()` 执行流程）：
  1. 调用 `close_project()` 清理当前状态
  2. 调用 `initialize_project(new_folder_path)` 初始化新项目
  3. 若新项目初始化失败，保持"未打开项目"状态
- [ ] **最近打开列表**：
  - 存储位置：`~/.circuit_design_ai/recent_projects.json`
  - 最多保留 10 个最近打开的路径
  - 打开项目时自动添加到列表顶部
  - 列表中的无效路径（已删除）在显示时自动过滤
- [ ] **被调用方**：`main_window.py`（打开/关闭工作文件夹时）、`design_workflow.py`（启动流程前）

---

### 2.6 文件浏览器面板 (`presentation/panels/`)

> **⚠️ UI架构对齐**：本节设计遵循阶段一 1.7 节定义的 UI 层架构规范：
> - 面板通过 `PanelManager` 注册到 LEFT 区域
> - 文件变更事件通过 `UIEventBridge` 桥接到 UI 层
> - 与代码编辑器面板的通信通过 EventBus（`file_selected` 信号）

#### 2.6.1 `file_browser_panel.py` - 文件浏览器面板
- [ ] **职责**：显示工作文件夹的文件树，响应文件选择事件
- [ ] **位置**：左栏（10%宽度）
- [ ] **视觉设计**（参考 Cursor/Trae 风格）：
  - 面板背景：`#f8f9fa`（浅灰白）
  - 面板顶部标题栏：显示"EXPLORER"或项目名称，右侧有折叠/刷新图标按钮
  - 文件树使用等宽字体，行高适中（24-28px）
  - 文件/文件夹图标使用 SVG 矢量图标
  - 选中项高亮背景：`#e3f2fd`（极浅蓝）
  - 悬停项高亮背景：`#f0f7ff`（淡蓝白）
  - 缩进线（可选）：显示层级关系的垂直虚线
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法，刷新面板标题、右键菜单项等文本
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件
- [ ] **项目切换响应**：
  - 订阅 `EVENT_STATE_PROJECT_OPENED` 事件：调用 `set_root_path()` 切换到新项目目录
  - 订阅 `EVENT_STATE_PROJECT_CLOSED` 事件：清空文件树显示
  - 切换项目时自动刷新文件树，显示新项目的文件结构
- [ ] **主电路标注响应**：
  - 订阅 `EVENT_MAIN_CIRCUIT_DETECTED` 事件
  - 接收主电路候选列表，更新文件树中的星标显示
  - 调用 `update_main_circuit_markers(candidates)` 刷新标注
- [ ] **核心功能**：
  - `set_root_path(folder_path)` - 设置根目录
  - `refresh()` - 刷新文件树
  - `get_selected_file()` - 获取当前选中文件
  - `clear()` - 清空文件树显示
  - `update_main_circuit_markers(candidates)` - 更新主电路星标显示
  - `clear_main_circuit_markers()` - 清除所有主电路星标
- [ ] **UI组件**：
  - 面板标题栏：项目名称 + 操作按钮（刷新、折叠全部）
  - `QTreeView` - 树形文件结构显示，自定义 delegate 绘制图标
  - `QFileSystemModel` - 文件系统模型
- [ ] **文件图标映射**：
  - `.cir`/`.sp`/`.spice`/`.net`/`.ckt` → 电路图标（自定义 SVG）
  - `.py` → Python 图标
  - `.json` → JSON 图标
  - `.png`/`.jpg` → 图片图标
  - `.md` → Markdown 图标
  - `.docx` → Word 文档图标
  - `.pdf` → PDF 文档图标
  - 文件夹 → 展开/折叠状态不同图标
- [ ] **主电路星标显示**：
  - 被检测为主电路候选的文件，在文件名后显示星标（★）
  - 星标颜色：金色（`#FFD700`）或橙色（`#FFA500`）
  - 星标位置：文件名右侧，与文件名间隔 4px
  - 悬停提示："检测为主电路（顶层电路文件）"
  - 多个主电路候选时，所有候选文件都显示星标
  - 无主电路候选时，不显示任何星标
- [ ] **文件过滤**：
  - 隐藏 `.circuit_ai/` 目录（系统目录不显示）
  - 显示：`.cir`、`.sp`、`.spice`、`.net`、`.ckt`、`.py`、`.json`、`.png`、`.jpg`、`.txt`、`.md`、`.docx`、`.pdf`
- [ ] **右键菜单**：
  - 文件：在编辑器中打开、在系统中显示、复制路径、删除
  - 可仿真文件（根据 `executor_registry` 支持的扩展名判断）额外菜单项：
    - "运行此文件仿真" → 调用 `simulation_service.run_with_file(file_path)`，直接运行此文件
  - 文件夹：新建文件、新建文件夹、刷新、在系统中显示
- [ ] **自动刷新**：
  - 使用 `QFileSystemWatcher` 监听变化
  - 或接收 `file_watcher_worker` 的信号（阶段三实现）
- [ ] **交互**：
  - 单击文件 → 在中栏显示内容
  - 双击文件夹 → 展开/折叠
- [ ] **信号发送**：
  - `file_selected(path)` - 文件被选中
- [ ] **被调用方**：`main_window.py`（布局）、`code_editor_panel.py`（显示文件）

---

### 2.7 代码编辑器面板 (`presentation/panels/`)

> **⚠️ UI架构对齐**：本节设计遵循阶段一 1.7 节定义的 UI 层架构规范：
> - 面板通过 `PanelManager` 注册到 CENTER 区域
> - 文件保存/修改事件通过 EventBus 发布
> - 与文件浏览器面板的通信通过 EventBus

> **模块组设计说明**：代码编辑器面板功能复杂，包含语法高亮、多种文件预览、标签页管理等职责。为遵循单一职责原则，将其拆分为多个子模块：
> - `code_editor_panel.py` - 面板主类，负责标签页管理和协调
> - `editor/code_editor.py` - 代码编辑器核心组件
> - `editor/line_number_area.py` - 行号区域组件
> - `highlighters/spice_highlighter.py` - SPICE 语法高亮器
> - `highlighters/json_highlighter.py` - JSON 语法高亮器
> - `highlighters/python_highlighter.py` - Python 语法高亮器
> - `viewers/image_viewer.py` - 图片预览组件
> - `viewers/document_viewer.py` - 文档预览组件（Markdown/Word/PDF）
>
> 此设计与阶段三的 `conversation_panel` 模块组保持一致的颗粒度，便于测试和维护。

#### 2.7.1 代码编辑器模块组

##### 2.7.1.1 `presentation/panels/highlighters/spice_highlighter.py` - SPICE 语法高亮器

- [ ] **文件路径**：`presentation/panels/highlighters/spice_highlighter.py`
- [ ] **职责**：专注于 SPICE 文件的语法高亮
- [ ] **核心类**：`SpiceHighlighter(QSyntaxHighlighter)`
- [ ] **高亮规则**：
  - 注释（`*` 开头的行）：`#6a9955`（绿色）
  - 行内注释（`;` 后面的内容）：`#6a9955`（绿色）
  - 指令（`.` 开头，如 `.tran`、`.ac`、`.dc`、`.param`、`.subckt`）：`#569cd6`（蓝色，加粗）
  - 元件名（R、C、L、Q、M、D、V、I、E、F、G、H、X 开头）：`#4ec9b0`（青色）
  - 数值和单位：`#b5cea8`（浅绿）
  - 科学计数法：`#b5cea8`（浅绿）
  - 字符串（引号内）：`#ce9178`（橙色）
- [ ] **被调用方**：`code_editor.py`

##### 2.7.1.2 `presentation/panels/highlighters/json_highlighter.py` - JSON 语法高亮器

- [ ] **文件路径**：`presentation/panels/highlighters/json_highlighter.py`
- [ ] **职责**：专注于 JSON 文件的语法高亮
- [ ] **核心类**：`JsonHighlighter(QSyntaxHighlighter)`
- [ ] **高亮规则**：
  - 键名（引号内，后跟冒号）：`#9cdcfe`（浅蓝）
  - 字符串值：`#ce9178`（橙色）
  - 数值：`#b5cea8`（浅绿）
  - 布尔值和 null：`#569cd6`（蓝色）
- [ ] **被调用方**：`code_editor.py`

##### 2.7.1.3 `presentation/panels/highlighters/python_highlighter.py` - Python 语法高亮器

- [ ] **文件路径**：`presentation/panels/highlighters/python_highlighter.py`
- [ ] **职责**：专注于 Python 文件的语法高亮
- [ ] **核心类**：`PythonHighlighter(QSyntaxHighlighter)`
- [ ] **高亮规则**：
  - 关键字（def、class、if、for、while、return、import 等）：`#569cd6`（蓝色）
  - 内置函数（print、len、range、str、int 等）：`#dcdcaa`（黄色）
  - 字符串（单引号、双引号、三引号）：`#ce9178`（橙色）
  - 注释（`#` 开头）：`#6a9955`（绿色）
  - 数值：`#b5cea8`（浅绿）
  - 装饰器（`@` 开头）：`#c586c0`（紫色）
  - 类名和函数名：`#4ec9b0`（青色）
- [ ] **被调用方**：`code_editor.py`

##### 2.7.1.4 `presentation/panels/editor/line_number_area.py` - 行号区域组件

- [ ] **文件路径**：`presentation/panels/editor/line_number_area.py`
- [ ] **职责**：专注于代码编辑器的行号显示
- [ ] **核心类**：`LineNumberArea(QWidget)`
- [ ] **核心功能**：
  - `sizeHint()` - 返回行号区域的推荐尺寸
  - `paintEvent()` - 委托给编辑器绘制行号
- [ ] **视觉设计**：
  - 背景色：`#f8f9fa`（浅灰白）
  - 右侧分隔线：`#e0e0e0`
  - 行号文字颜色：`#999999`
  - 最少显示 3 位数字宽度
- [ ] **被调用方**：`code_editor.py`

##### 2.7.1.5 `presentation/panels/editor/code_editor.py` - 代码编辑器核心组件

- [ ] **文件路径**：`presentation/panels/editor/code_editor.py`
- [ ] **职责**：专注于代码编辑功能，包含行号显示、当前行高亮、语法高亮集成
- [ ] **核心类**：`CodeEditor(QPlainTextEdit)`
- [ ] **依赖**：`line_number_area.py`、`highlighters/*.py`
- [ ] **核心功能**：
  - `set_highlighter(file_ext)` - 根据文件扩展名设置语法高亮器
  - `get_file_path()` / `set_file_path(path)` - 文件路径管理
  - `is_modified()` / `set_modified(modified)` - 修改状态管理
  - `get_cursor_position()` - 获取光标位置（行号，列号）
  - `line_number_area_width()` - 计算行号区域宽度
  - `line_number_area_paint_event(event)` - 绘制行号
- [ ] **信号**：
  - `modification_changed(bool)` - 修改状态变化时发出
- [ ] **视觉设计**：
  - 编辑器背景：`#ffffff`（纯白）
  - 当前行高亮：`#f0f7ff`（淡蓝白）
  - 选中文本高亮：`#e3f2fd`（极浅蓝）
  - 等宽编程字体（JetBrains Mono、Consolas、Fira Code）
  - Tab 宽度：4 个空格
- [ ] **编辑器级别撤销**：
  - 使用 `QPlainTextEdit` 内置的撤销栈，支持 Ctrl+Z/Ctrl+Y
  - 撤销粒度为单次编辑操作
  - 关闭文件或切换标签页时撤销栈清空
- [ ] **被调用方**：`code_editor_panel.py`

##### 2.7.1.6 `presentation/panels/viewers/image_viewer.py` - 图片预览组件

- [ ] **文件路径**：`presentation/panels/viewers/image_viewer.py`
- [ ] **职责**：专注于图片文件的预览显示
- [ ] **核心类**：`ImageViewer(QScrollArea)`
- [ ] **核心功能**：
  - `load_image(path)` - 加载图片文件
  - `zoom_in()` - 放大
  - `zoom_out()` - 缩小
  - `fit_to_window()` - 适应窗口大小
- [ ] **支持格式**：`.png`、`.jpg`、`.jpeg`、`.gif`、`.bmp`
- [ ] **视觉设计**：
  - 背景色：`#f5f5f5`（浅灰）
  - 图片居中显示
  - 支持滚动查看大图
- [ ] **被调用方**：`code_editor_panel.py`

##### 2.7.1.7 `presentation/panels/viewers/document_viewer.py` - 文档预览组件

- [ ] **文件路径**：`presentation/panels/viewers/document_viewer.py`
- [ ] **职责**：专注于文档文件的只读预览（Markdown、Word、PDF）
- [ ] **核心类**：`DocumentViewer(QTextEdit)`
- [ ] **核心功能**：
  - `load_markdown(path)` - 加载 Markdown 文件，使用 `markdown` 库渲染为 HTML
  - `load_word(path)` - 加载 Word 文档，使用 `python-docx` 提取文本
  - `load_pdf(path)` - 加载 PDF 文档，使用 `PyMuPDF` 提取文本
- [ ] **支持格式**：`.md`、`.markdown`、`.docx`、`.pdf`
- [ ] **视觉设计**：
  - 只读模式
  - 背景色：`#ffffff`（纯白）
  - 内边距：20px
  - 使用系统 UI 字体
- [ ] **依赖库**：
  - `markdown` - Markdown 转 HTML
  - `python-docx` - Word 文档读取
  - `PyMuPDF` - PDF 文档处理
- [ ] **被调用方**：`code_editor_panel.py`

##### 2.7.1.8 `presentation/panels/code_editor_panel.py` - 面板主类

- [ ] **文件路径**：`presentation/panels/code_editor_panel.py`
- [ ] **职责**：协调各子组件，管理多标签页，处理文件加载和保存
- [ ] **位置**：中栏（60%宽度）
- [ ] **依赖**：`editor/code_editor.py`、`viewers/image_viewer.py`、`viewers/document_viewer.py`
- [ ] **核心功能**：
  - `load_file(path)` - 根据文件类型创建对应的编辑器/预览器
  - `save_file()` - 保存当前文件
  - `save_all_files()` - 保存所有已修改的文件
  - `get_content()` - 获取编辑器内容
  - `set_readonly(readonly)` - 设置只读模式
  - `open_tab(path)` - 在新标签页打开文件
  - `close_tab(index)` - 关闭指定标签页
  - `close_all_tabs()` - 关闭所有标签页
  - `get_open_files()` - 获取当前打开的所有文件路径列表
  - `get_current_file()` - 获取当前激活的文件路径
  - `switch_to_file(path)` - 切换到指定文件的标签页
  - `undo()` / `redo()` - 编辑器级别撤销/重做
  - `can_undo()` / `can_redo()` - 检查撤销/重做可用性
  - `reset_all_modification_states()` - 重置所有文件的修改状态（会话恢复后调用）
- [ ] **信号**：
  - `file_saved(str)` - 文件保存时发出，携带文件路径
  - `open_workspace_requested()` - 请求打开工作区时发出
  - `undo_redo_state_changed(bool, bool)` - 撤销/重做状态变化信号
  - `editable_file_state_changed(bool)` - 可编辑文件状态变化信号
- [ ] **标签栏设计**：
  - 使用自定义 `EditorTabBar(QTabBar)` 组件
  - 标签显示文件名，悬停显示完整路径
  - 修改未保存时标签名后显示 ●
  - 关闭按钮始终可见
  - 右键菜单：关闭、关闭其他、关闭全部、复制路径
  - 标签栏滚动：标签过多时显示左右滚动按钮
- [ ] **文件类型路由**：
  - 可编辑文件（`.cir`、`.sp`、`.spice`、`.json`、`.txt`、`.py`）→ `CodeEditor`
  - 图片文件（`.png`、`.jpg`、`.jpeg`、`.gif`、`.bmp`）→ `ImageViewer`
  - 文档文件（`.md`、`.markdown`、`.docx`、`.pdf`）→ `DocumentViewer`
- [ ] **空状态设计**：
  - 无标签页时显示空状态占位组件
  - 无项目时显示"打开工作区"按钮
  - 有项目时显示"选择文件查看"提示
- [ ] **底部状态条**：
  - 显示行列号（Ln x, Col y）
  - 显示编码（UTF-8）
  - 显示文件类型（SPICE/JSON/Plain Text 等）
  - 只读模式时显示"READ ONLY"标签
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件
- [ ] **项目切换响应**：
  - 订阅 `EVENT_STATE_PROJECT_OPENED` 事件：关闭所有标签页
  - 订阅 `EVENT_STATE_PROJECT_CLOSED` 事件：关闭所有标签页，显示空状态
- [ ] **工作流锁定响应**：
  - 订阅 `EVENT_WORKFLOW_LOCKED` 事件：设置只读模式
  - 订阅 `EVENT_WORKFLOW_UNLOCKED` 事件：取消只读模式
- [ ] **文件加载时修改状态处理**：
  - 加载文件内容时阻止信号触发，避免误触发修改状态
  - 设置完成后彻底重置修改状态
- [ ] **保存流程**：
  1. 点击保存按钮或 Ctrl+S
  2. 调用 `file_manager.update_file()`
  3. 更新标签页未保存标记
  4. 发出 `file_saved` 信号
- [ ] **被调用方**：`main_window.py`、`file_browser_panel.py`（文件选择）

---

### 2.8 主窗口更新 (`presentation/`)

#### 2.8.1 `main_window.py` - 集成文件面板
- [ ] **本阶段新增**：
  - 将左栏占位替换为 `file_browser_panel`
  - 将中栏占位替换为 `code_editor_panel`
  - 连接文件浏览器的 `file_selected` 信号到代码编辑器
  - 实现"打开工作文件夹"完整流程（调用 `project_service`）
- [ ] **菜单栏更新**：
  - **文件菜单**：新增"关闭文件夹"、"最近打开"子菜单
  - **编辑菜单**：启用"撤销"和"重做"（编辑器级别，调用 `QPlainTextEdit` 内置方法）
  - **国际化**：新增菜单项文本需添加到 `i18n_manager` 文本字典
- [ ] **关闭文件夹功能**：
  - 点击后调用 `project_service.close_project()`
  - 清理完成后显示首次运行引导遮罩层
  - 用户可重新选择工作文件夹
- [ ] **最近打开子菜单**：
  - 从 `project_service.get_recent_projects()` 获取列表
  - 显示最近 10 个项目路径（仅显示文件夹名，悬停显示完整路径）
  - 点击后调用 `project_service.switch_project(path)`
  - 无效路径（已删除）显示为灰色并标注"(不存在)"
- [ ] **工具栏更新**：
  - `[打开]` - 完整功能
- [ ] **状态栏更新**：
  - 显示当前工作文件夹路径

---






































## 阶段 2.5：状态管理与文件快照架构 (0.5周)

> **目标**：建立"基于引用的单一数据源"架构，GraphState 作为唯一真理来源，存储文件路径和轻量摘要，业务数据存储在文件系统，领域服务提供无状态的读写接口

> **⚠️ 核心架构原则：Reference-Based Single Source of Truth**
> - **GraphState 是目录**：仅存储文件路径（指针）和轻量摘要，不存储重数据
> - **文件系统是仓库**：仿真结果、设计目标、对话历史等业务数据存储在文件中
> - **领域服务是搬运工**：无状态的纯函数式服务，输入 → 处理 → 输出到文件 → 返回路径
> - **LangGraph 管理版本**：通过 SqliteSaver 持久化 GraphState，回滚时指针自动回退
> - **SnapshotService 管理文件**：全量快照项目文件，支持文件级别的回滚（使用 shutil 标准库，简单可靠）

> **⚠️ 与旧架构的区别**：
> - **废弃**：有状态的领域状态管理器（DesignStateManager、SimulationStateManager 等）
> - **废弃**：StateCoordinator 协调内存状态
> - **新增**：无状态的领域服务（DesignService、SimulationService 等）
> - **新增**：GraphState 存储文件路径和摘要字段

> **⚠️ 跨阶段依赖**：
> - 阶段三：ContextService（对话历史读写）
> - 阶段四：SimulationService（仿真执行与结果存储）
> - 阶段五：RAGService（检索执行）
> - 阶段七：DesignService（设计目标读写）、GraphState 定义
> - 阶段八：撤回机制（线性快照恢复 + GraphState 重建）

---

### 2.5.1 架构概览

#### 2.5.1.1 核心架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    LangGraph 工作流层                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              GraphState (单一数据源)                      │   │
│  │                                                         │   │
│  │  流转控制：session_id, work_mode, current_node, intent  │   │
│  │  文件指针：circuit_file_path, sim_result_path           │   │
│  │  轻量摘要：design_goals_summary, last_metrics           │   │
│  │  消息聚合：messages (LangGraph 内部使用)                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              │ SqliteSaver 持久化               │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │           checkpoints.sqlite3 (GraphState 版本)          │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 图节点调用
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    无状态领域服务层                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │DesignService │  │SimulationSvc │  │ ContextService       │  │
│  │ (设计目标)   │  │ (仿真执行)   │  │ (对话历史)           │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
│         │                 │                    │                │
│         │ 读写文件        │ 读写文件           │ 读写文件       │
│         ↓                 ↓                    ↓                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    文件系统 (业务数据仓库)                │   │
│  │  .circuit_ai/design_goals.json                          │   │
│  │  .circuit_ai/sim_results/run_001.json                   │   │
│  │  .circuit_ai/conversations/{session_id}.json            │   │
│  │  amplifier.cir, parameters.json, ...                    │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 文件快照
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    全量快照服务                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              SnapshotService (shutil.copytree)           │   │
│  │                                                         │   │
│  │  create_snapshot() - 全量拷贝项目文件到快照目录          │   │
│  │  restore_snapshot() - 从快照目录恢复项目文件             │   │
│  │  cleanup_old_snapshots() - 保留最近 N 个快照             │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```



#### 2.5.1.2 数据分类原则

- [ ] **存入 GraphState 的数据**（轻量，决定流程走向）：
  - 流转控制：`session_id`、`work_mode`、`current_node`、`user_intent`
  - 文件指针：`circuit_file_path`、`sim_result_path`、`design_goals_path`
  - 轻量摘要：`design_goals_summary`、`last_metrics`、`error_context`
  - 计数器：`iteration_count`、`checkpoint_count`、`stagnation_count`
- [ ] **存入文件系统的数据**（重量，通过路径引用）：
  - 仿真波形数据：序列化为 JSON/NumPy，存入 `.circuit_ai/sim_results/`
  - 设计目标详情：存入 `.circuit_ai/design_goals.json`
  - 完整对话历史：存入 `.circuit_ai/conversations/{session_id}.json`
  - 电路文件：用户项目目录中的 `.cir`、`.sp` 文件
- [ ] **视图投影数据**（从 GraphState 历史派生，不独立存储）：
  - 迭代历史：从 SqliteSaver 的检查点历史中查询，是 GraphState 版本的视图投影
  - 避免双写一致性问题，UI 需要时实时查询
- [ ] **不存储的数据**（按需获取）：
  - RAG 检索结果：每次检索时实时获取
  - ChromaDB 向量索引：由 ChromaDB 自己管理

#### 2.5.1.3 回滚机制原理（线性撤回）

> **⚠️ 简化设计**：放弃 LangGraph Time Travel 分支机制，采用"文件快照恢复 + GraphState 重建"的线性撤回方案

```
[用户请求回滚到上一步]
       │
       ├─→ RecoveryLogService 写入恢复意图日志
       │
       ├─→ SnapshotService.restore_snapshot()
       │   └─→ 从快照目录全量恢复项目文件
       │       └─→ amplifier.cir 内容恢复到上一步的版本
       │
       ├─→ initialize_project() 重建 GraphState
       │   └─→ 从磁盘文件重新构建内存状态
       │       └─→ sim_result_path 从文件系统读取
       │       └─→ circuit_file_path 从文件系统读取
       │
       └─→ RecoveryLogService 清理恢复日志

[结果]
- 文件系统中的文件内容恢复到旧版本
- GraphState 从磁盘文件重建，指向正确的文件路径
- 无需复杂的内存状态同步
- 崩溃恢复：启动时检查未完成的恢复日志
```

---

### 2.5.2 GraphState 字段设计 (`application/graph/state.py`)

> **设计原则**：GraphState 是唯一真理来源，存储指针和摘要，不存储重数据

- [ ] **文件路径**：`application/graph/state.py`
- [ ] **职责**：定义 LangGraph 工作流的状态结构

#### 2.5.2.1 GraphState 字段定义

- [ ] **会话与模式控制**：
  - `session_id: str` - 会话标识，格式 YYYYMMDD_HHMMSS
  - `work_mode: str` - 工作模式（"workflow" | "free_work"）
  - `project_root: str` - 项目根目录路径
- [ ] **流转控制**：
  - `current_node: str` - 当前执行的节点名称
  - `previous_node: str` - 上一个执行的节点名称
  - `user_input: str` - 用户最新输入消息
  - `user_intent: str` - 用户意图类型
  - `is_completed: bool` - 是否完成
  - `termination_reason: str` - 终止原因
- [ ] **文件指针**（核心：存路径不存内容）：
  - `circuit_file_path: str` - 主电路文件相对路径
  - `sim_result_path: str` - 最新仿真结果文件相对路径
  - `design_goals_path: str` - 设计目标文件相对路径
- [ ] **轻量摘要**（用于条件边判断和 UI 显示）：
  - `design_goals_summary: dict` - 设计目标摘要（指标名称和目标值）
  - `last_metrics: dict` - 最新仿真指标摘要（如 `{"gain": "20dB", "bandwidth": "10MHz"}`）
  - `error_context: str` - 错误上下文（仿真失败时的错误信息）
- [ ] **计数器**：
  - `iteration_count: int` - 迭代次数
  - `checkpoint_count: int` - 检查点计数
  - `stagnation_count: int` - 停滞计数（连续未改善次数）
- [ ] **消息聚合**（LangGraph 内部使用）：
  - `messages: Annotated[list[AnyMessage], add_messages]` - 消息序列

#### 2.5.2.2 状态修改规范

- [ ] **图节点返回值模式**：
  - 图节点通过返回字典修改 GraphState
  - 返回值只包含需要更新的字段
  - 示例：`return {"sim_result_path": "sim_results/run_003.json", "last_metrics": {...}}`
- [ ] **禁止的操作**：
  - 禁止直接修改传入的 `state` 参数
  - 禁止在 GraphState 中存储大型数据（如完整仿真波形）
  - 禁止在异步任务中直接修改 GraphState

---

### 2.5.3 无状态领域服务设计

> **设计原则**：领域服务是纯函数式的"搬运工"，输入 → 处理 → 输出到文件 → 返回路径/摘要

#### 2.5.3.1 领域服务目录结构

```
domain/services/
├── __init__.py
├── design_service.py              # 设计目标读写服务
├── simulation_service.py          # 仿真执行服务（阶段四实现）
├── context_service.py             # 对话历史读写服务（阶段三实现）
├── rag_service.py                 # RAG 检索服务（阶段五实现）
└── iteration_history_service.py   # 迭代历史视图服务（从 SqliteSaver 查询）
```



#### 2.5.3.2 `design_service.py` - 设计目标服务

- [ ] **文件路径**：`domain/services/design_service.py`
- [ ] **职责**：提供设计目标的读写接口，数据存储在文件中
- [ ] **设计原则**：无状态，不持有任何内存数据
- [ ] **核心方法**：
  - `save_design_goals(project_root, goals) -> str` - 保存设计目标到文件，返回文件路径
  - `load_design_goals(project_root, file_path) -> dict` - 从文件加载设计目标
  - `get_goals_summary(goals) -> dict` - 提取设计目标摘要（用于存入 GraphState）
- [ ] **存储路径**：
  - 设计目标：`.circuit_ai/design_goals.json`
- [ ] **被调用方**：`design_goals_node`、`analysis_node`

#### 2.5.3.3 `simulation_service.py` - 仿真执行服务

- [ ] **文件路径**：`domain/services/simulation_service.py`
- [ ] **职责**：执行仿真并将结果存储到文件
- [ ] **设计原则**：无状态，仿真结果直接写入文件
- [ ] **核心方法**：
  - `run_simulation(project_root, circuit_file) -> tuple[str, dict]` - 执行仿真，返回 (结果文件路径, 指标摘要)
  - `load_sim_result(project_root, result_path) -> dict` - 从文件加载仿真结果
  - `extract_metrics(sim_data, goals) -> dict` - 提取性能指标摘要
- [ ] **存储路径**：
  - 仿真结果：`.circuit_ai/sim_results/{uuid}.json`
- [ ] **被调用方**：`simulation_node`

#### 2.5.3.4 `context_service.py` - 对话历史服务

- [ ] **文件路径**：`domain/services/context_service.py`
- [ ] **职责**：管理对话历史的读写
- [ ] **设计原则**：无状态，对话历史存储在文件/SQLite 中
- [ ] **核心方法**：
  - `save_messages(project_root, session_id, messages) -> None` - 保存消息到文件
  - `load_messages(project_root, session_id) -> list` - 加载消息历史
  - `append_message(project_root, session_id, message) -> None` - 追加单条消息
  - `get_recent_messages(project_root, session_id, limit) -> list` - 获取最近 N 条消息
- [ ] **存储路径**：
  - 对话历史：`.circuit_ai/conversations/{session_id}.json`
- [ ] **被调用方**：所有需要对话历史的图节点

#### 2.5.3.5 `rag_service.py` - RAG 检索服务

- [ ] **文件路径**：`domain/services/rag_service.py`
- [ ] **职责**：执行 RAG 检索，返回检索结果
- [ ] **设计原则**：无状态，检索结果不缓存在内存中
- [ ] **核心方法**：
  - `retrieve(query, top_k) -> list[SearchResult]` - 执行检索，返回结果列表
  - `get_index_status() -> dict` - 获取索引状态
- [ ] **存储**：
  - 向量索引由 ChromaDB 管理，不在本服务中持有
- [ ] **被调用方**：`rag_node`、`free_work_node`

#### 2.5.3.6 `iteration_history_service.py` - 迭代历史视图服务

> **设计理念**：迭代历史是 GraphState 历史版本的视图投影，不独立存储，避免双写一致性问题

- [ ] **文件路径**：`domain/services/iteration_history_service.py`
- [ ] **职责**：从 SqliteSaver 查询 GraphState 历史，提供迭代历史视图
- [ ] **设计原则**：
  - 只读服务，不写入任何数据
  - 迭代历史是 GraphState 检查点的派生视图
  - 每次查询实时从 SqliteSaver 获取，保证数据一致性
- [ ] **核心方法**：
  - `get_iteration_history(checkpointer, thread_id) -> list[IterationRecord]` - 获取迭代历史列表
  - `get_iteration_detail(checkpointer, thread_id, checkpoint_id) -> IterationRecord` - 获取单次迭代详情
  - `get_latest_iteration(checkpointer, thread_id) -> IterationRecord` - 获取最新迭代
- [ ] **IterationRecord 数据结构**：
  - `checkpoint_id: str` - 检查点 ID
  - `iteration_count: int` - 迭代次数
  - `metrics: dict` - 仿真指标摘要（从 `last_metrics` 提取）
  - `goals_summary: dict` - 设计目标摘要
  - `timestamp: str` - 创建时间
  - `node_name: str` - 当时执行的节点名称
- [ ] **查询逻辑**：
  - 调用 `checkpointer.list()` 获取检查点列表
  - 从每个检查点的 GraphState 中提取 `iteration_count`、`last_metrics` 等字段
  - 组装为 `IterationRecord` 返回
- [ ] **被调用方**：迭代历史面板 UI、`analysis_node`（用于判断停滞）

---

### 2.5.4 全量快照服务

> **设计理念**：使用 Python 标准库 shutil 实现全量文件快照，简单可靠，避免重造轮子
> 
> **为什么不用增量快照**：电路设计项目文件通常在 KB 级别，全量拷贝在毫秒级完成。自制增量快照（内容寻址、哈希去重、变更追踪）本质上是重新实现 Git，复杂度高、边缘情况多、维护成本大，收益却很小。

#### 2.5.4.1 快照服务目录结构

```
domain/services/
├── ...
└── snapshot_service.py     # 全量快照服务
```

#### 2.5.4.2 `snapshot_service.py` - 全量快照服务

- [ ] **文件路径**：`domain/services/snapshot_service.py`
- [ ] **职责**：提供项目文件的全量快照创建、恢复、清理功能
- [ ] **设计原则**：
  - 使用 `shutil.copytree` 实现全量拷贝，依赖标准库的可靠性
  - 无状态设计，不持有内存数据
  - 简单的保留策略：只保留最近 N 个快照（默认 10 个）
- [ ] **核心方法**：
  - `create_snapshot(project_root, snapshot_id) -> str` - 创建全量快照，返回快照路径
  - `restore_snapshot(project_root, snapshot_id) -> None` - 从快照恢复项目文件
  - `list_snapshots(project_root) -> List[SnapshotInfo]` - 列出所有快照
  - `delete_snapshot(project_root, snapshot_id) -> None` - 删除指定快照
  - `cleanup_old_snapshots(project_root, keep_count) -> int` - 清理旧快照，返回删除数量
- [ ] **SnapshotInfo 数据结构**：
  - `snapshot_id: str` - 快照标识
  - `timestamp: str` - 创建时间（ISO 格式）
  - `size_bytes: int` - 快照大小（字节）
  - `file_count: int` - 文件数量
- [ ] **忽略规则**：
  - 快照时忽略：`.circuit_ai/snapshots/`、`__pycache__/`、`.git/`、`*.pyc`
  - 使用 `shutil.ignore_patterns()` 实现
- [ ] **存储路径**：
  - 快照目录：`.circuit_ai/snapshots/{snapshot_id}/`
  - 每个快照是项目文件的完整副本
- [ ] **错误处理**：
  - 快照创建失败时清理不完整的快照目录
  - 恢复失败时保留原文件不变
  - 磁盘空间不足时抛出明确异常
- [ ] **被调用方**：`user_checkpoint_node`、`undo_node`



---

### 2.5.5 与 LangGraph Checkpointer 的协作

> **双层持久化设计**：LangGraph SqliteSaver 负责 GraphState 版本管理，SnapshotService 负责项目文件版本管理

#### 2.5.5.1 检查点创建流程

```
[图节点执行完成]
       │
       ├─→ 图节点调用领域服务
       │   └─→ 领域服务将数据写入文件
       │       └─→ 返回文件路径和摘要
       │
       ├─→ 图节点返回 GraphState 更新
       │   └─→ {"sim_result_path": "...", "last_metrics": {...}}
       │
       ├─→ LangGraph 运行时调用 SqliteSaver
       │   └─→ 保存 GraphState 到 SQLite
       │
       └─→ 在检查点节点调用 SnapshotService
           └─→ 使用 shutil.copytree 创建项目文件的全量快照
           └─→ 自动清理超出保留数量的旧快照
```

#### 2.5.5.2 检查点恢复流程（线性撤回）

> **⚠️ 简化设计**：放弃 LangGraph Time Travel 分支机制，采用"文件快照恢复 + GraphState 重建"的线性撤回方案

```
[用户请求回滚]
       │
       ├─→ RecoveryLogService 写入恢复意图日志
       │
       ├─→ SnapshotService.restore_snapshot()
       │   └─→ 清理当前项目文件（保留 .circuit_ai）
       │   └─→ 从快照目录全量拷贝恢复
       │
       ├─→ initialize_project() 重建 GraphState
       │   └─→ 从磁盘文件重新构建内存状态
       │
       └─→ RecoveryLogService 清理恢复日志
```

#### 2.5.5.3 检查点 ID 关联

- [ ] **ID 生成规则**：
  - 格式：`{session_id}_{timestamp}_{sequence}`
  - 示例：`20241220_143022_001`
- [ ] **ID 关联**：
  - SqliteSaver 的 thread_id 使用 session_id
  - SnapshotService 的 snapshot_id 与 LangGraph checkpoint_id 关联
- [ ] **快照保留策略**：
  - 默认保留最近 10 个快照
  - 每次创建新快照后自动清理超出数量的旧快照
  - 可通过配置调整保留数量

---

### 2.5.6 存储目录结构

```
{project_root}/
├── amplifier.cir                    # 用户电路文件
├── parameters.json                  # 用户参数文件
└── .circuit_ai/
    ├── checkpoints.sqlite3          # LangGraph GraphState 版本（SqliteSaver）
    │                                # 迭代历史从此处查询，不独立存储
    ├── design_goals.json            # 设计目标（业务数据）
    ├── sim_results/                 # 仿真结果目录
    │   ├── run_001.json
    │   └── run_002.json
    ├── conversations/               # 对话历史目录
    │   └── 20241220_143022.json
    └── snapshots/                   # 全量快照目录
        ├── 20241220_143022_001/     # 快照 1（完整项目副本）
        │   ├── amplifier.cir
        │   └── parameters.json
        └── 20241220_143500_002/     # 快照 2（完整项目副本）
            ├── amplifier.cir
            └── parameters.json
```

> **磁盘空间估算**：假设每个快照 500KB，保留 10 个快照约 5MB，完全可接受
> 
> **迭代历史说明**：迭代历史不再作为独立文件存储，而是从 `checkpoints.sqlite3` 中的 GraphState 历史版本派生。这避免了 SQLite 和 JSON 文件之间的双写一致性问题。

---

### 2.5.7 阶段检查点

#### 2.5.7.1 架构验证检查项

- [ ] GraphState 字段定义完整，包含文件指针和摘要字段
- [ ] 领域服务为无状态设计，不持有内存数据
- [ ] 领域服务正确读写文件
- [ ] 图节点通过返回值更新 GraphState
- [ ] 迭代历史从 SqliteSaver 查询，不独立存储

#### 2.5.7.2 快照服务验证检查项

- [ ] `create_snapshot()` 正确创建项目文件的全量副本
- [ ] `restore_snapshot()` 正确恢复项目文件
- [ ] `cleanup_old_snapshots()` 正确清理超出保留数量的旧快照
- [ ] 快照忽略规则正确（不拷贝 `.circuit_ai/snapshots/`、`__pycache__/` 等）
- [ ] 快照创建失败时正确清理不完整的快照目录

#### 2.5.7.3 迭代历史视图服务验证检查项

- [ ] `get_iteration_history()` 正确从 SqliteSaver 查询检查点列表
- [ ] `IterationRecord` 正确提取 `iteration_count`、`last_metrics` 等字段
- [ ] 查询结果与 GraphState 历史版本一致
- [ ] 无独立的 `iteration_history.json` 文件存在

#### 2.5.7.4 集成验证检查项

- [ ] LangGraph SqliteSaver 正常持久化 GraphState
- [ ] SnapshotService 正确恢复项目文件
- [ ] RecoveryLogService 正确记录和清理恢复日志
- [ ] initialize_project 正确重建 GraphState
- [ ] 回滚后项目文件内容正确恢复
- [ ] 崩溃恢复机制正常工作

#### 2.5.7.5 性能验证检查项

- [ ] 快照创建时间在毫秒级（小项目，KB 级文件）
- [ ] 快照恢复时间在毫秒级（小项目）
- [ ] 10 个快照的磁盘占用在合理范围内（< 10MB）
- [ ] 迭代历史查询响应时间可接受（< 100ms）
