## 阶段四：仿真引擎与可视化 (3周)

> **目标**：实现电路仿真、性能指标提取、图表生成，完成下栏面板（仿真结果标签页 + 报告生成标签页）

> **⚠️ 核心架构：基于引用的单一数据源**：
> - **SimulationService**：无状态仿真服务，执行仿真并将结果存储到文件
> - **数据访问**：图节点调用 SimulationService，返回文件路径和指标摘要到 GraphState
> - **文件系统是仓库**：仿真结果存储在 `.circuit_ai/sim_results/{uuid}.json`
> - **GraphState 存指针**：`sim_result_path` 和 `last_metrics` 字段

> **⚠️ 本阶段统一管理提示**：
> - SPICE 仿真通过 PySpice 的 NgSpiceShared 共享库模式执行，ngspice 在同一进程内运行
> - Python 脚本仿真通过 subprocess 在子进程中执行，提供基础进程隔离
> - 仿真进度通过 `EventBus` 事件通知 UI，使用 `EventThrottler` 聚合高频进度更新
> - 仿真结果通过 SimulationService 写入文件，GraphState 存储文件路径
> - 仿真错误通过 ErrorHandler 统一处理，不自动回滚
> - 新增 UI 面板需实现 `retranslate_ui()` 方法

> **⚠️ 跨阶段依赖检查**：
> - 开始本阶段前，必须确认以下模块已正确实现并读取其源码：
>   - `domain/state/base_state_manager.py` - 领域状态管理器基类（阶段 2.5）
>   - `domain/state/state_coordinator.py` - 状态协调器（阶段 2.5）
>   - `shared/async_task_registry.py` - 异步任务注册表（阶段一）
>   - `infrastructure/persistence/file_manager.py` - 文件写入接口
>   - `shared/error_handler.py` - 错误处理接口
>   - `shared/event_throttler.py` - 事件节流器（阶段一）

### 4.0 仿真域架构概览

> **架构设计原则**：
> - 单一职责：每个模块专注于一个明确的职责
> - 开闭原则：通过策略模式和注册表模式支持扩展
> - 依赖倒置：高层模块依赖抽象接口，不依赖具体实现
> - 数据类型化：使用 dataclass 定义标准化数据结构，确保类型安全

#### 4.0.1 仿真域目录结构

```
domain/simulation/
├── __init__.py
├── models/                          # 数据模型定义
│   ├── __init__.py
│   ├── simulation_result.py         # 仿真结果数据类
│   ├── simulation_error.py          # 仿真错误数据类
│   └── simulation_config.py         # 仿真配置数据类
├── executor/                        # 仿真执行器
│   ├── __init__.py
│   ├── simulation_executor.py       # 执行器抽象基类
│   ├── executor_registry.py         # 执行器注册表
│   ├── spice_executor.py            # SPICE 执行器（含错误解析）
│   ├── python_executor.py           # Python 执行器
│   ├── circuit_analyzer.py          # 电路文件分析器
│   └── file_discovery.py            # 文件发现策略
├── service/                         # 仿真服务层
│   ├── __init__.py
│   ├── simulation_service.py        # 门面类
│   ├── basic_simulation_runner.py   # 基础仿真执行
│   ├── advanced_simulation_runner.py # 高级仿真执行
│   ├── tuning_service.py            # 快速调参服务
│   ├── simulation_control_service.py # 仿真进度控制
│   ├── main_circuit_detector.py     # 主电路检测
│   ├── simulation_state_manager.py  # 状态管理
│   └── simulation_config_service.py # 配置服务（用户手动设置）
├── analysis/                        # 高级分析模块
│   ├── __init__.py
│   ├── pvt_analysis.py
│   ├── monte_carlo_analysis.py
│   ├── parametric_sweep.py
│   ├── worst_case_analysis.py
│   ├── sensitivity_analysis.py
│   ├── post_processor.py
│   └── topology_recognizer.py
├── metrics/                         # 指标提取
│   ├── __init__.py
│   ├── metrics_extractor.py         # 门面类
│   ├── metric_result.py             # 指标结果数据类
│   ├── amplifier_metrics.py         # 放大器指标
│   ├── noise_metrics.py             # 噪声指标
│   ├── distortion_metrics.py        # 失真指标
│   ├── power_metrics.py             # 电源指标
│   └── transient_metrics.py         # 瞬态指标
├── visualization/                   # 可视化模块
│   ├── __init__.py
│   ├── chart_generator.py           # 图表生成
│   ├── waveform_measurement.py      # 波形测量
│   ├── waveform_math.py             # 波形数学运算
│   ├── simulation_result_storage.py # 仿真结果存储
│   ├── data_exporter.py             # 数据导出
│   └── report_generator.py          # PDF报告生成
├── schematic/                       # 电路图生成子域（新增）
│   ├── __init__.py
│   ├── models/                      # 电路图数据模型
│   │   ├── __init__.py
│   │   ├── schematic_element.py     # 元件数据类
│   │   ├── schematic_connection.py  # 连接数据类
│   │   └── schematic_layout.py      # 布局结果数据类
│   ├── parser/                      # 网表解析器
│   │   ├── __init__.py
│   │   ├── netlist_parser.py        # 网表解析门面类
│   │   ├── element_extractor.py     # 元件提取器
│   │   └── connection_analyzer.py   # 连接关系分析器
│   ├── layout/                      # 布局引擎
│   │   ├── __init__.py
│   │   ├── layout_engine.py         # 布局引擎门面类
│   │   ├── force_directed.py        # 力导向布局算法
│   │   ├── hierarchical_layout.py   # 层次化布局算法
│   │   └── layout_optimizer.py      # 布局优化器
│   ├── renderer/                    # 渲染器（统一使用 QGraphicsScene）
│   │   ├── __init__.py
│   │   ├── symbol_library.py        # 元件符号库（Qt 绘图定义）
│   │   ├── schematic_exporter.py    # 静态导出器（复用 Scene 导出图片）
│   │   ├── schematic_scene.py       # 电路图场景（QGraphicsScene）
│   │   ├── schematic_view.py        # 电路图视图（QGraphicsView）
│   │   ├── element_items.py         # 元件图形项（QGraphicsItem）
│   │   ├── wire_item.py             # 连线图形项
│   │   └── interaction_handler.py   # 交互处理器
│   └── schematic_service.py         # 电路图服务门面类
├── convergence_helper.py            # 收敛辅助
├── feedback_generator.py            # 反馈生成器
└── library_manager.py               # 子电路库管理

# infrastructure 层相关模块
infrastructure/utils/
└── ngspice_config.py                # ngspice 路径配置（已实现）

infrastructure/library/
└── library_downloader.py            # 元件库下载器
```

#### 4.0.2 仿真数据流图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           仿真数据流转路径                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [UI 触发仿真]                                                          │
│       │                                                                 │
│       ▼                                                                 │
│  SimulationService.run_with_auto_detect()                               │
│       │                                                                 │
│       ├──► FileDiscoveryStrategy.discover()                             │
│       │         │                                                       │
│       │         ▼                                                       │
│       │    CircuitAnalyzer.detect_main_circuit()                        │
│       │         │                                                       │
│       │         ▼                                                       │
│       │    [主电路文件路径]                                              │
│       │                                                                 │
│       ├──► ExecutorRegistry.get_executor_for_file()                     │
│       │         │                                                       │
│       │         ▼                                                       │
│       │    [SpiceExecutor / PythonExecutor]                             │
│       │                                                                 │
│       ▼                                                                 │
│  BasicSimulationRunner.execute()                                        │
│       │                                                                 │
│       ├──► SpiceExecutor.execute()                                      │
│       │         │                                                       │
│       │         ├──► ProcessMonitor.start_process()                     │
│       │         │         │                                             │
│       │         │         ▼                                             │
│       │         │    [ngspice 进程]                                     │
│       │         │         │                                             │
│       │         │         ▼                                             │
│       │         │    [原始仿真输出]                                      │
│       │         │                                                       │
│       │         ├──► SpiceExecutor._parse_exception() ──► [错误? → 恢复策略]│
│       │         │                                                       │
│       │         ▼                                                       │
│       │    SimulationResult (dataclass)                                 │
│       │                                                                 │
│       ▼                                                                 │
│  [仿真成功?]                                                            │
│       │                                                                 │
│       ├─ 是 ──► MetricsExtractor.extract_metrics()                      │
│       │              │                                                  │
│       │              ▼                                                  │
│       │         [性能指标字典]                                           │
│       │              │                                                  │
│       │              ▼                                                  │
│       │         ChartGenerator.generate_charts()                        │
│       │              │                                                  │
│       │              ▼                                                  │
│       │         [图表文件路径]                                           │
│       │              │                                                  │
│       │              ▼                                                  │
│       │         SimulationResultStorage.save_*()                        │
│       │                                                                 │
│       ├─ 否 ──► SpiceExecutor._parse_exception()                        │
│       │              │                                                  │
│       │              ▼                                                  │
│       │         SimulationError (dataclass)                             │
│       │              │                                                  │
│       │              ▼                                                  │
│       │         [错误信息写入 GraphState]                                │
│       │                                                                 │
│       ▼                                                                 │
│  EventBus.publish(EVENT_SIMULATION_COMPLETE, result)                    │
│       │                                                                 │
│       ▼                                                                 │
│  [UI 订阅更新显示]                                                       │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 4.0.3 仿真事件定义

> **设计原则**：集中定义所有仿真相关事件常量，避免事件名拼写错误，便于追踪发布者和订阅者

- [x] **文件路径**：`shared/event_types.py`（遵循现有架构，在统一的事件类型文件中定义）
- [x] **事件常量定义**（模块级常量，遵循 `EVENT_` 前缀命名规范）：

**基础仿真事件**：
```python
# 仿真生命周期事件
EVENT_SIM_STARTED = "sim_started"           # 仿真开始
EVENT_SIM_PROGRESS = "sim_progress"         # 仿真进度（节流发布）
EVENT_SIM_COMPLETE = "sim_complete"         # 仿真完成
EVENT_SIM_ERROR = "sim_error"               # 仿真错误
EVENT_SIM_CANCELLED = "sim_cancelled"       # 仿真取消
EVENT_SIM_PAUSED = "sim_paused"             # 仿真暂停
EVENT_SIM_RESUMED = "sim_resumed"           # 仿真恢复
EVENT_SIM_CONFIG_CHANGED = "sim_config_changed"  # 仿真配置变更

# 电路分析事件
EVENT_MAIN_CIRCUIT_DETECTED = "main_circuit_detected"
EVENT_MAIN_CIRCUIT_CHANGED = "main_circuit_changed"
EVENT_CIRCUIT_ANALYSIS_COMPLETE = "circuit_analysis_complete"
```

**高级仿真事件**（PVT/蒙特卡洛/参数扫描）：
```python
EVENT_PVT_CORNER_COMPLETE = "sim_pvt_corner_complete"
EVENT_MONTE_CARLO_RUN_COMPLETE = "sim_monte_carlo_run_complete"
EVENT_SWEEP_POINT_COMPLETE = "sim_sweep_point_complete"
```

**电路图事件**：
```python
EVENT_SCHEMATIC_LOADED = "schematic_loaded"
EVENT_SCHEMATIC_ELEMENT_SELECTED = "schematic_element_selected"
EVENT_SCHEMATIC_ELEMENT_HOVERED = "schematic_element_hovered"
EVENT_SCHEMATIC_JUMP_TO_SOURCE = "schematic_jump_to_source"
EVENT_SCHEMATIC_ZOOM_CHANGED = "schematic_zoom_changed"
```

- [x] **使用方式**：所有仿真相关模块通过 `from shared.event_types import EVENT_SIM_*` 导入使用
- [x] **事件数据结构**：每个事件的携带数据已在 `event_types.py` 中以注释形式详细说明

#### 4.0.3.1 仿真结果到 UI 的事件链路

> **设计目标**：确保仿真结果从执行完成到 UI 显示的完整事件链路清晰可追踪

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      仿真结果 → UI 事件链路                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [仿真子进程完成]                                                        │
│       │                                                                 │
│       ▼                                                                 │
│  SimulationTask.run_simulation_async() 读取结果文件                      │
│       │                                                                 │
│       ▼                                                                 │
│  EventBus.publish(SIMULATION_COMPLETE, {result, metrics, charts})       │
│       │                                                                 │
│       ├──► UIEventBridge.on_simulation_complete()                       │
│       │         │                                                       │
│       │         ▼                                                       │
│       │    QMetaObject.invokeMethod() 切换到主线程                       │
│       │         │                                                       │
│       │         ▼                                                       │
│       │    SimulationViewModel.load_result(result)                      │
│       │         │                                                       │
│       │         ├──► 更新 metrics_list 属性                             │
│       │         ├──► 更新 chart_paths 属性                              │
│       │         └──► 发射 dataChanged 信号                              │
│       │                   │                                             │
│       │                   ▼                                             │
│       │              SimulationTab 响应信号更新 UI                       │
│       │                   │                                             │
│       │                   ├──► MetricsPanel.update_metrics()            │
│       │                   └──► ChartViewer.load_chart()                 │
│       │                                                                 │
│       └──► GraphStateProjector.on_simulation_complete()                 │
│                 │                                                       │
│                 ▼                                                       │
│            更新 SessionState.last_simulation_result                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

- [x] **关键节点说明**：
  - `SimulationTask`：在主进程中监听子进程完成，读取结果文件
  - `EventBus.publish`：发布领域事件，携带结构化数据
  - `UIEventBridge`：桥接领域事件到 UI 层，确保主线程执行
  - `SimulationViewModel`：转换数据格式，触发 UI 绑定更新
  - `GraphStateProjector`：同步更新 SessionState，供其他模块查询

> **实现说明**：本节事件定义已在 `shared/event_types.py` 中完成，遵循项目现有的事件管理架构。

### 4.0.4 仿真数据单一数据源原则

> **⚠️ 核心架构约束**：GraphState 是仿真数据的唯一真相来源（Single Source of Truth）

#### 数据源层级定义

- [x] **唯一数据源**：`GraphState.sim_result_path` + `GraphState.last_metrics` 是所有仿真数据的权威来源
- [x] **数据流向**：仿真执行 → 写入文件 → GraphState 存路径 → 各消费方按需读取
- [x] **禁止行为**：任何模块不得绕过 GraphState 直接从文件系统读取仿真结果作为实时数据

#### 数据位置与用途

- [x] **GraphState.sim_result_path**：仿真结果文件路径（指针），工作流状态传递
- [x] **GraphState.last_metrics**：最新仿真指标摘要，用于 UI 显示和条件边判断
- [x] **GraphState.error_context**：错误信息传递，仿真成功后自动清除
- [x] **.circuit_ai/sim_results/ 目录**：仿真结果持久化存储，按需读取
- [x] **SimulationResult 数据类**：内存中的结构化数据，执行后写入文件

#### 数据刷新机制

- [x] **写入文件**：每次仿真执行后，结果写入 `.circuit_ai/sim_results/{uuid}.json`
- [x] **返回路径**：图节点返回 `{"sim_result_path": "...", "last_metrics": {...}}`
- [x] **错误处理**：仿真失败时，错误信息写入 `error_context` 字段

#### 各模块数据读取规范

- [x] **analysis_node**：调用 `SimulationService.load_sim_result(project_root, sim_result_path)` 读取
- [x] **diagnostics_collector**：从 GraphState 的 `error_context` 读取错误信息
- [x] **chart_generator**：调用 `SimulationService.load_sim_result()` 读取数据生成图表
- [x] **simulation_result_storage**：仿真结果已在文件中，无需额外归档

> **实现说明**：GraphState 已在 `application/graph/state.py` 中定义，包含 `sim_result_path`、`last_metrics`、`error_context` 等字段。

---

### 4.0.5 文件引用有效性校验（Dangling Pointer 防护）

> **⚠️ 问题场景**：GraphState 存储的是文件路径（指针），而非实际数据。当用户在文件系统中手动删除了被引用的文件（如 `sim_result_path` 指向的 `.circuit_ai/sim_results/run_001.json`），GraphState 中的路径就变成了悬空指针（Dangling Pointer）。

> **设计原则**：
> - 服务层防御性读取：返回结构化结果对象，明确区分"成功/文件缺失/解析错误"
> - UI 层感知状态：调用前校验路径有效性，发现缺失时显示占位图和操作按钮
> - 工作流层闭环：通过 GraphState 控制标志触发重新执行，不绕过 LangGraph

#### 4.0.5.1 `LoadResult` - 统一加载结果数据类

- [x] **文件路径**：`shared/models/load_result.py`
- [x] **职责**：定义文件加载操作的统一返回结构，替代返回空字典或抛异常的做法
- [x] **数据类定义**：
  - `LoadResult[T]` - 泛型加载结果
    - `success: bool` - 是否成功
    - `data: Optional[T]` - 加载的数据（成功时有值）
    - `error_code: Optional[LoadErrorCode]` - 错误码（失败时有值）
    - `error_message: Optional[str]` - 错误消息（失败时有值）
    - `file_path: str` - 尝试加载的文件路径
- [x] **错误码枚举** `LoadErrorCode`：
  - `FILE_MISSING` - 文件不存在（悬空指针场景）
  - `PARSE_ERROR` - 文件存在但解析失败
  - `PERMISSION_DENIED` - 文件存在但无读取权限
  - `PATH_EMPTY` - 路径为空字符串
  - `UNKNOWN_ERROR` - 未知错误
- [x] **工厂方法**：
  - `LoadResult.ok(data, file_path)` - 创建成功结果
  - `LoadResult.file_missing(file_path)` - 创建文件缺失结果
  - `LoadResult.path_empty()` - 创建路径为空结果
  - `LoadResult.parse_error(file_path, message)` - 创建解析错误结果
  - `LoadResult.permission_denied(file_path)` - 创建权限拒绝结果
  - `LoadResult.unknown_error(file_path, message)` - 创建未知错误结果
- [x] **辅助方法**：
  - `is_file_missing()` - 检查是否为文件缺失错误
  - `get_data_or_default(default)` - 获取数据，失败时返回默认值
- [x] **被调用方**：`SimulationService.load_sim_result()`、`DesignService.load_goals()`、所有 `load_*` 方法

#### 4.0.5.2 `FileReferenceValidator` - 文件引用校验器

- [x] **文件路径**：`shared/file_reference_validator.py`
- [x] **职责**：提供文件路径有效性校验的统一入口，供 UI 层和工作流层调用
- [x] **核心方法**：
  - `validate_path(project_root, relative_path) -> bool` - 校验单个路径是否有效
  - `validate_sim_result_path(project_root, sim_result_path) -> bool` - 校验仿真结果路径
  - `validate_design_goals_path(project_root, design_goals_path) -> bool` - 校验设计目标路径
  - `validate_circuit_file_path(project_root, circuit_file_path) -> bool` - 校验电路文件路径
  - `get_invalid_references(project_root, state) -> list[str]` - 批量校验 GraphState 中的所有路径，返回无效路径列表
  - `get_invalid_references_from_dict(project_root, state_dict) -> list[str]` - 从字典格式的状态中批量校验路径
- [x] **设计原则**：
  - 纯函数式：无状态，仅做路径存在性检查
  - 不修改 GraphState：仅返回校验结果，由调用方决定后续处理
- [x] **模块级单例**：`file_reference_validator` 便于直接导入使用
- [x] **被调用方**：UI 面板（显示前校验）、图节点（执行前校验）

#### 4.0.5.3 服务层防御性读取规范

> **`SimulationService.load_sim_result` 返回类型规范**

- [x] **返回类型**：`LoadResult[Dict[str, Any]]`
- [x] **行为规范**：
  - 路径为空：返回 `LoadResult.path_empty()`
  - 文件不存在：返回 `LoadResult.file_missing(path)`
  - 解析失败：返回 `LoadResult.parse_error(path, message)`
  - 成功：返回 `LoadResult.ok(data, path)`
- [x] **调用方适配**：所有调用 `load_sim_result` 的代码需检查 `result.success` 后再使用 `result.data`

#### 4.0.5.4 UI 层文件缺失处理规范

- [x] **校验时机**：UI 面板在显示仿真结果/图表前，先调用 `FileReferenceValidator.validate_sim_result_path()`
- [x] **缺失时显示**：
  - 显示占位图（灰色背景 + 文件缺失图标）
  - 显示提示文字："仿真结果文件已丢失"
  - 显示"重新仿真"按钮
- [x] **"重新仿真"按钮行为**：
  - **禁止**：直接调用 `SimulationService.run_simulation()`（绕过 LangGraph）
  - **正确做法**：通过 EventBus 发送 `EVENT_REQUEST_RESIMULATION` 事件，由 `SessionManager` 接收后设置 `GraphState.force_resimulate = True` 并触发工作流执行
- [x] **事件定义**：
  - `EVENT_REQUEST_RESIMULATION = "ui.request_resimulation"` - UI 请求重新仿真（已在 `shared/event_types.py` 中定义）

#### 4.0.5.5 工作流层状态校验与重新执行

> **GraphState 控制标志**

- [x] **字段定义**：`force_resimulate: bool = False`（已在 `application/graph/state.py` 中定义）
- [x] **字段用途**：当 UI 发现文件缺失并请求重新仿真时，设置此标志为 True
- [x] **router_node 条件边逻辑**：
  - 检查 `state.force_resimulate`，若为 True 则直接路由到 `simulation_node`
  - `simulation_node` 执行完成后，将 `force_resimulate` 重置为 False
- [x] **图节点前置校验**：
  - `analysis_node` 开头检查 `sim_result_path` 指向的文件是否存在
  - 若不存在，返回 `{"error_context": "SIM_RESULT_FILE_MISSING", "force_resimulate": True}`
  - 条件边检测到此状态后路由回 `simulation_node`

> **实现说明**：
> - `LoadResult` 和 `LoadErrorCode` 已在 `shared/models/load_result.py` 中完整实现
> - `FileReferenceValidator` 已在 `shared/file_reference_validator.py` 中完整实现
> - `GraphState.force_resimulate` 已在 `application/graph/state.py` 中定义
> - `EVENT_REQUEST_RESIMULATION` 已在 `shared/event_types.py` 中定义

---

### 4.1 仿真数据模型 (`domain/simulation/models/`)

> **设计原则**：使用 dataclass 定义标准化数据结构，确保类型安全，提供 IDE 自动补全支持

#### 4.1.1 `simulation_result.py` - 仿真结果数据类

- [ ] **文件路径**：`domain/simulation/models/simulation_result.py`
- [ ] **职责**：定义标准化的仿真结果数据结构，供所有仿真相关模块使用
- [ ] **数据类定义**：
  - `SimulationData` - 仿真数据容器
    - `frequency: Optional[np.ndarray]` - AC 分析频率点
    - `time: Optional[np.ndarray]` - 瞬态分析时间点
    - `signals: Dict[str, np.ndarray]` - 信号数据字典
  - `SimulationResult` - 标准化仿真结果
    - `executor: str` - 执行器名称
    - `file_path: str` - 仿真文件路径
    - `analysis_type: str` - 分析类型
    - `success: bool` - 是否成功
    - `data: Optional[SimulationData]` - 仿真数据
    - `metrics: Optional[Dict]` - 性能指标
    - `error: Optional[SimulationError]` - 错误信息
    - `raw_output: Optional[str]` - 原始输出
    - `timestamp: str` - ISO 格式时间戳（如 2024-12-20T14:30:22）
    - `duration_seconds: float` - 执行耗时
    - `version: int` - 版本号，每次仿真递增，用于验证数据新鲜度
- [ ] **核心方法**：
  - `to_dict()` - 序列化为字典
  - `from_dict(data)` - 从字典反序列化
  - `is_successful()` - 判断是否成功
  - `get_signal(name)` - 获取指定信号数据
  - `is_fresh(max_age_seconds)` - 检查数据是否在指定时间内（用于缓存验证）
- [ ] **被调用方**：所有仿真执行器、仿真服务、分析节点

#### 4.1.2 `simulation_error.py` - 仿真错误数据类

- [ ] **文件路径**：`domain/simulation/models/simulation_error.py`
- [ ] **职责**：定义标准化的仿真错误数据结构
- [ ] **错误类型枚举**：
  ```python
  class SimulationErrorType(Enum):
      SYNTAX_ERROR = "E001"
      MODEL_MISSING = "E002"
      NODE_FLOATING = "E003"
      CONVERGENCE_DC = "E004"
      CONVERGENCE_TRAN = "E005"
      TIMEOUT = "E006"
      MEMORY_OVERFLOW = "E007"
      NGSPICE_CRASH = "E008"
      FILE_ACCESS = "E009"
      PARAMETER_INVALID = "E010"
  ```
- [ ] **错误严重级别枚举**：
  ```python
  class ErrorSeverity(Enum):
      LOW = "low"
      MEDIUM = "medium"
      HIGH = "high"
      CRITICAL = "critical"
  ```
- [ ] **数据类定义**：
  - `SimulationError` - 仿真错误
    - `code: str` - 错误码
    - `type: SimulationErrorType` - 错误类型
    - `severity: ErrorSeverity` - 严重级别
    - `message: str` - 错误消息摘要
    - `file_path: Optional[str]` - 出错文件路径
    - `line_number: Optional[int]` - 出错行号
    - `context: Optional[str]` - 错误上下文代码
    - `details: Optional[Dict]` - 详细信息
    - `recovery_attempted: bool` - 是否已尝试恢复
    - `recovery_result: Optional[str]` - 恢复结果
    - `recovery_suggestion: Optional[str]` - 恢复建议
    - `raw_output: Optional[str]` - 原始输出
- [ ] **核心方法**：
  - `to_dict()` - 序列化为字典
  - `from_dict(data)` - 从字典反序列化
  - `is_recoverable()` - 判断是否可自动恢复
  - `get_user_message()` - 获取用户友好的错误消息
- [ ] **被调用方**：`SpiceExecutor`、`SimulationResult`、`FixErrorAction`、`SpiceErrorRecovery`

#### 4.1.3 `simulation_config.py` - 仿真配置数据类

- [ ] **文件路径**：`domain/simulation/models/simulation_config.py`
- [ ] **职责**：定义仿真配置的数据结构（纯数据类，不含业务逻辑）
- [ ] **设计原则**：配置数据类仅定义结构，配置的读写、校验、持久化由 `SimulationConfigService` 处理
- [ ] **数据类定义**：
  - `ACAnalysisConfig` - AC 分析配置
    - `start_freq: float` - 起始频率（Hz）
    - `stop_freq: float` - 终止频率（Hz）
    - `points_per_decade: int` - 每十倍频程点数
    - `sweep_type: str` - 扫描类型（dec/oct/lin）
  - `DCAnalysisConfig` - DC 分析配置
    - `source_name: str` - 扫描源名称
    - `start_value: float` - 起始值
    - `stop_value: float` - 终止值
    - `step: float` - 步进值
  - `TransientConfig` - 瞬态分析配置
    - `step_time: float` - 时间步长（秒）
    - `end_time: float` - 终止时间（秒）
    - `start_time: float` - 起始时间（秒）
    - `max_step: Optional[float]` - 最大步长
    - `use_initial_conditions: bool` - 是否使用初始条件
  - `NoiseConfig` - 噪声分析配置
    - `output_node: str` - 输出节点
    - `input_source: str` - 输入源
    - `start_freq: float` - 起始频率（Hz）
    - `stop_freq: float` - 终止频率（Hz）
  - `ConvergenceConfig` - 收敛参数配置（用户可调）
    - `gmin: float` - 最小电导（默认 1e-12）
    - `abstol: float` - 绝对电流容差（默认 1e-12）
    - `reltol: float` - 相对容差（默认 1e-3）
    - `vntol: float` - 电压容差（默认 1e-6）
    - `itl1: int` - DC 迭代限制（默认 100）
    - `itl4: int` - 瞬态迭代限制（默认 10）
  - `GlobalSimulationConfig` - 全局仿真配置
    - `timeout_seconds: int` - 超时时间（秒）
    - `temperature: float` - 仿真温度（摄氏度，默认 27）
    - `convergence: ConvergenceConfig` - 收敛参数
- [ ] **核心方法**：
  - `to_dict()` - 序列化为字典
  - `from_dict(data)` - 从字典反序列化
  - `get_default()` - 获取默认配置（类方法）
- [ ] **被调用方**：`SimulationConfigService`、各执行器

### 4.2 仿真执行器模块组 (`domain/simulation/executor/`)

> **三层分离架构设计**：
> 
> 本域采用策略模式 + 适配器模式实现三层分离，确保仿真执行、文件选择、工作流模式三个维度正交解耦：
> 
> **第一层：仿真执行器（SimulationExecutor）**
> - 定义统一的仿真执行接口
> - 不同仿真方式实现此接口（SpiceExecutor、PythonExecutor）
> - 符合开闭原则：新增仿真方式只需新增实现类并注册
> 
> **第二层：文件发现策略（FileDiscoveryStrategy）**
> - 自动扫描策略：扫描工作目录，分析文件引用关系
> - 手动选择策略：弹出对话框让用户选择
> - 与仿真执行方式无关
> 
> **组合自由度**：用户可自由组合两个维度，例如：
> - 自动扫描 + SPICE 仿真
> - 手动选择 + Python 仿真
> - 自动扫描 + Python 仿真

#### 4.2.1 `circuit_analyzer.py` - 电路文件分析器

> **初始化顺序**：无需显式初始化，作为工具类按需实例化
>
> **职责边界**：本模块专注于电路文件结构分析和主电路识别，底层的 `.include/.lib` 语句解析复用阶段2的 `include_parser.py`，避免重复实现

- [ ] **文件路径**：`domain/simulation/executor/circuit_analyzer.py`
- [ ] **职责**：分析工作区中的电路文件结构，识别主电路文件，提取文件引用关系
- [ ] **依赖**：`domain.dependency.scanner.include_parser` - 复用阶段2的语句解析器
- [ ] **核心功能**：
  - `scan_circuit_files(project_path)` - 扫描项目中所有 SPICE 文件
  - `parse_includes(file_path) -> list[IncludeInfo]` - 解析文件中的 `.include` 和 `.lib` 语句（委托给 `include_parser`）
  - `build_dependency_graph(project_path)` - 构建文件依赖关系图
  - `detect_main_circuit(project_path)` - 自动检测主电路文件
  - `get_circuit_type(file_path)` - 判断文件类型（主电路/子电路/参数文件）
- [ ] **`IncludeInfo` 数据结构**：
  - `line_number: int` - 语句所在行号
  - `statement_type: str` - 语句类型（"include" 或 "lib"）
  - `raw_path: str` - 原始路径字符串（保持用户书写格式）
  - `resolved_path: Optional[str]` - 解析后的相对路径（基于项目根目录）
  - `exists: bool` - 引用的文件是否存在
- [ ] **主电路识别策略（被引用分析法）**：
  - 扫描所有 `.cir`、`.sp`、`.spice` 文件
  - 解析每个文件的 `.include` 和 `.lib` 语句，提取被引用的文件路径
  - 构建引用关系图：`{file: [referenced_files]}`
  - 计算每个文件的被引用次数
  - 被引用次数为 0 且包含仿真控制语句的文件为主电路候选
  - 若只有一个候选，直接返回；若有多个，按优先级排序
- [ ] **主电路优先级规则**：
  - 名为 `main.cir` 的文件优先级最高
  - 包含 `.ac`、`.dc`、`.tran`、`.noise` 等仿真控制语句的文件优先
  - 文件大小较大的优先（通常主电路包含更多内容）
  - 最近修改时间较新的优先
- [ ] **文件类型判断规则**：
  - 主电路：不被其他文件引用，包含仿真控制语句
  - 子电路：仅包含 `.subckt ... .ends` 定义，被其他文件引用
  - 参数文件：仅包含 `.param` 语句，被其他文件引用
  - 库文件：包含多个 `.subckt` 或 `.model` 定义
- [ ] **返回数据结构**：返回字典格式，包含检测到的主电路路径（相对路径）、置信度（0-1）、其他候选主电路列表、子电路文件列表、参数文件列表和依赖关系图。
- [ ] **被调用方**：`simulation_service.py`（仿真服务）、`file_discovery.py`（文件发现策略）

#### 4.2.2 `simulation_executor.py` - 仿真执行器抽象基类

> **设计原则**：采用策略模式，将仿真执行方式与文件选择方式、工作流模式解耦，符合开闭原则

- [ ] **职责**：定义统一的仿真执行接口，管理不同仿真执行器的注册与调度
- [ ] **两层分离设计**：
  - **仿真执行方式**：由 `SimulationExecutor` 接口及其实现类控制（如 SPICE 仿真、Python 脚本仿真）
  - **文件选择方式**：由 `simulation_service.py` 控制（自动扫描 vs 手动选择）
  - 两者正交，互不影响，可自由组合
- [ ] **抽象基类 `SimulationExecutor`**：
  - `get_name()` - 返回执行器名称（如 "spice"、"python"）
  - `get_supported_extensions()` - 返回支持的文件扩展名列表
  - `can_handle(file_path)` - 判断是否能处理指定文件
  - `execute(file_path, analysis_config)` - 执行仿真，返回标准化结果
  - `validate_file(file_path)` - 校验文件格式是否有效
  - `get_available_analyses()` - 返回支持的分析类型列表
- [ ] **标准化仿真结果结构**：
  ```python
  {
    "executor": str,              # 执行器名称
    "file_path": str,             # 仿真文件路径
    "analysis_type": str,         # 分析类型
    "success": bool,              # 是否成功
    "data": {                     # 仿真数据（格式统一）
      "frequency": np.array,      # 频率点（AC分析）
      "time": np.array,           # 时间点（瞬态分析）
      "signals": dict,            # 信号数据 {"V(out)": np.array, ...}
    },
    "metrics": dict,              # 提取的性能指标（可选）
    "error": str,                 # 错误信息（失败时）
    "raw_output": str,            # 原始输出（调试用）
  }
  ```
- [ ] **被调用方**：`simulation_service.py`（仿真服务）

#### 4.2.3 `executor_registry.py` - 执行器注册表

> **初始化顺序**：Phase 3.10，依赖 Logger，注册到 ServiceLocator

- [ ] **职责**：管理所有仿真执行器的注册、查询和调度
- [ ] **核心功能**：
  - `register(executor)` - 注册仿真执行器实例
  - `unregister(name)` - 注销指定执行器
  - `get_executor(name)` - 按名称获取执行器
  - `get_executor_for_file(file_path)` - 根据文件扩展名自动选择执行器
  - `get_all_executors()` - 获取所有已注册执行器
  - `get_all_supported_extensions()` - 获取所有支持的文件扩展名
- [ ] **执行器选择策略**：
  - 根据文件扩展名匹配执行器
  - 多个执行器支持同一扩展名时，按注册顺序优先
  - 无匹配执行器时返回 None，由调用方处理
- [ ] **内置执行器注册**：
  - 启动时自动注册 `SpiceExecutor`（处理 .cir/.sp/.spice/.net/.ckt）
  - 启动时自动注册 `PythonExecutor`（处理 .py）
- [ ] **扩展机制**：
  - 新增仿真方式只需实现 `SimulationExecutor` 接口并注册
  - 无需修改现有代码，符合开闭原则
- [ ] **被调用方**：`simulation_service.py`（仿真服务）

#### 4.2.4 `ngspice_config.py` - ngspice 路径配置（已实现）

> **设计原则**：将 ngspice 路径配置逻辑从 spice_executor 中分离，遵循单一职责原则
>
> **⚠️ 关键约束**：此模块必须在任何 PySpice 导入之前执行，否则 PySpice 会使用默认路径导致加载失败

- [x] **文件路径**：`infrastructure/utils/ngspice_config.py`（已实现）
- [x] **职责**：管理 ngspice 二进制和模型库的路径配置，处理跨平台差异
- [x] **核心功能**：
  - `configure_ngspice() -> bool` - 配置 ngspice 路径（必须在导入 PySpice 之前调用）
  - `get_ngspice_path() -> Path` - 获取 ngspice 基础目录路径
  - `get_ngspice_lib_path() -> Path` - 获取 lib/ngspice 目录路径（codemodel 文件）
  - `get_ngspice_models_path() -> Path` - 获取模型库基础路径（cmp/sub/custom）
  - `get_ngspice_scripts_path() -> Path` - 获取 spinit 脚本路径
  - `is_ngspice_available() -> bool` - 检查 ngspice 是否可用
  - `get_configuration_error() -> str` - 获取配置错误信息
  - `get_ngspice_info() -> dict` - 获取配置详细信息（调试用）
- [x] **路径解析逻辑**：
  - 开发环境：从 `vendor/ngspice/{platform}/` 加载
  - 打包环境：从 `sys._MEIPASS` 临时目录加载
  - 系统安装：作为回退方案，从系统常见路径查找
- [x] **环境变量设置**：
  - `PATH` - 添加 DLL 目录（Windows）
  - `SPICE_LIB_DIR` - codemodel 和 OSDI 模型路径
  - `SPICE_SCRIPTS` - spinit 脚本路径
  - `NGSPICE_LIBRARY_PATH` - ngspice 共享库路径
- [x] **调用时机**：在 `main.py` 的最开始调用，位于所有其他导入之前
- [x] **目录结构**（以 Windows 为例）：
  ```
  vendor/ngspice/
  ├── LICENSE                           # ngspice 许可证
  ├── win64/
  │   └── Spice64_dll/
  │       ├── dll-vs/                   # DLL 文件
  │       │   ├── ngspice.dll
  │       │   └── libomp140.x86_64.dll
  │       ├── lib/ngspice/              # codemodel 和 OSDI 模型
  │       │   ├── analog.cm
  │       │   ├── digital.cm
  │       │   └── ...
  │       └── share/ngspice/
  │           ├── models/               # SPICE 模型库
  │           │   ├── cmp/              # 基础器件模型
  │           │   ├── sub/              # 子电路定义
  │           │   └── custom/           # 用户自定义模型
  │           └── scripts/
  │               └── spinit            # 初始化脚本
  ├── linux64/
  │   └── .gitkeep
  └── macos/
      └── .gitkeep
  ```
- [ ] **版本要求**：ngspice 40 或更高版本
- [ ] **许可证**：ngspice 使用 BSD-3-Clause 许可证，允许二进制分发
#### 4.2.5 `spice_executor.py` - SPICE仿真执行器

> **初始化顺序**：无需显式初始化，作为工具类按需实例化，依赖 `ngspice_config`（路径配置）、PySpice 库
> 
> **⚠️ 执行模式说明**：PySpice 通过 `NgSpiceShared` 共享库模式调用 ngspice，ngspice 在**同一进程内**执行，不需要启动独立子进程。这种模式性能更高，但需要确保 ngspice 共享库路径正确配置。
> 
> **职责精简说明**：根据单一职责原则，ngspice 路径配置委托给 `ngspice_config`，错误解析作为执行器内部职责（`_parse_exception` 方法），本模块专注于仿真执行核心逻辑
>
> **⚠️ 路径解析策略**：采用工作目录切换方案，利用 ngspice 原生的相对路径解析能力，无需生成临时文件

- [x] **文件路径**：`domain/simulation/executor/spice_executor.py`
- [x] **职责**：实现 `SimulationExecutor` 接口，封装 PySpice 库执行 SPICE 电路仿真
- [x] **继承**：`SimulationExecutor`（抽象基类）
- [x] **支持的扩展名**：`.cir`、`.sp`、`.spice`、`.net`、`.ckt`
- [x] **核心功能**：
  - `execute(file_path, analysis_config) -> SimulationResult` - 执行仿真（接口方法）
  - `load_circuit(spice_file_path)` - 加载SPICE网表文件
  - `run_ac_analysis(start_freq, stop_freq, points)` - 交流小信号分析
  - `run_dc_analysis(source, start, stop, step)` - 直流扫描分析
  - `run_transient_analysis(step_time, end_time)` - 瞬态分析
  - `run_noise_analysis(output_node, input_source, freq_range)` - 噪声分析
  - `get_node_voltage(node_name)` - 获取节点电压
  - `get_branch_current(element_name)` - 获取支路电流
- [x] **仿真执行流程**：
  1. 校验文件存在性和扩展名（优先于 ngspice 检查）
  2. 检查 `ngspice_config.is_ngspice_available()` 确保 ngspice 已配置
  3. **切换工作目录到电路文件所在目录**（关键步骤，确保相对路径正确解析）
  4. 加载电路文件内容
  5. 使用 PySpice 的 SpiceParser 解析网表
  6. 根据分析类型执行仿真（AC/DC/瞬态/噪声/工作点）
  7. 提取仿真数据到标准化 SimulationData 结构
  8. 如果仿真失败，解析异常并返回结构化错误
  9. **恢复原工作目录**（使用 try-finally 确保恢复）
  10. 返回 SimulationResult
- [x] **依赖**：
  - `PySpice` 库 - SPICE 仿真引擎封装（通过 NgSpiceShared 共享库模式调用 ngspice）
  - `infrastructure.utils.ngspice_config` - ngspice 路径配置（已实现）
- [x] **元器件模型集成**（阶段十实现，此处预留接口）：
  - `check_required_models(circuit_file)` - 检查电路所需的 SPICE 模型
  - `_resolve_model_path(model_name)` - 解析模型文件路径
- [x] **被调用方**：`executor_registry.py`（执行器注册表）

##### 4.2.5.1 工作目录切换策略

> **设计原理**：ngspice 在解析 `.include` 和 `.lib` 语句时，会基于当前工作目录解析相对路径。通过在仿真执行前切换到电路文件所在目录，可以让 ngspice 自动正确解析所有相对路径引用，无需生成临时文件或修改网表内容。

- [x] **核心方法**：
  - `_execute_with_working_directory(file_path, callback)` - 在指定工作目录下执行回调
- [x] **实现要点**：
  - 使用 `os.getcwd()` 保存当前工作目录
  - 使用 `os.chdir(circuit_dir)` 切换到电路文件所在目录
  - 使用 `try-finally` 确保无论成功或失败都恢复原工作目录
  - 线程安全考虑：工作目录是进程级状态，并发仿真需要加锁或使用进程隔离
- [x] **优势**：
  - 零代码侵入，利用 ngspice 原生能力
  - 无需临时文件管理
  - 无需路径映射（错误信息直接对应原始文件）
  - 跨平台兼容（ngspice 在所有平台都支持相对路径）
- [x] **限制**：
  - 工作目录是进程级状态，不支持同一进程内并发仿真
  - 如需并发，应使用 `subprocess` 在独立进程中执行
- [ ] **并发仿真支持**（可选扩展）：
  - 当检测到并发仿真请求时，自动切换到 subprocess 模式
  - subprocess 模式下，每个仿真在独立进程中执行，工作目录互不影响

##### 4.2.5.2 错误解析增强

> **设计原则**：错误解析是仿真执行的内部职责，与执行逻辑紧密耦合，不单独分离为独立模块。在 PySpice 共享库模式下，错误信息来自 Python 异常而非原始 ngspice 输出，内聚处理更合理。

- [x] **核心方法**：`_parse_exception(exception, file_path) -> SimulationError`
- [x] **职责**：将 Python 异常转换为结构化的 `SimulationError` 对象
- [ ] **增强功能**：
  - `_extract_line_number(error_msg)` - 从异常消息中提取行号（如果包含）
  - `_extract_missing_models(error_msg)` - 从异常消息中提取缺失模型名称
  - `_extract_floating_nodes(error_msg)` - 从异常消息中提取浮空节点名称
- [x] **错误分类规则**：
  - 语法错误：匹配 "syntax"、"parse" 关键词
  - 模型缺失：匹配 "model"、"not found"、"unknown" 关键词
  - 节点浮空：匹配 "floating"、"no dc path" 关键词
  - 收敛失败：匹配 "convergence"、"no convergence" 关键词
  - 超时：匹配 "timeout" 关键词
- [x] **返回值**：`SimulationError` 对象，包含错误码、类型、严重级别、恢复建议等
- [x] **设计决策说明**：
  - 不创建独立的 `SpiceErrorParser` 模块
  - 原因：PySpice 共享库模式下，错误信息已被封装为 Python 异常，无需解析原始 ngspice stdout/stderr
  - 如未来需要 subprocess 模式（独立进程调用 ngspice CLI），可在该模式内部实现文本解析

#### 4.2.6 错误处理设计说明（已完成）

> **设计原则**：简化错误处理流程，用户主导问题解决，避免黑盒自动恢复

- [x] **错误处理策略：**
  - **立即失败，清晰反馈**：仿真错误立即返回，不进行自动重试
  - **用户友好的错误提示**：`SimulationError` 对象包含详细的错误信息和修改建议
  - **透明的参数调整**：用户通过 UI 手动调整仿真配置，理解每个参数的作用
  - **避免过度设计**：不引入复杂的自动恢复机制，降低维护成本

- [x] **错误解析实现：**
  - `spice_executor._parse_exception()` 方法负责将 ngspice 异常转换为结构化的 `SimulationError`
  - 每个错误类型包含：
    - 错误码和类型（如 E004 - CONVERGENCE_DC）
    - 严重级别（LOW/MEDIUM/HIGH/CRITICAL）
    - 用户友好的错误消息
    - 具体的修改建议（`recovery_suggestion` 字段）
    - 出错位置信息（文件路径、行号）

- [x] **用户工作流：**
  1. 用户触发仿真
  2. 仿真失败，UI 显示错误详情和建议
  3. 用户根据建议修改电路或调整配置
  4. 用户手动重新仿真

- [x] **配置调整支持：**
  - 通过 `SimulationConfigService` 提供配置编辑界面
  - 用户可手动调整收敛参数（gmin、reltol、itl1 等）
  - 配置保存到项目，下次仿真自动使用

- [x] **设计优势：**
  - 简化代码，降低维护成本
  - 用户理解问题根源，而非依赖黑盒自动修复
  - 避免自动重试浪费时间
  - 提高用户对仿真工具的掌控感

#### 4.2.7 `python_executor.py` - Python脚本仿真执行器

> **初始化顺序**：无需显式初始化，作为工具类按需实例化
>
> **⚠️ 设计简化说明**：本模块仅提供基础进程隔离，不实现完整沙箱。用户应仅执行可信脚本。
>
> **⚠️ 进程管理说明**：直接使用 Python 标准库 `subprocess` 模块管理子进程，不依赖额外的进程管理器。

- [x] **文件路径**：`domain/simulation/executor/python_executor.py`
- [x] **职责**：实现 `SimulationExecutor` 接口，在隔离子进程中执行用户自定义的 Python 仿真脚本
- [x] **继承**：`SimulationExecutor`（抽象基类）
- [x] **支持的扩展名**：`.py`
- [x] **适用场景**：
  - 用户需要自定义仿真逻辑（如参数扫描、蒙特卡洛分析）
  - 需要调用其他仿真工具（如 LTspice、Spectre）的 Python 封装
  - 需要进行复杂的数据后处理
- [x] **核心功能**：
  - `validate_file(file_path)` - 校验 Python 脚本格式，检查是否定义了符合约定的入口函数
  - `execute(file_path, analysis_config)` - 执行 Python 脚本并返回标准化结果
  - `_run_in_subprocess(file_path, config)` - 在子进程中执行脚本，实现进程隔离
  - `_parse_output(stdout, stderr)` - 解析脚本输出为标准化仿真结果
- [x] **脚本约定**：
  - 脚本必须定义 `run_simulation(config: dict) -> dict` 入口函数
  - 入口函数接收配置字典作为参数，返回符合标准化仿真结果结构的字典（见 4.2.2 节）
  - 返回字典需包含 `success` 布尔字段表示执行状态，`data` 字段存放仿真数据，`metrics` 字段存放性能指标
  - 脚本通过标准输出（stdout）以 JSON 格式输出结果
- [x] **进程管理实现**：
  - **进程启动**：使用 Python 标准库 `subprocess.run()` 启动独立子进程执行脚本
  - **超时控制**：通过 subprocess 的 timeout 参数设置执行时限，默认 600 秒
  - **进程终止**：超时后自动终止子进程并回收资源
  - **数据传递**：通过命令行参数传入配置，通过 stdout 获取 JSON 格式的执行结果
- [x] **基础隔离机制**：
  - **进程隔离**：脚本在独立子进程中执行，子进程崩溃不影响主程序稳定性，通过标准流进行数据交换
  - **资源限制**：仅实现执行超时限制，超限时自动终止子进程
  - **工作目录限制**：子进程工作目录设置为项目根目录，脚本可访问项目目录及其子目录
- [x] **安全声明**：
  - 本模块不提供完整的安全沙箱，不限制模块导入、文件系统访问、网络访问
  - 用户应仅执行可信的脚本
  - UI 层需明确提示用户相关安全风险
- [x] **输出解析**：
  - 执行器解析 stdout 中的最后一个有效 JSON 对象作为执行结果
  - stderr 内容记录到日志用于调试，不作为结果解析
- [x] **错误处理**：
  - 脚本语法错误 → 捕获异常并返回 `SimulationError`
  - 执行超时 → 终止子进程并返回超时错误
  - 输出格式错误 → 返回 JSON 解析错误
  - 子进程崩溃 → 返回进程异常退出错误
- [x] **被调用方**：`executor_registry.py`（执行器注册表）

#### 4.2.8 `file_discovery.py` - 文件发现策略

> **设计原则**：采用策略模式，将文件发现方式与仿真执行方式解耦
>
> **命名简化**：使用简洁的类名，避免冗余的 "Strategy" 后缀

- [ ] **文件路径**：`domain/simulation/executor/file_discovery.py`
- [ ] **职责**：定义文件发现的统一接口，支持自动扫描和手动选择两种策略
- [ ] **抽象基类 `FileDiscovery`**：
  - `discover(project_path) -> DiscoveryResult` - 发现可仿真文件
  - `get_name() -> str` - 返回策略名称
- [ ] **`DiscoveryResult` 数据结构**：
  - `files: list[Path]` - 发现的文件列表
  - `main_circuit_candidate: Optional[Path]` - 主电路候选（自动扫描时）
  - `confidence: float` - 置信度（0-1，自动扫描时）
  - `method: str` - 发现方法（"auto_scan" 或 "manual_select"）
- [ ] **`AutoScanDiscovery` - 自动扫描策略**：
  - 扫描工作目录中所有支持的文件类型
  - 从 `executor_registry` 获取所有支持的扩展名
  - 调用 `circuit_analyzer.detect_main_circuit()` 分析文件引用关系
  - 返回主电路候选及其置信度
  - 若检测到多个候选，返回置信度最高的一个
- [ ] **`ManualSelectDiscovery` - 手动选择策略**：
  - 弹出文件选择对话框（使用 Qt 的 `QFileDialog`）
  - 过滤器显示所有支持的文件类型
  - 用户选择后返回选中的文件
  - 置信度固定为 1.0（用户明确选择）
- [ ] **策略工厂**：
  ```python
  class FileDiscoveryFactory:
      @staticmethod
      def create(mode: str, executor_registry) -> FileDiscovery:
          if mode == "auto":
              return AutoScanDiscovery(executor_registry)
          elif mode == "manual":
              return ManualSelectDiscovery(executor_registry)
          else:
              raise ValueError(f"Unknown discovery mode: {mode}")
  ```
- [ ] **与执行器注册表的协作**：
  - `AutoScanDiscovery` 调用 `executor_registry.get_all_supported_extensions()` 获取扫描范围
  - 确保新增执行器后，自动扫描能发现对应类型的文件
  - 手动选择对话框的过滤器也基于注册表动态生成
- [ ] **被调用方**：`simulation_service.py`（仿真服务）

### 4.3 仿真服务模块组 (`domain/simulation/service/`)

> **初始化顺序**：Phase 3.11，依赖 ExecutorRegistry、EventBus、Logger，注册到 ServiceLocator

> **两层分离设计**：本服务是两层分离架构的协调中心
> - **仿真执行方式**：通过 `executor_registry` 获取合适的执行器
> - **文件选择方式**：通过 `FileDiscoveryStrategy` 实现自动扫描或手动选择
> - 两者正交，互不影响，可自由组合

> **模块拆分说明**：为遵循单一职责原则，将仿真服务拆分为以下子模块：

- [ ] **目录结构**：
  ```
  domain/simulation/service/
  ├── __init__.py
  ├── simulation_service.py        # 门面类，协调各子模块
  ├── basic_simulation_runner.py   # 基础仿真执行
  ├── advanced_simulation_runner.py # 高级仿真执行
  ├── main_circuit_detector.py     # 主电路检测逻辑
  ├── simulation_state_manager.py  # 仿真状态管理
  ├── simulation_config_service.py # 配置服务（用户手动设置）
  ├── tuning_service.py            # 快速调参服务
  └── simulation_control_service.py # 仿真进度控制
  ```

#### 4.3.1 `simulation_config_service.py` - 仿真配置服务

> **⚠️ 核心设计原则**：仿真参数由用户通过 UI 手动设置，软件不内置硬编码的预设配置

- [ ] **文件路径**：`domain/simulation/service/simulation_config_service.py`
- [ ] **职责**：管理仿真配置的读取、校验、持久化，提供配置编辑的数据支持
- [ ] **设计原则**：
  - 配置由用户通过 UI 对话框手动设置
  - 软件仅提供合理的默认值作为初始状态
  - 不提供"快速/标准/精确"等预设，避免用户依赖黑盒配置
  - 所有参数对用户透明可见、可编辑

##### 核心功能

- [ ] **配置读取**：
  - `load_config(project_root) -> GlobalSimulationConfig` - 加载项目配置
  - `get_analysis_config(analysis_type) -> AnalysisConfig` - 获取指定分析类型配置
- [ ] **配置保存**：
  - `save_config(project_root, config)` - 保存配置到项目
  - `save_analysis_config(analysis_type, config)` - 保存单个分析配置
- [ ] **配置校验**：
  - `validate_config(config) -> ValidationResult` - 校验配置有效性
  - `get_validation_errors(config) -> list[str]` - 获取校验错误列表
- [ ] **默认值管理**：
  - `get_default_config() -> GlobalSimulationConfig` - 获取默认配置（仅作为初始值）
  - `reset_to_default(project_root)` - 重置为默认配置

##### 配置存储

- [ ] **项目级配置文件**：`.circuit_ai/simulation_config.json`
- [ ] **配置文件结构**：
  ```json
  {
    "version": "1.0",
    "global": {
      "timeout_seconds": 300,
      "temperature": 27.0,
      "convergence": {
        "gmin": 1e-12,
        "abstol": 1e-12,
        "reltol": 1e-3,
        "vntol": 1e-6,
        "itl1": 100,
        "itl4": 10
      }
    },
    "ac": {
      "start_freq": 1.0,
      "stop_freq": 1e9,
      "points_per_decade": 20,
      "sweep_type": "dec"
    },
    "dc": {
      "source_name": "",
      "start_value": 0.0,
      "stop_value": 5.0,
      "step": 0.1
    },
    "transient": {
      "step_time": 1e-6,
      "end_time": 1e-3,
      "start_time": 0.0,
      "max_step": null,
      "use_initial_conditions": false
    },
    "noise": {
      "output_node": "",
      "input_source": "",
      "start_freq": 1.0,
      "stop_freq": 1e6
    }
  }
  ```

##### 配置校验规则

- [ ] **频率参数**：`start_freq > 0`，`stop_freq > start_freq`
- [ ] **时间参数**：`step_time > 0`，`end_time > start_time`
- [ ] **收敛参数**：`gmin > 0`，`abstol > 0`，`reltol` 在 (0, 1) 范围内
- [ ] **超时参数**：`timeout_seconds > 0`
- [ ] **校验失败处理**：返回详细错误信息，UI 层显示给用户

##### 事件发布

- [ ] `EVENT_SIM_CONFIG_CHANGED` - 配置变更时发布，携带变更的配置项
- [ ] `EVENT_SIM_CONFIG_VALIDATION_FAILED` - 配置校验失败时发布

- [ ] **被调用方**：`SimulationService`、`SimulationConfigDialog`（UI）、各执行器

#### 4.3.2 `simulation_service.py` - 仿真服务门面类

> **职责精简说明**：根据单一职责原则，门面类仅负责协调和委托，具体功能由子服务实现

- [ ] **文件路径**：`domain/simulation/service/simulation_service.py`
- [ ] **职责**：作为门面类协调各子模块，提供统一的仿真入口
- [ ] **基础仿真入口**（委托给 `BasicSimulationRunner`）：
  - `run_with_auto_detect(analysis_config)` - 自动扫描策略执行仿真
  - `run_with_file(file_path, analysis_config)` - 指定文件执行仿真
  - `run_with_manual_select(analysis_config)` - 手动选择策略执行仿真
- [ ] **高级仿真入口**（委托给 `AdvancedSimulationRunner`）：
  - `run_pvt_analysis(...)` - PVT 角点仿真
  - `run_monte_carlo(...)` - 蒙特卡洛分析
  - `run_parametric_sweep(...)` - 参数扫描
  - `run_worst_case(...)` - 最坏情况分析
  - `run_sensitivity(...)` - 敏感度分析
- [ ] **快速调参入口**（委托给 `TuningService`）：
  - `get_tunable_parameters(file_path)` - 提取可调参数
  - `run_tuning_simulation(...)` - 调参仿真
- [ ] **进度控制入口**（委托给 `SimulationControlService`）：
  - `pause_simulation()` / `resume_simulation()` - 暂停/恢复
  - `get_simulation_progress()` - 获取进度
- [ ] **其他功能**：
  - `initialize(project_path)` - 初始化仿真服务
  - `get_simulatable_files()` - 获取可仿真文件列表
  - `get_main_circuit_candidates()` - 委托给 `MainCircuitDetector`
- [ ] **依赖的子模块**：
  - `BasicSimulationRunner` - 基础仿真执行（详见 4.3.5）
  - `AdvancedSimulationRunner` - 高级仿真执行（详见 4.3.6）
  - `TuningService` - 快速调参（详见 4.3.7）
  - `SimulationControlService` - 进度控制（详见 4.3.8）
  - `MainCircuitDetector` - 主电路检测（详见 4.3.3）
  - `SimulationStateManager` - 状态管理（详见 4.3.4）
- [ ] **被调用方**：`simulation_worker.py`、`main_window.py`、`tool_executor.py`

#### 4.3.3 `main_circuit_detector.py` - 主电路检测器

- [ ] **文件路径**：`domain/simulation/service/main_circuit_detector.py`
- [ ] **职责**：专注于主电路的检测、分析和事件通知
- [ ] **核心功能**：
  - `detect_main_circuit(project_path)` - 检测主电路，返回候选列表
  - `refresh_analysis(project_path)` - 刷新文件分析结果
  - `get_candidates()` - 获取当前检测到的主电路候选列表
  - `on_file_changed(file_path)` - 文件变更时重新分析
- [ ] **主电路检测机制**：
  - **自动检测**：调用 `circuit_analyzer.detect_main_circuit()` 使用被引用分析法
  - **检测结果**：返回候选主电路列表（可能为 0、1 或多个）
  - **唯一主电路**：检测到 1 个时直接使用
  - **多个主电路**：检测到 2 个及以上时，返回候选列表供 UI 层处理
- [ ] **事件订阅**：
  - 订阅 `EVENT_STATE_PROJECT_OPENED` 事件，项目打开后自动执行被引用分析
  - 订阅 `EVENT_FILE_CHANGED` 事件，SPICE 文件变更时重新分析
- [ ] **事件发布**：
  - `EVENT_MAIN_CIRCUIT_CHANGED` - 主电路变更时发布
  - `EVENT_CIRCUIT_ANALYSIS_COMPLETE` - 电路分析完成时发布
  - `EVENT_MAIN_CIRCUIT_DETECTED` - 主电路检测完成时发布，携带候选列表
- [ ] **被调用方**：`simulation_service.py`（门面类）

#### 4.3.4 `simulation_state_manager.py` - 仿真状态管理器

- [ ] **文件路径**：`domain/simulation/service/simulation_state_manager.py`
- [ ] **职责**：专注于仿真相关状态的管理和持久化
- [ ] **核心功能**：
  - `get_circuit_analysis_result()` - 获取最近一次电路分析结果
  - `set_circuit_analysis_result(result)` - 设置电路分析结果
  - `get_main_circuit_candidates()` - 获取主电路候选列表
  - `set_main_circuit_candidates(candidates)` - 设置主电路候选列表
  - `get_last_simulation_file()` - 获取上次仿真使用的文件
  - `set_last_simulation_file(file_path)` - 设置上次仿真文件
  - `clear()` - 清空所有状态（项目关闭时）
- [ ] **状态字段**：
  - `circuit_analysis_result` - 最近一次电路分析结果
  - `main_circuit_candidates` - 当前检测到的主电路候选列表
  - `last_simulation_file` - 上次仿真使用的文件
- [ ] **事件订阅**：
  - 订阅 `EVENT_STATE_PROJECT_CLOSED` 事件，清空状态
- [ ] **被调用方**：`simulation_service.py`（门面类）、`main_circuit_detector.py`

#### 4.3.5 `basic_simulation_runner.py` - 基础仿真执行器（新增）

> **设计原则**：将基础仿真执行逻辑从 simulation_service 中分离

- [ ] **文件路径**：`domain/simulation/service/basic_simulation_runner.py`
- [ ] **职责**：执行基础仿真任务，包括自动检测、指定文件、手动选择三种模式
- [ ] **核心功能**：
  - `run_with_auto_detect(analysis_config) -> SimulationResult` - 自动检测主电路并执行仿真
  - `run_with_file(file_path, analysis_config) -> SimulationResult` - 使用指定文件执行仿真
  - `run_with_manual_select(analysis_config) -> SimulationResult` - 手动选择文件后执行仿真
- [ ] **执行流程**：
  - 根据文件扩展名从 `executor_registry` 获取对应执行器
  - 调用执行器的 `execute()` 方法执行仿真
  - 处理执行结果，转换为标准化 `SimulationResult`
  - 发布仿真完成事件
- [ ] **被调用方**：`simulation_service.py`（门面类）

#### 4.3.6 `advanced_simulation_runner.py` - 高级仿真执行器（新增）

> **设计原则**：将高级仿真执行逻辑从 simulation_service 中分离

- [ ] **文件路径**：`domain/simulation/service/advanced_simulation_runner.py`
- [ ] **职责**：执行高级仿真任务，包括 PVT、蒙特卡洛、参数扫描等
- [ ] **核心功能**：
  - `run_pvt_analysis(file_path, analysis_config, corners)` - 执行 PVT 角点仿真
  - `run_monte_carlo(file_path, analysis_config, num_runs, variations)` - 执行蒙特卡洛分析
  - `run_parametric_sweep(file_path, analysis_config, sweep_config)` - 执行参数扫描
  - `run_worst_case(file_path, analysis_config, tolerances, method)` - 执行最坏情况分析
  - `run_sensitivity(file_path, analysis_config, params, metric)` - 执行敏感度分析
- [ ] **与分析模块的协作**：
  - 委托给 `domain/simulation/analysis/` 下的具体分析模块
  - 负责协调多次仿真执行和结果汇总
  - 发布进度事件（如 `PVT_CORNER_COMPLETE`）
- [ ] **被调用方**：`simulation_service.py`（门面类）

#### 4.3.7 `tuning_service.py` - 快速调参服务（新增）

> **设计参考**：借鉴 LTspice 的实时参数调整（Tuning）功能

- [ ] **文件路径**：`domain/simulation/service/tuning_service.py`
- [ ] **职责**：提供快速调参功能，支持参数提取、单参数调整、批量调整
- [ ] **核心功能**：
  - `get_tunable_parameters(file_path) -> List[TunableParameter]` - 提取可调参数列表
  - `run_tuning_simulation(file_path, param_name, new_value) -> SimulationResult` - 单参数调整仿真
  - `batch_tuning_simulation(file_path, param_changes) -> SimulationResult` - 批量参数调整仿真
  - `apply_parameter_change(file_path, param_name, new_value)` - 应用参数修改到文件
  - `revert_parameter_change(file_path, param_name)` - 撤销参数修改
- [ ] **参数提取规则**：
  - 从 `.param` 语句中提取参数名和当前值
  - 从电阻、电容、电感元件中提取数值
  - 自动识别参数单位和合理范围
- [ ] **数据类定义**：
  - `TunableParameter` - 可调参数
    - `name: str` - 参数名
    - `current_value: float` - 当前值
    - `unit: str` - 单位
    - `min_value: float` - 建议最小值
    - `max_value: float` - 建议最大值
    - `component_type: str` - 元件类型（param/resistor/capacitor 等）
- [ ] **被调用方**：`simulation_service.py`（门面类）、`tuning_panel.py`（UI）

#### 4.3.8 `simulation_control_service.py` - 仿真进度控制服务（新增）

> **设计参考**：借鉴 LTspice 的仿真控制功能

- [ ] **文件路径**：`domain/simulation/service/simulation_control_service.py`
- [ ] **职责**：提供仿真进度控制功能，支持暂停、恢复、断点
- [ ] **核心功能**：
  - `pause_simulation()` - 暂停当前仿真
  - `resume_simulation()` - 恢复暂停的仿真
  - `cancel_simulation()` - 取消当前仿真
  - `get_simulation_progress() -> SimulationProgress` - 获取当前仿真进度
  - `set_breakpoint(condition: str)` - 设置条件断点
  - `clear_breakpoint()` - 清除断点
  - `is_breakpoint_hit() -> bool` - 检查是否触发断点
- [ ] **进度数据类**：
  - `SimulationProgress` - 仿真进度
    - `status: str` - 状态（running/paused/completed/cancelled）
    - `percent: float` - 完成百分比
    - `current_point: str` - 当前仿真点（时间或频率）
    - `estimated_remaining: float` - 预计剩余时间（秒）
    - `message: str` - 状态消息
- [ ] **断点条件语法**：
  - 支持简单条件：`V(out) > 2.0`
  - 支持复合条件：`V(out) > 2.0 AND time > 1e-6`
  - 条件解析使用简单的表达式解析器
- [ ] **与进程监控的协作**：
  - 通过 `ProcessMonitor` 发送暂停/恢复信号
  - 定期轮询仿真输出检查断点条件
- [ ] **被调用方**：`simulation_service.py`（门面类）、`main_window.py`（暂停按钮）

### 4.4 高级仿真分析模块组 (`domain/simulation/analysis/`)

> **设计说明**：为支持专业级电路设计验证，将高级仿真分析功能独立为模块组，包括 PVT 角点仿真、蒙特卡洛分析、参数扫描等。

- [ ] **目录结构**：
  ```
  domain/simulation/analysis/
  ├── __init__.py
  ├── pvt_analysis.py           # PVT 角点仿真
  ├── monte_carlo_analysis.py   # 蒙特卡洛分析
  ├── parametric_sweep.py       # 参数扫描
  ├── worst_case_analysis.py    # 最坏情况分析
  ├── sensitivity_analysis.py   # 敏感度分析
  ├── post_processor.py         # 仿真后处理
  └── topology_recognizer.py    # 电路拓扑识别
  ```

#### 4.4.1 `pvt_analysis.py` - PVT 角点仿真

> **初始化顺序**：无需显式初始化，作为工具类按需实例化

- [ ] **职责**：执行工艺-电压-温度（Process-Voltage-Temperature）角点仿真，验证电路在极端条件下的性能
- [ ] **核心功能**：
  - `run_pvt_corners(circuit_file, analysis_config, corners)` - 执行多角点仿真
  - `get_default_corners()` - 获取默认角点配置
  - `add_custom_corner(name, process, voltage, temperature)` - 添加自定义角点
  - `generate_pvt_report(results)` - 生成 PVT 分析报告
  - `find_worst_case(results, metric)` - 找出指定指标的最差角点
- [ ] **默认角点配置**：
  - TT（Typical-Typical）：典型工艺、标称电压、室温（25°C）
  - FF（Fast-Fast）：快速工艺、高电压（+10%）、低温（-40°C）
  - SS（Slow-Slow）：慢速工艺、低电压（-10%）、高温（85°C）
  - FS（Fast-Slow）：NMOS快/PMOS慢、标称电压、室温
  - SF（Slow-Fast）：NMOS慢/PMOS快、标称电压、室温
- [ ] **工艺角点实现方式**：
  - 通过修改 `.lib` 文件中的模型参数实现工艺变化
  - 支持用户指定自定义工艺库文件
  - 若无工艺库，通过调整关键器件参数（如 Vth、mobility）模拟工艺偏差
- [ ] **结果汇总结构**：包含各角点的仿真结果、各指标的最差角点标识、通过/失败状态，以及详细的角点对比数据
- [ ] **与设计目标集成**：
  - 检查所有角点下是否满足设计目标
  - 标识哪些角点导致指标不达标
  - 生成角点覆盖率报告
- [ ] **被调用方**：`simulation_service.py`、`tool_executor.py`（响应 `run_pvt_analysis` 工具调用）

#### 4.4.2 `monte_carlo_analysis.py` - 蒙特卡洛分析

> **初始化顺序**：无需显式初始化，作为工具类按需实例化

- [ ] **职责**：执行蒙特卡洛统计分析，评估工艺偏差和元件容差对电路性能的影响
- [ ] **核心功能**：
  - `run_monte_carlo(circuit_file, analysis_config, num_runs, variations)` - 执行蒙特卡洛仿真
  - `define_variation(component, param, distribution, sigma)` - 定义元件参数变化
  - `get_statistics(results, metric)` - 计算统计指标（均值、标准差、最大/最小值）
  - `calculate_yield(results, specs)` - 计算良率
  - `generate_histogram(results, metric, bins)` - 生成直方图数据
  - `identify_sensitive_params(results)` - 识别敏感参数
- [ ] **参数变化分布类型**：
  - 高斯分布（Gaussian）：适用于大多数工艺参数
  - 均匀分布（Uniform）：适用于元件容差
  - 对数正态分布（Log-normal）：适用于某些物理参数
- [ ] **典型变化配置**：
  - 电阻：±5% 或 ±10% 均匀分布
  - 电容：±10% 或 ±20% 均匀分布
  - 晶体管阈值电压：3σ = 30mV 高斯分布
  - 晶体管电流因子：3σ = 5% 高斯分布
- [ ] **并行执行策略**：
  - **进程池并行**：使用 `ProcessPoolExecutor` 并行执行多次仿真
  - **并行度配置**：默认使用 CPU 核心数 - 1，可通过配置调整
  - **批次执行**：将 N 次仿真分成多个批次，每批次并行执行
  - **进度汇报**：每完成一批次发布 `EVENT_MONTE_CARLO_BATCH_COMPLETE` 事件
  - **内存控制**：每批次完成后释放中间结果，仅保留统计摘要
  - **失败处理**：单次仿真失败不影响其他仿真，记录失败次数
  - **提前终止**：若失败率超过阈值（如 10%），提前终止并报告
- [ ] **统计结果结构**：包含运行次数、各指标的统计数据（均值、标准差、最小值、最大值、3σ范围）、良率百分比、敏感参数排名
- [ ] **良率计算**：
  - 根据设计目标计算各指标的通过率
  - 综合良率 = 所有指标同时满足的比例
  - 支持设置良率目标（如 99.7% 对应 3σ）
- [ ] **被调用方**：`simulation_service.py`、`tool_executor.py`（响应 `run_monte_carlo` 工具调用）

#### 4.4.3 `parametric_sweep.py` - 参数扫描

> **初始化顺序**：无需显式初始化，作为工具类按需实例化

- [ ] **职责**：执行参数扫描分析，探索设计空间，辅助参数优化
- [ ] **核心功能**：
  - `run_sweep(circuit_file, analysis_config, sweep_config)` - 执行参数扫描
  - `define_sweep_param(component, param, start, stop, step)` - 定义扫描参数
  - `define_nested_sweep(params)` - 定义嵌套扫描（多参数同时扫描）
  - `find_optimal_point(results, objective, constraints)` - 找出最优参数点
  - `generate_contour_data(results, x_param, y_param, z_metric)` - 生成等高线图数据
- [ ] **扫描类型**：
  - 线性扫描：等间距扫描
  - 对数扫描：对数间距扫描（适用于频率、电阻等）
  - 列表扫描：指定离散值列表
- [ ] **嵌套扫描支持**：
  - 支持最多 3 层嵌套扫描
  - 自动计算总仿真次数并预估时间
  - 超过阈值时提示用户确认
- [ ] **结果可视化数据**：
  - 单参数扫描：生成曲线数据
  - 双参数扫描：生成等高线/热力图数据
  - 三参数扫描：生成切片数据
- [ ] **优化辅助**：
  - 根据扫描结果识别参数敏感度
  - 建议参数调整方向
  - 标识设计空间中的可行区域
- [ ] **被调用方**：`simulation_service.py`、`tool_executor.py`（响应 `run_parametric_sweep` 工具调用）

#### 4.4.4 `worst_case_analysis.py` - 最坏情况分析

> **设计参考**：借鉴 LTspice 的最坏情况分析功能，比蒙特卡洛更快速地找到极端情况

- [ ] **职责**：分析元件容差组合的最坏情况，快速评估设计裕度
- [ ] **核心功能**：
  - `run_worst_case(circuit_file, tolerances, method, metric)` - 执行最坏情况分析
  - `define_tolerance(component, param, tolerance_percent)` - 定义元件容差
  - `get_worst_combination(results, metric)` - 获取导致最差性能的参数组合
  - `calculate_design_margin(results, spec)` - 计算设计裕度
  - `generate_worst_case_report(results)` - 生成最坏情况报告
- [ ] **分析方法**：
  - RSS（Root Sum Square）方法：假设参数变化独立且服从正态分布，计算均方根叠加效应，适用于大多数情况
  - EVA（Extreme Value Analysis）方法：考虑所有参数同时取极端值的情况，结果更保守，适用于高可靠性要求
  - 敏感度加权方法：根据参数敏感度加权计算最坏情况
- [ ] **RSS 方法计算**：首先对每个参数单独进行 +tolerance 和 -tolerance 仿真，计算每个参数对指标的影响量 Δi，然后计算总变化量为各影响量平方和的平方根，最后得到最坏情况值为标称值加减总变化量。
- [ ] **EVA 方法计算**：首先确定每个参数对指标的影响方向（正相关或负相关），然后将所有正相关参数设为使指标变差的极端值，将所有负相关参数也设为使指标变差的极端值，最后执行一次仿真得到最坏情况。
- [ ] **结果数据结构**：结果包含分析方法、标称值、最坏情况值（最大和最小）、设计裕度百分比、关键参数列表（按影响程度排序），以及各参数的敏感度系数。
- [ ] **与蒙特卡洛的区别**：
  - 最坏情况分析：仿真次数少（2N+1 次，N 为参数数量），快速得到极端情况
  - 蒙特卡洛分析：仿真次数多（通常 100-1000 次），得到统计分布
  - 建议先用最坏情况分析快速评估，再用蒙特卡洛验证
- [ ] **被调用方**：`simulation_service.py`、`tool_executor.py`（响应 `run_worst_case` 工具调用）

#### 4.4.5 `sensitivity_analysis.py` - 敏感度分析

> **设计参考**：借鉴 LTspice 的敏感度分析功能，识别关键元件指导优化方向

- [ ] **职责**：分析各参数对输出的影响程度，识别关键元件
- [ ] **核心功能**：
  - `run_sensitivity(circuit_file, params, metric)` - 执行敏感度分析
  - `calculate_sensitivity(param, nominal, perturbed, delta)` - 计算单个参数敏感度
  - `rank_by_sensitivity(results)` - 按敏感度排序参数
  - `identify_critical_components(results, threshold)` - 识别关键元件
  - `generate_tornado_chart_data(results)` - 生成龙卷风图数据
  - `get_optimization_suggestions(results, goals)` - 获取优化建议
- [ ] **敏感度计算方法**：
  - 绝对敏感度：S = ∂Output / ∂Param
  - 相对敏感度：S_rel = (∂Output / Output) / (∂Param / Param)
  - 归一化敏感度：将敏感度归一化到 0-1 范围
- [ ] **敏感度分析流程**：首先执行标称值仿真获取基准结果，然后对每个参数分别进行 +1% 和 -1% 扰动仿真，计算敏感度系数，最后按敏感度绝对值排序。
- [ ] **结果数据结构**：结果包含分析的指标名称、参数敏感度列表（每个参数记录名称、标称值、绝对敏感度、相对敏感度和影响方向），以及关键参数列表（敏感度超过阈值的参数）。
- [ ] **龙卷风图数据**：龙卷风图用于可视化各参数对指标的影响程度，数据包含参数名称列表、正向影响值列表、负向影响值列表，以及基准值。
- [ ] **优化建议生成**：
  - 根据敏感度和当前性能差距生成调参建议
  - 高敏感度参数优先调整
  - 考虑参数调整方向（增大或减小）
  - 估算调整量以达到目标
- [ ] **与 LLM 优化的协同**：
  - 敏感度分析结果可注入 Prompt，帮助 LLM 更有针对性地优化
  - 在 `OPTIMIZE_PARAMETERS` 模板中包含敏感度信息
  - LLM 优先调整高敏感度参数
- [ ] **被调用方**：`simulation_service.py`、`tool_executor.py`（响应 `run_sensitivity` 工具调用）、`action_node.py`（优化时参考）

#### 4.4.6 `post_processor.py` - 仿真后处理

> **初始化顺序**：无需显式初始化，作为工具类按需实例化

- [ ] **职责**：对仿真原始数据进行后处理分析，提取高级特征
- [ ] **核心功能**：
  - `compute_fft(time_data, signal, window)` - 计算 FFT 频谱
  - `compute_thd(fft_result, fundamental_freq)` - 计算总谐波失真
  - `compute_sndr(fft_result, signal_freq)` - 计算信噪失真比
  - `compute_sfdr(fft_result)` - 计算无杂散动态范围
  - `compute_enob(sndr)` - 计算有效位数
  - `find_poles_zeros(ac_data)` - 提取极点和零点
  - `compute_group_delay(ac_data)` - 计算群延迟
  - `interpolate_data(data, new_points)` - 数据插值
  - `smooth_data(data, window_size)` - 数据平滑
- [ ] **FFT 分析参数**：
  - 窗函数选择：Hanning、Hamming、Blackman、Kaiser
  - 零填充支持：提高频率分辨率
  - 频谱平均：减少噪声影响
- [ ] **谐波分析**：
  - 自动识别基波频率
  - 计算各次谐波幅度
  - 支持指定谐波次数范围
- [ ] **极零点提取**：
  - 从 AC 分析数据拟合传递函数
  - 提取主极点和零点位置
  - 计算单位增益带宽、相位裕度等
- [ ] **被调用方**：`metrics_extractor.py`、`chart_generator.py`

#### 4.4.7 `topology_recognizer.py` - 电路拓扑识别

> **初始化顺序**：无需显式初始化，作为工具类按需实例化

- [ ] **职责**：自动识别电路拓扑类型，为仿真配置和指标提取提供指导
- [ ] **核心功能**：
  - `recognize_topology(spice_netlist)` - 识别电路拓扑类型
  - `get_recommended_analyses(topology)` - 获取推荐的分析类型
  - `get_key_metrics(topology)` - 获取关键性能指标列表
  - `get_typical_specs(topology)` - 获取典型规格范围
  - `identify_critical_nodes(spice_netlist, topology)` - 识别关键节点
- [ ] **支持识别的拓扑类型**：
  - 放大器类：共源/共射、共漏/共集、共栅/共基、差分对、运算放大器、仪表放大器
  - 滤波器类：低通、高通、带通、带阻、全通
  - 电源类：LDO、Buck、Boost、Buck-Boost
  - 振荡器类：环形振荡器、LC 振荡器、晶振
  - 比较器类：单端比较器、迟滞比较器
  - 数据转换器类：ADC、DAC
- [ ] **识别方法**：
  - 基于网表结构分析：识别反馈路径、电源连接、信号流向
  - 基于器件组合模式：识别典型电路结构（如电流镜、差分对）
  - 基于仿真控制语句：从 .ac/.tran/.dc 推断分析意图
- [ ] **推荐分析配置**：
  - 放大器：AC 分析（Bode 图）、瞬态分析（阶跃响应）、噪声分析
  - 滤波器：AC 分析（频率响应）、群延迟分析
  - 电源：瞬态分析（负载阶跃）、DC 扫描（负载调整率）
  - 振荡器：瞬态分析（起振特性）、相位噪声分析
- [ ] **被调用方**：`simulation_service.py`（自动配置仿真）、`design_goals_node.py`（建议设计目标）

### 4.5 性能指标提取模块组 (`domain/simulation/metrics/`)

> **设计原则**：根据单一职责原则，将指标提取按类型拆分为独立子模块，便于维护和测试
> 
> **目录结构**：
> ```
> domain/simulation/metrics/
> ├── __init__.py
> ├── metrics_extractor.py      # 门面类，委托给各子模块
> ├── amplifier_metrics.py      # 放大器指标
> ├── noise_metrics.py          # 噪声指标
> ├── distortion_metrics.py     # 失真指标
> ├── power_metrics.py          # 电源指标
> ├── transient_metrics.py      # 瞬态指标
> └── metric_result.py          # 指标结果数据类
> ```

#### 4.5.1 `metric_result.py` - 指标结果数据类

- [ ] **文件路径**：`domain/simulation/metrics/metric_result.py`
- [ ] **职责**：定义标准化的指标结果数据结构
- [ ] **数据类定义**：
  - `MetricResult` - 单个指标结果
    - `name: str` - 指标名称
    - `value: Optional[float]` - 指标数值
    - `unit: str` - 单位
    - `target: Optional[float]` - 目标值
    - `is_met: Optional[bool]` - 是否达标
    - `confidence: float` - 置信度（0-1）
    - `measurement_condition: str` - 测量条件描述
    - `error_message: Optional[str]` - 计算失败时的错误信息
- [ ] **被调用方**：所有指标提取子模块

#### 4.5.2 `metrics_extractor.py` - 指标提取门面类

> **初始化顺序**：无需显式初始化，作为工具类按需实例化

- [ ] **文件路径**：`domain/simulation/metrics/metrics_extractor.py`
- [ ] **职责**：作为门面类协调各子模块，提供统一的指标提取入口
- [ ] **核心功能**：
  - `extract_metrics(sim_data, topology, goals) -> Dict[str, MetricResult]` - 根据拓扑类型自动提取相关指标
  - `extract_all_metrics(sim_data) -> Dict[str, MetricResult]` - 提取所有可计算的指标
  - `get_metric_by_name(sim_data, metric_name) -> MetricResult` - 按名称提取单个指标
- [ ] **委托逻辑**：
  - 放大器指标 → `AmplifierMetrics`
  - 噪声指标 → `NoiseMetrics`
  - 失真指标 → `DistortionMetrics`
  - 电源指标 → `PowerMetrics`
  - 瞬态指标 → `TransientMetrics`
- [ ] **指标计算容错**：
  - 数据不足时返回 `MetricResult` 并设置 `error_message`
  - 计算异常时返回估计值并标记 `confidence`
- [ ] **被调用方**：`analysis_node.py`、`simulation_tab.py`、`pvt_analysis.py`

#### 4.5.3 `amplifier_metrics.py` - 放大器指标提取

- [ ] **文件路径**：`domain/simulation/metrics/amplifier_metrics.py`
- [ ] **职责**：提取放大器相关的性能指标
- [ ] **核心功能**：
  - `extract_gain(ac_data, freq_point)` - 提取指定频率的增益（dB）
  - `extract_bandwidth(ac_data, gain_ref)` - 提取 -3dB 带宽
  - `extract_gbw(ac_data)` - 提取增益带宽积
  - `extract_phase_margin(ac_data)` - 提取相位裕度
  - `extract_gain_margin(ac_data)` - 提取增益裕度
  - `extract_input_impedance(ac_data)` - 提取输入阻抗
  - `extract_output_impedance(ac_data)` - 提取输出阻抗
  - `extract_cmrr(ac_data)` - 提取共模抑制比
  - `extract_psrr(ac_data)` - 提取电源抑制比
  - `extract_slew_rate(tran_data)` - 提取压摆率（上升/下降）
  - `extract_settling_time(tran_data, target, tolerance)` - 提取整定时间
  - `extract_overshoot(tran_data)` - 提取过冲量
  - `extract_offset_voltage(dc_data)` - 提取输入失调电压
- [ ] **被调用方**：`metrics_extractor.py`（门面类）

#### 4.5.4 `noise_metrics.py` - 噪声指标提取

- [ ] **文件路径**：`domain/simulation/metrics/noise_metrics.py`
- [ ] **职责**：提取噪声相关的性能指标
- [ ] **核心功能**：
  - `extract_input_noise(noise_data, freq_point)` - 提取输入等效噪声电压密度
  - `extract_integrated_noise(noise_data, freq_range)` - 提取积分噪声
  - `extract_noise_figure(noise_data)` - 提取噪声系数
  - `extract_snr(noise_data, signal_level)` - 提取信噪比
- [ ] **被调用方**：`metrics_extractor.py`（门面类）

#### 4.5.5 `distortion_metrics.py` - 失真指标提取

- [ ] **文件路径**：`domain/simulation/metrics/distortion_metrics.py`
- [ ] **职责**：提取失真相关的性能指标
- [ ] **核心功能**：
  - `extract_thd(fft_data)` - 提取总谐波失真
  - `extract_thd_n(fft_data)` - 提取 THD+N
  - `extract_imd(fft_data, f1, f2)` - 提取互调失真
  - `extract_sfdr(fft_data)` - 提取无杂散动态范围
  - `extract_sndr(fft_data)` - 提取信噪失真比
  - `extract_enob(sndr)` - 提取有效位数
- [ ] **被调用方**：`metrics_extractor.py`（门面类）

#### 4.5.6 `power_metrics.py` - 电源指标提取

- [ ] **文件路径**：`domain/simulation/metrics/power_metrics.py`
- [ ] **职责**：提取电源相关的性能指标
- [ ] **核心功能**：
  - `extract_quiescent_current(dc_data)` - 提取静态电流
  - `extract_power_consumption(dc_data)` - 提取功耗
  - `extract_efficiency(tran_data)` - 提取效率（电源电路）
  - `extract_load_regulation(dc_data)` - 提取负载调整率
  - `extract_line_regulation(dc_data)` - 提取线性调整率
  - `extract_dropout_voltage(dc_data)` - 提取压差（LDO）
  - `extract_component_power(sim_data, component_name)` - 提取单个元件功耗
  - `extract_power_distribution(sim_data)` - 提取各元件功耗分布
  - `extract_efficiency_curve(tran_data, load_range)` - 提取效率随负载变化曲线
  - `extract_power_loss_breakdown(sim_data)` - 功耗损耗分解
  - `estimate_thermal_rise(power_data, thermal_resistance)` - 估算元件温升
- [ ] **被调用方**：`metrics_extractor.py`（门面类）

#### 4.5.7 `transient_metrics.py` - 瞬态指标提取

- [ ] **文件路径**：`domain/simulation/metrics/transient_metrics.py`
- [ ] **职责**：提取瞬态分析相关的性能指标
- [ ] **核心功能**：
  - `extract_rise_time(tran_data, low, high)` - 提取上升时间
  - `extract_fall_time(tran_data, low, high)` - 提取下降时间
  - `extract_propagation_delay(tran_data)` - 提取传播延迟
  - `extract_duty_cycle(tran_data)` - 提取占空比
  - `extract_frequency(tran_data)` - 提取振荡频率
- [ ] **被调用方**：`metrics_extractor.py`（门面类）

### 4.6 仿真辅助模块 (`domain/simulation/`)

#### 4.6.1 `convergence_helper.py` - 仿真收敛辅助

> **初始化顺序**：无需显式初始化，作为工具类按需实例化

- [ ] **职责**：辅助解决仿真收敛问题，自动调整仿真参数，提高仿真成功率
- [ ] **核心功能**：
  - `diagnose_convergence_issue(error_output)` - 诊断收敛问题类型
  - `suggest_initial_conditions(netlist)` - 建议初始条件设置
  - `adjust_simulation_params(current_params, error_type)` - 调整仿真参数
  - `add_convergence_aids(netlist)` - 添加收敛辅助元件
  - `validate_netlist_connectivity(netlist)` - 验证网表连通性
- [ ] **收敛问题诊断**：
  - DC 工作点不收敛：检查电源连接、浮空节点、初始条件
  - 瞬态分析不收敛：检查时间步长、非线性元件、初始状态
  - AC 分析异常：检查直流偏置点、小信号模型有效性
- [ ] **自动修复策略**：
  - 浮空节点：自动添加高阻接地电阻（如 1GΩ）
  - DC 不收敛：逐步放宽 gmin、reltol、abstol 参数
  - 瞬态不收敛：减小最大时间步长、添加 .ic 初始条件
  - 模型问题：建议替换为简化模型或添加寄生参数
- [ ] **初始条件建议**：
  - 分析电路拓扑，识别需要初始条件的节点
  - 根据电源电压和电路结构估算合理的初始值
  - 生成 .ic 语句建议
- [ ] **收敛辅助元件**：
  - Gmin 步进：在关键节点添加小电导
  - 源步进：逐步增加电源电压
  - 伪瞬态分析：将 DC 分析转换为瞬态分析
- [ ] **网表验证**：
  - 检查所有节点是否有 DC 通路到地
  - 检查电源和地的连接完整性
  - 检查器件参数是否在有效范围内
  - 检查 .include 文件是否存在
- [ ] **被调用方**：`spice_executor.py`（仿真失败时）、`fix_error_action.py`（错误修复时）

#### 4.6.2 `feedback_generator.py` - 反馈生成器（备用）

> **初始化顺序**：无需显式初始化，作为工具类按需实例化

- [ ] **职责**：根据性能差距生成优化建议（备用模块）
- [ ] **说明**：在当前LangGraph流程中，此功能由 `analysis_node` 中的LLM直接完成
- [ ] **核心功能**（如需独立使用）：
  - `compare_with_goals(metrics, goals)` - 比较实际值与目标值
  - `generate_suggestions(gaps)` - 根据差距生成调参建议
- [ ] **被调用方**：可选，作为LLM分析的补充或降级方案

#### 4.6.3 `library_manager.py` - 子电路库管理器

> **设计参考**：借鉴 LTspice 的元件库管理功能
> 
> **路径解析说明**：
> - 调用 `ngspice_config.get_ngspice_models_path()` 获取模型库基础路径
> - 自动处理开发环境和打包环境的路径差异
> - 支持 cmp/sub/custom 三类模型目录

- [ ] **职责**：管理 SPICE 子电路库和元件模型，支持导入、搜索和组织
- [ ] **依赖**：`ngspice_config`（路径获取）
- [ ] **核心功能**：
  - `list_available_libraries()` - 列出所有可用库
  - `import_library(path, library_name)` - 导入外部库文件到 custom 目录
  - `export_library(library_name, output_path)` - 导出库文件
  - `search_component(keyword, category)` - 搜索元件
  - `get_component_info(component_name)` - 获取元件详细信息
  - `add_to_favorites(component_name)` - 添加到收藏
  - `get_favorites()` - 获取收藏列表
  - `validate_library(library_path)` - 校验库文件格式
- [ ] **库文件组织结构**：
  - 内嵌库目录：`vendor/ngspice/{platform}/.../models/cmp/` 和 `models/sub/`（只读，随应用分发）
  - 用户库目录：`vendor/ngspice/{platform}/.../models/custom/`（可写，用户导入的库）
  - 项目库目录：`{project}/libraries/`（项目专用库，可选）
- [ ] **预置库内容**（位于 sub 目录）：
  - 通用运放模型（如 LM741、LT1001、ADI 系列）
  - 通用比较器模型（如 LM393、LM311）
  - 电源管理芯片模型（LT 系列稳压器）
  - 基本晶体管和 MOSFET 模型（位于 cmp 目录）
- [ ] **元件搜索功能**：
  - 支持按名称模糊搜索
  - 支持按类别筛选（运放、比较器、晶体管、MOSFET、稳压器等）
  - 支持按厂商筛选
  - 支持按参数范围筛选（如增益带宽积 > 10MHz）
- [ ] **元件信息数据结构**：元件信息包含名称、类别、厂商、描述、关键参数列表、数据手册链接（可选）、库文件路径，以及使用示例代码。
- [ ] **库文件格式支持**：
  - 标准 SPICE 库文件（.lib、.mod）
  - LTspice 库文件（.lib、.sub）
  - PSpice 库文件（.lib）
  - 自动检测并转换格式差异
- [ ] **被调用方**：`file_browser_panel.py`（库管理面板）、`initial_design_node.py`（选择元件）

#### 4.6.4 `library_downloader.py` - 元件库下载器

> **设计目标**：提供预制元件库的自动下载和更新功能，确保用户开箱即用
>
> **架构说明**：网络下载属于 I/O 操作，按分层架构原则放在 infrastructure 层

- [ ] **文件路径**：`infrastructure/library/library_downloader.py`
- [ ] **职责**：从远程源下载和更新 SPICE 元件库
- [ ] **核心功能**：
  - `download_default_libraries()` - 下载默认预制库
  - `update_library(library_name)` - 更新指定库
  - `check_updates()` - 检查库更新
  - `get_download_progress()` - 获取下载进度
  - `cancel_download()` - 取消下载
- [ ] **预制库来源**：
  - **ngspice 官方模型**：从 ngspice SourceForge 仓库获取标准模型
  - **开源社区库**：从 GitHub `spice-models` 等项目获取
  - **厂商模型索引**：提供 TI、ADI、ON Semi 等厂商模型的下载链接索引
- [ ] **下载目录**：
  - 系统库：`vendor/spice_libraries/`（随应用分发）
  - 用户库：`~/.circuit_design_ai/libraries/`（用户下载）
- [ ] **首次启动检查**：
  - 应用首次启动时检查 `vendor/spice_libraries/` 是否存在
  - 若不存在或不完整，提示用户下载预制库
  - 提供"跳过"选项，用户可稍后手动下载
- [ ] **库清单文件**：
  - 远程清单：`https://example.com/circuit-ai/library-manifest.json`
  - 本地清单：`vendor/spice_libraries/manifest.json`
  - 清单内容：库名称、版本、下载 URL、SHA256 校验和、文件大小
- [ ] **下载流程**：
  1. 获取远程清单
  2. 比对本地清单，确定需要下载/更新的库
  3. 显示下载确认对话框（列出库名称和大小）
  4. 用户确认后开始下载
  5. 下载完成后校验 SHA256
  6. 解压到目标目录
  7. 更新本地清单
- [ ] **离线模式**：
  - 支持从本地 ZIP 文件导入库
  - 支持导出已安装库为 ZIP 文件
- [ ] **事件发布**：
  - `EVENT_LIBRARY_DOWNLOAD_STARTED` - 下载开始
  - `EVENT_LIBRARY_DOWNLOAD_PROGRESS` - 下载进度
  - `EVENT_LIBRARY_DOWNLOAD_COMPLETE` - 下载完成
  - `EVENT_LIBRARY_DOWNLOAD_ERROR` - 下载错误
- [ ] **被调用方**：`library_manager.py`、`startup_check.py`（首次启动检查）

---

### 4.7 可视化子域 (`domain/simulation/visualization/`)

> **⚠️ 大数据波形渲染核心约束**：
> - 仿真产生的瞬态分析数据可能达百万级数据点
> - 禁止将原始数据直接传递给前端 Plotly，必须经过降采样处理
> - 前后端通信使用二进制编码（Base64 TypedArray），禁止 JSON 序列化大量浮点数
> - 交互式图表采用分层渲染架构：初始显示低分辨率，缩放时按需加载高分辨率

> **目录结构**：
> ```
> domain/simulation/visualization/
> ├── __init__.py
> ├── streaming/                       # 大数据波形流式渲染子模块（新增）
> │   ├── __init__.py
> │   ├── waveform_data_service.py     # 波形数据服务门面类
> │   ├── lttb_downsampler.py          # LTTB 降采样算法
> │   ├── resolution_pyramid.py        # 多分辨率金字塔管理
> │   ├── viewport_data_provider.py    # 视口感知数据提供器
> │   ├── waveform_prefetcher.py       # 预加载服务
> │   └── binary_data_encoder.py       # 二进制数据编码器
> ├── chart_generator.py               # 图表生成（集成降采样）
> ├── waveform_measurement.py          # 波形测量（双光标、自动标注）
> ├── waveform_math.py                 # 波形数学运算
> ├── simulation_result_storage.py     # 仿真结果存储（含分辨率金字塔）
> ├── data_exporter.py                 # 数据导出（CSV、MATLAB）
> └── report_generator.py              # PDF报告生成
> ```

#### 4.7.0 大数据波形渲染架构概览

> **设计目标**：解决百万级数据点的交互式波形渲染问题，确保初始渲染 < 500ms，缩放响应 < 100ms

> **核心架构原则**：
> - **分层降采样**：预计算多分辨率金字塔，避免实时计算开销
> - **视口感知加载**：只加载当前可见范围的数据，不加载全量数据
> - **二进制传输**：使用 Base64 编码的 TypedArray 传输数据，避免 JSON 序列化开销
> - **智能预加载**：预测用户操作，提前加载相邻区域数据

##### 4.7.0.1 大数据波形渲染数据流图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      大数据波形渲染数据流转路径                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [仿真完成]                                                             │
│       │                                                                 │
│       ▼                                                                 │
│  SimulationResultStorage.save_iteration_results()                       │
│       │                                                                 │
│       ├──► ResolutionPyramid.build_pyramid()                            │
│       │         │                                                       │
│       │         ├──► LTTBDownsampler.downsample(原始数据, 50000点)       │
│       │         ├──► LTTBDownsampler.downsample(原始数据, 10000点)       │
│       │         ├──► LTTBDownsampler.downsample(原始数据, 2000点)        │
│       │         └──► LTTBDownsampler.downsample(原始数据, 500点)         │
│       │                                                                 │
│       ▼                                                                 │
│  [存储到文件系统]                                                        │
│       │                                                                 │
│       ├──► raw_data.bin          # 原始数据（二进制格式）                │
│       ├──► pyramid_50000.bin     # 50000点分辨率层                       │
│       ├──► pyramid_10000.bin     # 10000点分辨率层                       │
│       ├──► pyramid_2000.bin      # 2000点分辨率层                        │
│       └──► pyramid_500.bin       # 500点分辨率层（缩略图）               │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [用户打开图表]                                                          │
│       │                                                                 │
│       ▼                                                                 │
│  WaveformDataService.get_initial_data()                                 │
│       │                                                                 │
│       ├──► 选择合适的分辨率层（根据视口宽度）                            │
│       │                                                                 │
│       ├──► BinaryDataEncoder.encode_to_base64()                         │
│       │                                                                 │
│       ▼                                                                 │
│  [返回 Base64 编码数据给前端]                                            │
│       │                                                                 │
│       ▼                                                                 │
│  [前端 Plotly 渲染]  ◄── 初始渲染 < 500ms                                │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [用户缩放/平移]                                                         │
│       │                                                                 │
│       ▼                                                                 │
│  Plotly relayout 事件 → QWebChannel 调用                                │
│       │                                                                 │
│       ▼                                                                 │
│  ViewportDataProvider.get_viewport_data(x_min, x_max, viewport_width)   │
│       │                                                                 │
│       ├──► 计算所需分辨率 = viewport_width * 2                          │
│       │                                                                 │
│       ├──► 从金字塔选择最接近的分辨率层                                  │
│       │                                                                 │
│       ├──► 裁剪到 [x_min, x_max] 范围                                   │
│       │                                                                 │
│       ├──► BinaryDataEncoder.encode_to_base64()                         │
│       │                                                                 │
│       ▼                                                                 │
│  [返回 Base64 编码数据]  ◄── 响应时间 < 100ms                            │
│       │                                                                 │
│       ▼                                                                 │
│  WaveformPrefetcher.prefetch_adjacent()  ◄── 后台预加载相邻区域          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

##### 4.7.0.2 性能指标要求

- [ ] **初始渲染延迟**：< 500ms（从打开图表到首次显示）
- [ ] **缩放响应延迟**：< 100ms（从用户操作到图表更新）
- [ ] **前端内存占用**：< 50MB（单个图表）
- [ ] **金字塔构建时间**：< 2s（百万点数据）
- [ ] **预加载命中率**：> 80%（用户小幅平移时无需请求后端）

##### 4.7.0.2.1 性能保障措施

- [ ] **初始渲染优化**：
  - 使用最低分辨率层（500点）作为初始显示
  - 图表框架先渲染，数据异步加载
  - 显示加载骨架屏，避免空白等待
- [ ] **缩放响应优化**：
  - 前端防抖：50ms 内的连续缩放操作合并为一次请求
  - 后端缓存：LRU 缓存最近 10 个视口范围的数据
  - 增量更新：仅更新变化的数据点，不重绘整个图表
- [ ] **内存控制**：
  - 前端只保留当前视口 + 预加载区域的数据
  - 超出范围的数据自动释放
  - 监控内存占用，超过阈值时清理缓存
- [ ] **金字塔构建优化**：
  - 使用 NumPy 向量化操作，避免 Python 循环
  - 多信号并行构建（使用 ThreadPoolExecutor）
  - 构建过程异步执行，不阻塞仿真完成事件
- [ ] **预加载策略**：
  - 根据用户操作方向预测下一个视口范围
  - 后台线程预加载，不阻塞主线程
  - 预加载优先级：当前视口 > 相邻区域 > 远端区域

##### 4.7.0.3 分辨率层级配置

- [ ] **默认层级**：`[500, 2000, 10000, 50000]` 点
- [ ] **层级选择策略**：选择大于等于 `viewport_width * 2` 的最小层级
- [ ] **原始数据保留**：始终保留原始数据，用于极端放大场景
- [ ] **动态层级**：数据量 < 10000 点时不生成金字塔，直接使用原始数据

#### 4.7.0.4 流式渲染子模块 (`domain/simulation/visualization/streaming/`)

##### `waveform_data_service.py` - 波形数据服务门面类

- [ ] **文件路径**：`domain/simulation/visualization/streaming/waveform_data_service.py`
- [ ] **职责**：作为波形数据访问的统一入口，协调降采样、缓存、预加载
- [ ] **核心功能**：
  - `get_initial_data(signal_name, viewport_width) -> WaveformDataPacket` - 获取初始显示数据
  - `get_viewport_data(signal_name, x_min, x_max, viewport_width) -> WaveformDataPacket` - 获取视口范围数据
  - `get_full_resolution_data(signal_name, x_min, x_max) -> WaveformDataPacket` - 获取原始分辨率数据（极端放大时）
  - `invalidate_cache(signal_name)` - 使缓存失效
  - `preload_signal(signal_name)` - 预加载信号数据到内存
- [ ] **`WaveformDataPacket` 数据结构**：
  - `signal_name: str` - 信号名称
  - `x_data_base64: str` - X 轴数据（Base64 编码的 Float64Array）
  - `y_data_base64: str` - Y 轴数据（Base64 编码的 Float64Array）
  - `point_count: int` - 数据点数量
  - `resolution_level: int` - 当前分辨率层级
  - `x_range: Tuple[float, float]` - X 轴范围
  - `y_range: Tuple[float, float]` - Y 轴范围
  - `is_full_resolution: bool` - 是否为原始分辨率
- [ ] **依赖**：`ResolutionPyramid`、`ViewportDataProvider`、`BinaryDataEncoder`、`WaveformPrefetcher`
- [ ] **被调用方**：`chart_generator.py`、`chart_viewer_panel.py`（通过 QWebChannel）

##### `lttb_downsampler.py` - LTTB 降采样算法

- [ ] **文件路径**：`domain/simulation/visualization/streaming/lttb_downsampler.py`
- [ ] **职责**：实现 Largest Triangle Three Buckets 降采样算法，保持波形视觉特征
- [ ] **核心功能**：
  - `downsample(x: np.ndarray, y: np.ndarray, target_points: int) -> Tuple[np.ndarray, np.ndarray]` - 执行 LTTB 降采样
  - `downsample_multiple(x: np.ndarray, signals: Dict[str, np.ndarray], target_points: int) -> Dict[str, Tuple[np.ndarray, np.ndarray]]` - 批量降采样多个信号（共享 X 轴）
- [ ] **算法说明**：
  - LTTB 将数据分成 N 个桶（bucket）
  - 每个桶选择一个点，使其与相邻桶的代表点形成的三角形面积最大
  - 保留波形的峰值、谷值等视觉特征，优于简单的等间隔采样
- [ ] **性能要求**：
  - 百万点降采样到 2000 点：< 100ms
  - 使用 NumPy 向量化操作优化性能
- [ ] **被调用方**：`ResolutionPyramid`、`ViewportDataProvider`

##### `resolution_pyramid.py` - 多分辨率金字塔管理

- [ ] **文件路径**：`domain/simulation/visualization/streaming/resolution_pyramid.py`
- [ ] **职责**：管理波形数据的多分辨率金字塔，支持构建、存储、加载
- [ ] **核心功能**：
  - `build_pyramid(x: np.ndarray, y: np.ndarray, levels: List[int]) -> PyramidData` - 构建分辨率金字塔
  - `save_pyramid(pyramid: PyramidData, output_dir: Path)` - 保存金字塔到文件
  - `load_pyramid(input_dir: Path) -> PyramidData` - 从文件加载金字塔
  - `get_level_data(pyramid: PyramidData, level: int) -> Tuple[np.ndarray, np.ndarray]` - 获取指定层级数据
  - `select_optimal_level(pyramid: PyramidData, required_points: int) -> int` - 选择最优层级
- [ ] **`PyramidData` 数据结构**：
  - `signal_name: str` - 信号名称
  - `original_point_count: int` - 原始数据点数
  - `levels: Dict[int, Tuple[np.ndarray, np.ndarray]]` - 各层级数据 {点数: (x, y)}
  - `x_range: Tuple[float, float]` - X 轴范围
  - `y_range: Tuple[float, float]` - Y 轴范围
  - `build_timestamp: str` - 构建时间戳
- [ ] **存储格式**：
  - 使用 NumPy 的 `.npy` 格式存储二进制数据
  - 元数据存储在 `pyramid_meta.json`
- [ ] **被调用方**：`WaveformDataService`、`SimulationResultStorage`

##### `viewport_data_provider.py` - 视口感知数据提供器

- [ ] **文件路径**：`domain/simulation/visualization/streaming/viewport_data_provider.py`
- [ ] **职责**：根据当前视口范围和宽度，提供最优分辨率的数据
- [ ] **核心功能**：
  - `get_viewport_data(pyramid: PyramidData, x_min: float, x_max: float, viewport_width: int) -> Tuple[np.ndarray, np.ndarray]` - 获取视口数据
  - `calculate_required_resolution(viewport_width: int) -> int` - 计算所需分辨率
  - `crop_to_range(x: np.ndarray, y: np.ndarray, x_min: float, x_max: float) -> Tuple[np.ndarray, np.ndarray]` - 裁剪到指定范围
- [ ] **分辨率计算策略**：
  - 所需点数 = `viewport_width * 2`（确保每像素至少 2 个数据点）
  - 从金字塔中选择大于等于所需点数的最小层级
  - 若所有层级都不足，使用原始数据并实时降采样
- [ ] **范围裁剪优化**：
  - 使用二分查找定位范围边界
  - 扩展边界 5% 以支持平滑滚动
- [ ] **被调用方**：`WaveformDataService`

##### `waveform_prefetcher.py` - 预加载服务

- [ ] **文件路径**：`domain/simulation/visualization/streaming/waveform_prefetcher.py`
- [ ] **职责**：预测用户操作，提前加载相邻区域数据，减少交互延迟
- [ ] **核心功能**：
  - `prefetch_adjacent(signal_name: str, current_x_min: float, current_x_max: float, direction: str)` - 预加载相邻区域
  - `get_prefetched_data(signal_name: str, x_min: float, x_max: float) -> Optional[Tuple[np.ndarray, np.ndarray]]` - 获取预加载数据
  - `clear_prefetch_cache(signal_name: str)` - 清除预加载缓存
  - `set_prefetch_ratio(ratio: float)` - 设置预加载比例（默认 0.5，即预加载当前视口宽度的 50%）
- [ ] **预加载策略**：
  - 用户查看 `[t1, t2]` 时，后台预加载 `[t1 - delta, t1]` 和 `[t2, t2 + delta]`
  - `delta = (t2 - t1) * prefetch_ratio`
  - 预加载在后台线程执行，不阻塞主线程
- [ ] **缓存管理**：
  - 使用 LRU 缓存，最多缓存 10 个区域
  - 缓存键：`(signal_name, x_min, x_max, resolution_level)`
- [ ] **被调用方**：`WaveformDataService`

##### `binary_data_encoder.py` - 二进制数据编码器

- [ ] **文件路径**：`domain/simulation/visualization/streaming/binary_data_encoder.py`
- [ ] **职责**：将 NumPy 数组编码为 Base64 字符串，供前端 JavaScript 直接解析为 TypedArray
- [ ] **核心功能**：
  - `encode_to_base64(data: np.ndarray, dtype: str = 'float64') -> str` - 编码为 Base64
  - `decode_from_base64(base64_str: str, dtype: str = 'float64') -> np.ndarray` - 从 Base64 解码
  - `encode_waveform_packet(x: np.ndarray, y: np.ndarray) -> Dict[str, str]` - 编码完整波形数据包
- [ ] **编码格式**：
  - 使用 `numpy.ndarray.tobytes()` 获取原始字节
  - 使用 `base64.b64encode()` 编码为 Base64 字符串
  - 前端使用 `atob()` + `Float64Array` 解码
- [ ] **性能对比**：
  - JSON 序列化 10000 个浮点数：约 200KB，解析约 50ms
  - Base64 编码 10000 个浮点数：约 107KB，解析约 5ms
- [ ] **前端解码示例**（文档说明，非实现代码）：
  ```javascript
  // 前端 JavaScript 解码示例
  function decodeBase64ToFloat64Array(base64Str) {
      const binaryStr = atob(base64Str);
      const bytes = new Uint8Array(binaryStr.length);
      for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
      }
      return new Float64Array(bytes.buffer);
  }
  ```
- [ ] **被调用方**：`WaveformDataService`

#### 4.7.1 `chart_generator.py` - 图表生成

> **初始化顺序**：无需显式初始化，作为工具类按需实例化，依赖 matplotlib 库、file_manager（文件写入）、WaveformDataService（大数据降采样）

> **⚠️ 大数据处理约束**：
> - 禁止将原始仿真数据直接传递给 Plotly
> - 交互式图表必须通过 `WaveformDataService` 获取降采样数据
> - 静态图表可直接使用原始数据（matplotlib 在后端渲染，无前端内存压力）

- [ ] **职责**：根据仿真数据生成各类分析图表
- [ ] **核心功能**：
  - `generate_charts(types, data, output_dir, iteration)` - 批量生成指定类型图表
  - `generate_chart_by_type(chart_type, data, output_path)` - 按类型生成单个图表
- [ ] **频域分析图表**：
  - `generate_bode_magnitude(ac_data, output_path)` - 生成幅频响应图
  - `generate_bode_phase(ac_data, output_path)` - 生成相频响应图
  - `generate_bode_combined(ac_data, output_path)` - 生成组合 Bode 图（幅度+相位）
  - `generate_nyquist(ac_data, output_path)` - 生成 Nyquist 稳定性图
  - `generate_nichols(ac_data, output_path)` - 生成 Nichols 图
  - `generate_pole_zero_map(ac_data, output_path)` - 生成极零点图
  - `generate_group_delay(ac_data, output_path)` - 生成群延迟图
- [ ] **时域分析图表**：
  - `generate_transient_waveform(tran_data, output_path)` - 生成瞬态波形图
  - `generate_step_response(tran_data, output_path)` - 生成阶跃响应图
  - `generate_pulse_response(tran_data, output_path)` - 生成脉冲响应图
  - `generate_eye_diagram(tran_data, output_path)` - 生成眼图（高速信号）
  - `generate_slew_rate_plot(tran_data, output_path)` - 生成压摆率测量图
- [ ] **噪声与失真图表**：
  - `generate_noise_spectrum(noise_data, output_path)` - 生成噪声功率谱密度图
  - `generate_integrated_noise(noise_data, output_path)` - 生成积分噪声图
  - `generate_thd_spectrum(fft_data, output_path)` - 生成谐波失真谱
  - `generate_imd_spectrum(fft_data, output_path)` - 生成互调失真谱
  - `generate_dnl_inl(adc_data, output_path)` - 生成 DNL/INL 图（ADC）
- [ ] **统计分析图表**：
  - `generate_monte_carlo_histogram(mc_results, metric, output_path)` - 生成蒙特卡洛直方图
  - `generate_yield_curve(mc_results, output_path)` - 生成良率曲线
  - `generate_sensitivity_bar(mc_results, output_path)` - 生成参数敏感度柱状图
  - `generate_pvt_comparison(pvt_results, metric, output_path)` - 生成 PVT 角点对比图
  - `generate_parametric_sweep_plot(sweep_results, output_path)` - 生成参数扫描曲线
  - `generate_contour_plot(sweep_results, x_param, y_param, z_metric, output_path)` - 生成等高线图
- [ ] **FFT 频谱图表**（借鉴 LTspice 频谱显示功能）：
  - `generate_fft_spectrum(tran_data, signal_name, output_path)` - 生成 FFT 频谱图
  - `generate_harmonic_bar_chart(fft_data, output_path)` - 生成谐波分量柱状图
  - `generate_power_spectrum_density(tran_data, signal_name, output_path)` - 生成功率谱密度图
- [ ] **功率分析图表**（借鉴 LTspice 功率分析功能）：
  - `generate_power_distribution_pie(power_data, output_path)` - 生成功耗分布饼图
  - `generate_efficiency_curve(efficiency_data, output_path)` - 生成效率曲线图
  - `generate_power_loss_breakdown(loss_data, output_path)` - 生成功耗损耗分解图
  - `generate_thermal_map(thermal_data, output_path)` - 生成元件温升热力图
- [ ] **敏感度分析图表**：
  - `generate_tornado_chart(sensitivity_data, output_path)` - 生成龙卷风图
  - `generate_sensitivity_ranking(sensitivity_data, output_path)` - 生成敏感度排名图
- [ ] **图表样式**：
  - 使用matplotlib默认样式
  - 标注关键点（-3dB点、相位裕度点等）
  - 添加网格线和图例
- [ ] **输出格式**：
  - **静态图表**：PNG 文件，用于报告和快速预览（使用原始数据）
  - **交互式图表**：HTML 文件，支持缩放、平移、数据点悬停（使用降采样数据）
- [ ] **交互式图表支持（大数据优化架构）**：
  - **实现方式**：生成包含 QWebChannel 通信的 HTML 模板，数据通过后端按需提供
  - **禁止行为**：禁止将原始数据内嵌到 HTML 文件中
  - **数据加载流程**：
    1. HTML 加载时通过 QWebChannel 调用 `WaveformDataService.get_initial_data()`
    2. 获取降采样后的 Base64 编码数据
    3. 前端解码为 TypedArray 后传递给 Plotly
  - **缩放/平移响应流程**：
    1. Plotly `relayout` 事件触发
    2. 通过 QWebChannel 调用 `WaveformDataService.get_viewport_data(x_min, x_max, viewport_width)`
    3. 后端返回对应分辨率的 Base64 编码数据
    4. 前端更新图表（目标响应时间 < 100ms）
  - **交互功能**：
    - 鼠标滚轮缩放（触发后端数据请求）
    - 拖拽平移（触发后端数据请求，预加载减少延迟）
    - 数据点悬停显示具体数值
    - 双击重置视图
    - 框选放大
    - 图例点击显示/隐藏曲线
    - 导出为 PNG/SVG
  - **核心方法**：
    - `generate_interactive_bode(ac_data, output_path)` - 交互式 Bode 图
    - `generate_interactive_transient(tran_data, output_path)` - 交互式瞬态波形（大数据优化）
    - `generate_interactive_nyquist(ac_data, output_path)` - 交互式 Nyquist 图
    - `generate_interactive_charts(types, data, output_dir, iteration)` - 批量生成交互式图表
  - **HTML 图表模板结构**：
    - Plotly 库引用（内嵌或 CDN）
    - QWebChannel 初始化代码
    - Base64 解码工具函数
    - 数据请求和图表更新逻辑
    - relayout 事件监听和防抖处理
  - **前端 JavaScript 实现要点**（文档说明，非实现代码）：
    ```javascript
    // 1. QWebChannel 初始化
    new QWebChannel(qt.webChannelTransport, function(channel) {
        window.waveformService = channel.objects.waveformService;
        loadInitialData();
    });
    
    // 2. 初始数据加载
    function loadInitialData() {
        waveformService.get_initial_data(signalName, viewportWidth, function(packet) {
            const xData = decodeBase64ToFloat64Array(packet.x_data_base64);
            const yData = decodeBase64ToFloat64Array(packet.y_data_base64);
            Plotly.newPlot('chart', [{x: xData, y: yData}], layout);
        });
    }
    
    // 3. 缩放/平移响应（带防抖）
    let debounceTimer;
    document.getElementById('chart').on('plotly_relayout', function(eventData) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(function() {
            const xMin = eventData['xaxis.range[0]'];
            const xMax = eventData['xaxis.range[1]'];
            waveformService.get_viewport_data(signalName, xMin, xMax, viewportWidth, updateChart);
        }, 50);  // 50ms 防抖
    });
    ```
  - **QWebChannel 后端注册**：
    - 在 `chart_viewer_panel.py` 中注册 `WaveformDataService` 到 QWebChannel
    - 使用 `QWebEngineView.page().setWebChannel(channel)`
    - 服务方法需标记 `@pyqtSlot` 装饰器
  - **图表配置选项**：支持配置是否生成交互式图表（默认开启）、是否同时生成静态 PNG 作为备选、主题（亮色/暗色）、初始显示分辨率（默认 2000 点），以及需要标注的关键点列表。
- [ ] **文件命名规则**：
  - 静态图表：`{图表类型}.png`，如 `bode_magnitude.png`
  - 交互式图表：`{图表类型}_interactive.html`，如 `bode_magnitude_interactive.html`
  - 图表文件名不再包含时间戳，因为会话目录已包含时间戳
  - 同一迭代内同类型图表会覆盖（通常每轮迭代只生成一次）
- [ ] **输出目录**：`{work_folder}/simulation_results/session_{timestamp}/iteration_{N}/charts/`
- [ ] **依赖**：`matplotlib`（静态图表）、`plotly`（交互式图表模板）、`WaveformDataService`（大数据降采样）
- [ ] **被调用方**：`tool_executor.py`（响应 `generate_chart` 工具调用）、`simulation_node.py`（迭代完成时自动生成）、`chart_viewer_panel.py`（UI 显示）

#### 4.7.2 `waveform_measurement.py` - 波形测量模块

> **设计参考**：借鉴 LTspice 的交互式测量功能，支持双光标测量和自动关键点标注

- [ ] **职责**：提供波形数据的精确测量功能，支持双光标和自动标注
- [ ] **核心功能**：
  - `get_value_at_point(data, x_coord)` - 获取指定坐标点的精确数值
  - `measure_between_cursors(data, cursor1, cursor2)` - 双光标测量
  - `find_critical_points(data, point_type)` - 查找关键点
  - `auto_annotate(data, annotations_config)` - 自动标注关键点
- [ ] **双光标测量功能**：
  - 支持在波形上放置两个独立光标
  - 自动计算两点间的差值（ΔV、Δt、Δf）
  - 计算两点间的斜率（dV/dt）
  - 计算频率（1/Δt）
  - 支持光标锁定到波形数据点
- [ ] **操作提示与引导**：
  - **首次使用引导**：首次进入测量模式时显示操作提示气泡
    - "点击波形放置第一个光标"
    - "再次点击放置第二个光标"
    - "拖拽光标调整位置"
    - "按 ESC 退出测量模式"
  - **状态栏提示**：测量模式下状态栏显示当前操作状态
    - "测量模式：等待放置光标 1"
    - "测量模式：等待放置光标 2"
    - "测量模式：拖拽光标调整位置"
  - **快捷键提示**：工具栏测量按钮悬停时显示快捷键（如 Ctrl+M）
  - **测量结果面板**：测量完成后在图表下方显示结果面板
    - 显示所有测量值（Δx、Δy、斜率、频率）
    - 提供"复制结果"按钮
    - 提供"清除测量"按钮
- [ ] **测量结果数据结构**：测量结果包含两个光标的坐标和数值、差值（Δx 和 Δy）、斜率、频率（若为时域数据），以及测量时间戳。
- [ ] **关键点自动检测**：
  - `-3dB 点`：增益下降 3dB 的频率点
  - `过零点`：波形穿越零电平的时间点
  - `峰值点`：局部最大值和最小值
  - `相位裕度点`：增益为 0dB 时的相位
  - `增益裕度点`：相位为 -180° 时的增益
  - `上升/下降沿`：10%-90% 或 20%-80% 跳变点
  - `整定时间点`：进入容差带的时间点
- [ ] **自动标注配置**：支持配置需要标注的关键点类型列表、标注样式（颜色、字体、箭头）、标注位置偏移，以及是否显示数值。
- [ ] **被调用方**：`chart_viewer.py`（UI 交互）、`chart_generator.py`（自动标注）

#### 4.7.3 `waveform_math.py` - 波形数学运算模块

> **设计参考**：借鉴 LTspice 的波形数学运算功能

- [ ] **职责**：对波形数据进行数学运算，支持多种运算类型
- [ ] **核心功能**：
  - `add(waveform1, waveform2)` - 波形加法
  - `subtract(waveform1, waveform2)` - 波形减法
  - `multiply(waveform1, waveform2)` - 波形乘法
  - `divide(waveform1, waveform2)` - 波形除法
  - `differentiate(waveform)` - 微分运算（d/dt）
  - `integrate(waveform)` - 积分运算
  - `abs_value(waveform)` - 绝对值
  - `db_convert(waveform)` - 转换为 dB
  - `phase_unwrap(waveform)` - 相位展开
  - `custom_expression(expression, waveforms)` - 自定义表达式运算
- [ ] **运算表达式支持**：
  - 支持类似 `V(out) - V(in)` 的表达式
  - 支持 `d(V(out))/dt` 微分表达式
  - 支持 `integ(I(R1))` 积分表达式
  - 支持 `abs(V(out))` 绝对值
  - 支持 `20*log10(abs(V(out)/V(in)))` 增益计算
- [ ] **数据对齐处理**：
  - 自动处理不同采样率的波形对齐
  - 支持插值对齐（线性、样条）
  - 处理时间/频率轴不匹配的情况
- [ ] **运算结果数据结构**：运算结果包含结果波形数据、运算表达式字符串、源波形名称列表、运算类型，以及结果单位。
- [ ] **被调用方**：`chart_viewer.py`（用户自定义运算）、`metrics_extractor.py`（指标计算）

#### 4.7.4 `simulation_result_storage.py` - 仿真结果存储服务

> **初始化顺序**：无需显式初始化，作为工具类按需实例化，依赖 file_manager（文件写入）、ResolutionPyramid（分辨率金字塔）

> **⚠️ 定位说明**：本模块仅用于持久化归档和报告生成，不作为实时数据源。所有实时数据读取必须从 GraphState 获取。

> **⚠️ 大数据存储约束**：保存仿真数据时必须同时生成分辨率金字塔，供交互式图表使用

- [ ] **职责**：管理每轮迭代的仿真数据和图表的持久化归档（仅写入，不作为实时读取源）
- [ ] **数据来源**：从 `GraphState.simulation_results` 读取数据后写入文件系统
- [ ] **禁止行为**：其他模块不得从本模块存储的文件中读取数据作为实时仿真结果
- [ ] **存储目录结构**：
  ```
  {work_folder}/simulation_results/
  ├── session_20241214_153022/       # 会话目录（时间戳标识）
  │   ├── iteration_1/
  │   │   ├── simulation_data.txt    # 仿真原始数据（文本格式，用于用户查看）
  │   │   ├── waveform_data/         # 波形二进制数据目录（新增）
  │   │   │   ├── raw_data.bin       # 原始波形数据（二进制格式）
  │   │   │   ├── pyramid_meta.json  # 金字塔元数据
  │   │   │   ├── pyramid_500.npy    # 500点分辨率层
  │   │   │   ├── pyramid_2000.npy   # 2000点分辨率层
  │   │   │   ├── pyramid_10000.npy  # 10000点分辨率层
  │   │   │   └── pyramid_50000.npy  # 50000点分辨率层
  │   │   ├── metrics.json           # 提取的性能指标
  │   │   └── charts/                # 本轮迭代的分析图表
  │   │       ├── bode_magnitude.png
  │   │       ├── bode_phase.png
  │   │       └── transient_waveform.png
  │   ├── iteration_2/
  │   │   ├── simulation_data.txt
  │   │   ├── waveform_data/
  │   │   ├── metrics.json
  │   │   └── charts/
  │   │       └── ...
  │   └── simulation_session_meta.json  # 仿真会话元信息（开始时间、设计目标摘要）
  ├── session_20241215_091530/       # 另一个会话（用户重新开始）
  │   └── ...
  └── latest/                        # 最新会话的软链接或副本
      └── ...
  ```
- [ ] **会话目录命名规则**：
  - 格式：`session_{YYYYMMDD}_{HHMMSS}`
  - 时间戳取自会话开始时刻（首次调用 LLM 或用户发送第一条消息时）
  - 同一会话内的所有迭代共享同一个会话目录
  - 用户终止后重新开始会创建新的会话目录，避免覆盖历史数据
- [ ] **核心功能**：
  - `create_session(session_id)` - 创建新会话目录，session_id 为时间戳
  - `get_current_session_path()` - 获取当前会话的存储路径
  - `save_simulation_session_meta(design_goals_summary)` - 保存仿真会话元信息
  - `save_iteration_results(iteration, sim_data, metrics, charts)` - 保存一轮迭代的完整结果（含金字塔生成）
  - `save_simulation_data(iteration, raw_data)` - 保存仿真原始数据为文本文件
  - `save_metrics(iteration, metrics)` - 保存性能指标为 JSON 文件
  - `get_iteration_path(iteration)` - 获取指定迭代的存储路径（在当前会话下）
  - `update_latest_link()` - 更新 latest 目录指向当前会话
  - `list_sessions()` - 列出所有已保存的会话
  - `list_iterations(session_id)` - 列出指定会话的所有迭代
- [ ] **分辨率金字塔生成（新增）**：
  - `save_waveform_with_pyramid(iteration, signal_name, x_data, y_data)` - 保存波形数据并生成金字塔
  - `get_waveform_pyramid_path(iteration, signal_name)` - 获取金字塔存储路径
  - **生成时机**：在 `save_iteration_results()` 中自动调用
  - **生成条件**：数据点数 > 10000 时生成金字塔，否则直接存储原始数据
  - **默认层级**：`[500, 2000, 10000, 50000]` 点
  - **依赖**：`ResolutionPyramid`（分辨率金字塔管理）
- [ ] **高级仿真结果存储**：
  - `save_pvt_results(iteration, pvt_data)` - 保存 PVT 角点仿真结果
  - `save_monte_carlo_results(iteration, mc_data)` - 保存蒙特卡洛分析结果
  - `save_parametric_sweep_results(iteration, sweep_data)` - 保存参数扫描结果
  - `get_pvt_results(iteration)` - 获取 PVT 结果
  - `get_monte_carlo_results(iteration)` - 获取蒙特卡洛结果
- [ ] **高级仿真结果目录结构**：
  ```
  iteration_N/
  ├── simulation_data.txt      # 标准仿真数据（文本格式）
  ├── waveform_data/           # 波形二进制数据（新增）
  │   ├── raw_data.bin
  │   ├── pyramid_meta.json
  │   └── pyramid_*.npy
  ├── metrics.json             # 性能指标
  ├── charts/                  # 图表目录
  ├── pvt/                     # PVT 角点结果（可选）
  │   ├── pvt_summary.json     # 角点汇总
  │   ├── corner_TT.txt        # 各角点原始数据
  │   ├── corner_FF.txt
  │   └── ...
  ├── monte_carlo/             # 蒙特卡洛结果（可选）
  │   ├── mc_summary.json      # 统计汇总
  │   ├── mc_raw_data.csv      # 原始运行数据
  │   └── histograms/          # 直方图数据
  └── sweep/                   # 参数扫描结果（可选）
      ├── sweep_config.json    # 扫描配置
      └── sweep_data.csv       # 扫描数据
  ```
- [ ] **仿真数据文件格式**（simulation_data.txt）：
  - 文本格式，便于用户查看和导入其他工具
  - 包含仿真类型、时间戳、分析参数
  - 数据以 CSV 风格组织（频率/时间 + 各节点电压/电流）
- [ ] **触发时机**：
  - 会话开始时（首次进入 `design_goals_node`），由 `design_workflow` 调用 `create_session()` 创建会话目录
  - 仿真完成后，由 `simulation_node` 调用保存原始数据和生成金字塔
  - 分析完成后，由 `analysis_node` 调用保存性能指标
  - 图表生成后，由 `chart_generator` 保存到对应迭代目录
- [ ] **会话 ID 生成规则**：
  - 格式：`YYYYMMDD_HHMMSS`（如 `20241214_153022`）
  - 由 `design_workflow` 在会话开始时生成并写入 `GraphState.session_id`
  - 后续所有迭代使用同一 session_id
- [ ] **版本管理与会话比较**：
  - **仿真会话元信息**（simulation_session_meta.json）：包含会话标识、创建和更新时间（ISO格式）、设计目标摘要、电路类型、总迭代次数、最终性能得分、终止原因，以及可选的用户标签和备注。
  - **会话比较功能**：
    - `compare_sessions(session_id_1, session_id_2)` - 比较两个会话的性能指标
    - `compare_iterations(session_id, iter_1, iter_2)` - 比较同一会话内两个迭代
    - `get_best_session(metric_name)` - 获取指定指标最优的会话
    - `export_comparison_report(session_ids, output_path)` - 导出比较报告
  - **比较结果数据结构**：包含参与比较的会话列表、各性能指标的对比（每个指标记录两个会话的值、差值和单位）、迭代次数对比、最终得分对比、优胜会话标识，以及自动生成的比较摘要文本。
  - **会话标签与搜索**：
    - `add_tag(session_id, tag)` - 为会话添加标签
    - `remove_tag(session_id, tag)` - 移除标签
    - `search_sessions(query, tags, date_range)` - 搜索会话
    - 支持按设计目标、电路类型、性能得分等条件筛选
  - **会话归档与清理**：
    - `archive_session(session_id)` - 归档会话（压缩存储）
    - `restore_session(session_id)` - 恢复归档会话
    - `delete_session(session_id)` - 删除会话（需确认）
    - `cleanup_old_sessions(days=30)` - 清理超过指定天数的会话
- [ ] **被调用方**：`design_workflow.py`（会话创建）、`simulation_node.py`、`analysis_node.py`、`chart_generator.py`、`history_dialog.py`（会话比较）

#### 4.7.5 `data_exporter.py` - 数据导出模块

> **设计参考**：借鉴 LTspice 的数据导出功能，支持多种格式导出

- [ ] **职责**：将仿真数据导出为多种标准格式，便于与其他工具交换
- [ ] **核心功能**：
  - `export_to_csv(data, signals, output_path)` - 导出为 CSV 格式
  - `export_to_matlab(data, output_path)` - 导出为 MATLAB .mat 格式
  - `export_to_numpy(data, output_path)` - 导出为 NumPy .npy 格式
  - `export_to_json(data, output_path)` - 导出为 JSON 格式
  - `export_to_touchstone(data, output_path)` - 导出为 Touchstone S 参数格式
  - `get_supported_formats()` - 获取支持的导出格式列表
- [ ] **CSV 导出格式**：
  - 首行为列标题（时间/频率 + 各信号名称）
  - 数据行按时间/频率顺序排列
  - 支持选择导出的信号子集
  - 支持设置数值精度
- [ ] **MATLAB 导出格式**：
  - 使用 scipy.io.savemat 生成 .mat 文件
  - 每个信号作为独立变量存储
  - 包含时间/频率向量
  - 包含元数据（分析类型、仿真参数）
- [ ] **导出配置选项**：支持配置导出格式、信号选择列表、数值精度、是否包含元数据，以及时间/频率范围。
- [ ] **被调用方**：`chart_viewer.py`（导出按钮）、`tool_executor.py`（响应导出工具调用）

#### 4.7.6 `report_generator.py` - PDF报告生成

> **初始化顺序**：无需显式初始化，作为工具类按需实例化，依赖 reportlab/fpdf 库、file_manager（文件写入）

- [ ] **职责**：生成完整的设计报告PDF文档
- [ ] **核心功能**：
  - `generate_report(design_goals, checkpointer, thread_id, charts, output_path)` - 生成完整报告（迭代历史从 SqliteSaver 查询）
- [ ] **报告内容**：
  1. 封面（项目名称、日期）
  2. 设计目标摘要
  3. 最终电路设计（SPICE代码）
  4. 最终性能指标
  5. 优化历史（可选）
     - 每次优化的参数变化
     - 性能变化趋势图
  6. 分析图表（可选）
  7. 结论与建议
- [ ] **依赖**：`reportlab` 或 `fpdf` 库
- [ ] **被调用方**：`tool_executor.py`（响应 `generate_design_report` 工具调用）

---

### 4.8 电路图生成子域 (`domain/simulation/schematic/`)

> **设计目标**：将 SPICE 网表文件转换为可视化的电路原理图，支持静态图片生成和交互式查看两种模式
>
> **架构设计**：采用分层架构，网表解析、布局算法、渲染器三层分离，静态导出和交互式查看共享同一套 QGraphicsScene 渲染逻辑
>
> **技术选型**：
> - 渲染引擎：统一使用 PyQt6 QGraphicsScene/QGraphicsView
> - 静态导出：复用 QGraphicsScene，通过 QImage/QSvgGenerator/QPdfWriter 导出
> - 布局算法：力导向算法为主，层次化布局为辅
>
> **设计原则**：单一渲染源，避免维护两套绘图逻辑

#### 4.8.0 电路图生成数据流图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         电路图生成数据流转路径                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  [SPICE 网表文件]                                                       │
│       │                                                                 │
│       ▼                                                                 │
│  NetlistParser.parse()                                                  │
│       │                                                                 │
│       ├──► ElementExtractor.extract()                                   │
│       │         │                                                       │
│       │         ▼                                                       │
│       │    [元件列表: SchematicElement[]]                               │
│       │                                                                 │
│       ├──► ConnectionAnalyzer.analyze()                                 │
│       │         │                                                       │
│       │         ▼                                                       │
│       │    [连接关系: SchematicConnection[]]                            │
│       │                                                                 │
│       ▼                                                                 │
│  LayoutEngine.layout()                                                  │
│       │                                                                 │
│       ├──► ForceDirectedLayout.compute()                                │
│       │         │                                                       │
│       │         ▼                                                       │
│       │    [初始布局坐标]                                                │
│       │                                                                 │
│       ├──► LayoutOptimizer.optimize()                                   │
│       │         │                                                       │
│       │         ▼                                                       │
│       │    [优化后布局: SchematicLayout]                                 │
│       │                                                                 │
│       ▼                                                                 │
│  SchematicScene.load_layout()  ◄── 统一渲染入口                         │
│       │                                                                 │
│       ├──► ElementItems 创建元件图形项                                   │
│       │                                                                 │
│       ├──► WireItem 创建连线图形项                                       │
│       │                                                                 │
│       ▼                                                                 │
│  [输出分支]                                                             │
│       │                                                                 │
│       ├─ 静态导出 ──► SchematicExporter.export()                        │
│       │                   │                                             │
│       │                   ├──► QImage (PNG)                             │
│       │                   ├──► QSvgGenerator (SVG)                      │
│       │                   └──► QPdfWriter (PDF)                         │
│       │                                                                 │
│       └─ 交互查看 ──► SchematicView.setScene()                          │
│                           │                                             │
│                           ├──► 缩放/平移/点击高亮                        │
│                           │                                             │
│                           └──► SchematicViewerPanel 集成到主窗口         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 4.8.1 电路图数据模型 (`domain/simulation/schematic/models/`)

> **设计原则**：使用 dataclass 定义标准化数据结构，作为解析、布局、渲染三层之间的数据传递载体

##### 4.8.1.1 `schematic_element.py` - 元件数据类

- [ ] **文件路径**：`domain/simulation/schematic/models/schematic_element.py`
- [ ] **职责**：定义电路元件的数据结构
- [ ] **元件类型枚举**：
  ```python
  class ElementType(Enum):
      RESISTOR = "R"           # 电阻
      CAPACITOR = "C"          # 电容
      INDUCTOR = "L"           # 电感
      VOLTAGE_SOURCE = "V"     # 电压源
      CURRENT_SOURCE = "I"     # 电流源
      DIODE = "D"              # 二极管
      BJT_NPN = "Q_NPN"        # NPN 三极管
      BJT_PNP = "Q_PNP"        # PNP 三极管
      MOSFET_N = "M_N"         # NMOS
      MOSFET_P = "M_P"         # PMOS
      OPAMP = "X_OPAMP"        # 运算放大器
      SUBCIRCUIT = "X"         # 子电路
      GROUND = "GND"           # 地
  ```
- [ ] **数据类定义**：
  - `SchematicElement` - 电路元件
    - `name: str` - 元件名称（如 R1、C2、Q3）
    - `element_type: ElementType` - 元件类型
    - `nodes: List[str]` - 连接的节点列表
    - `value: Optional[str]` - 元件值（如 10k、100n）
    - `model: Optional[str]` - 模型名称（晶体管等）
    - `parameters: Dict[str, str]` - 附加参数
    - `position: Optional[Tuple[float, float]]` - 布局后的位置坐标
    - `rotation: float` - 旋转角度（度）
    - `source_line: int` - 在网表中的行号
- [ ] **核心方法**：
  - `get_terminal_count()` - 获取端子数量
  - `get_terminal_names()` - 获取端子名称列表
  - `to_dict()` / `from_dict()` - 序列化/反序列化
- [ ] **被调用方**：`element_extractor.py`、`layout_engine.py`、`element_items.py`

##### 4.8.1.2 `schematic_connection.py` - 连接数据类

- [ ] **文件路径**：`domain/simulation/schematic/models/schematic_connection.py`
- [ ] **职责**：定义元件之间的电气连接关系
- [ ] **数据类定义**：
  - `SchematicConnection` - 电气连接
    - `node_name: str` - 节点名称
    - `connected_elements: List[Tuple[str, int]]` - 连接的元件列表（元件名, 端子索引）
    - `is_power: bool` - 是否为电源节点
    - `is_ground: bool` - 是否为地节点
    - `wire_segments: List[WireSegment]` - 布局后的连线段
  - `WireSegment` - 连线段
    - `start: Tuple[float, float]` - 起点坐标
    - `end: Tuple[float, float]` - 终点坐标
    - `is_junction: bool` - 是否为交叉点
- [ ] **核心方法**：
  - `get_connected_count()` - 获取连接的元件数量
  - `is_floating()` - 判断是否为浮空节点
- [ ] **被调用方**：`connection_analyzer.py`、`layout_engine.py`、`wire_item.py`

##### 4.8.1.3 `schematic_layout.py` - 布局结果数据类

- [ ] **文件路径**：`domain/simulation/schematic/models/schematic_layout.py`
- [ ] **职责**：定义布局计算的结果数据结构
- [ ] **数据类定义**：
  - `SchematicLayout` - 布局结果
    - `elements: List[SchematicElement]` - 带位置信息的元件列表
    - `connections: List[SchematicConnection]` - 带连线信息的连接列表
    - `bounding_box: Tuple[float, float, float, float]` - 边界框（x, y, width, height）
    - `grid_size: float` - 网格大小
    - `layout_algorithm: str` - 使用的布局算法名称
    - `layout_time_ms: float` - 布局计算耗时
- [ ] **核心方法**：
  - `get_element_by_name(name)` - 按名称获取元件
  - `get_connections_for_node(node_name)` - 获取节点的所有连接
  - `scale(factor)` - 缩放布局
  - `translate(dx, dy)` - 平移布局
- [ ] **被调用方**：`layout_engine.py`、`schematic_scene.py`、`schematic_viewer_panel.py`

#### 4.8.2 网表解析器 (`domain/simulation/schematic/parser/`)

> **设计原则**：将网表解析拆分为元件提取和连接分析两个独立步骤，便于测试和扩展

##### 4.8.2.1 `netlist_parser.py` - 网表解析门面类

- [ ] **文件路径**：`domain/simulation/schematic/parser/netlist_parser.py`
- [ ] **职责**：作为网表解析的统一入口，协调元件提取和连接分析
- [ ] **核心功能**：
  - `parse(file_path) -> Tuple[List[SchematicElement], List[SchematicConnection]]` - 解析网表文件
  - `parse_text(netlist_text) -> Tuple[List[SchematicElement], List[SchematicConnection]]` - 解析网表文本
  - `validate(file_path) -> List[str]` - 校验网表格式，返回错误列表
- [ ] **解析流程**：
  1. 读取网表文件内容
  2. 预处理：移除注释、处理续行符、展开 `.include`
  3. 委托 `ElementExtractor` 提取元件列表
  4. 委托 `ConnectionAnalyzer` 分析连接关系
  5. 返回元件列表和连接列表
- [ ] **支持的网表格式**：
  - 标准 SPICE 网表（.cir、.sp、.spice）
  - 支持 `.subckt` 子电路定义
  - 支持 `.include` 文件引用
  - 支持 `.param` 参数定义
- [ ] **被调用方**：`schematic_service.py`

##### 4.8.2.2 `element_extractor.py` - 元件提取器

- [ ] **文件路径**：`domain/simulation/schematic/parser/element_extractor.py`
- [ ] **职责**：从网表文本中提取所有电路元件
- [ ] **核心功能**：
  - `extract(lines: List[str]) -> List[SchematicElement]` - 提取元件列表
  - `parse_element_line(line, line_number) -> Optional[SchematicElement]` - 解析单行元件定义
  - `identify_element_type(name) -> ElementType` - 根据元件名识别类型
- [ ] **元件识别规则**：
  - R 开头 → 电阻
  - C 开头 → 电容
  - L 开头 → 电感
  - V 开头 → 电压源
  - I 开头 → 电流源
  - D 开头 → 二极管
  - Q 开头 → BJT（根据模型判断 NPN/PNP）
  - M 开头 → MOSFET（根据模型判断 N/P）
  - X 开头 → 子电路（根据子电路名判断是否为运放等）
- [ ] **元件值解析**：
  - 支持 SPICE 单位后缀（k、meg、g、m、u、n、p、f）
  - 支持科学计数法（1e-9）
  - 支持参数引用（{R_value}）
- [ ] **被调用方**：`netlist_parser.py`

##### 4.8.2.3 `connection_analyzer.py` - 连接关系分析器

- [ ] **文件路径**：`domain/simulation/schematic/parser/connection_analyzer.py`
- [ ] **职责**：分析元件之间的电气连接关系
- [ ] **核心功能**：
  - `analyze(elements: List[SchematicElement]) -> List[SchematicConnection]` - 分析连接关系
  - `build_node_map(elements) -> Dict[str, List[Tuple[str, int]]]` - 构建节点到元件的映射
  - `identify_special_nodes(node_map) -> Tuple[Set[str], Set[str]]` - 识别电源和地节点
- [ ] **节点识别规则**：
  - 节点 `0` 或 `gnd` → 地节点
  - 节点名包含 `vcc`、`vdd`、`vss`、`vee` → 电源节点
  - 连接到电压源正极的节点 → 可能为电源节点
- [ ] **连接分析算法**：
  1. 遍历所有元件，收集每个节点连接的元件和端子
  2. 构建节点到元件的映射表
  3. 识别特殊节点（电源、地）
  4. 生成 `SchematicConnection` 列表
- [ ] **被调用方**：`netlist_parser.py`

#### 4.8.3 布局引擎 (`domain/simulation/schematic/layout/`)

> **设计原则**：布局算法可插拔，支持多种布局策略，通过布局优化器进行后处理

##### 4.8.3.1 `layout_engine.py` - 布局引擎门面类

- [ ] **文件路径**：`domain/simulation/schematic/layout/layout_engine.py`
- [ ] **职责**：作为布局计算的统一入口，协调布局算法和优化器
- [ ] **核心功能**：
  - `layout(elements, connections, config) -> SchematicLayout` - 执行布局计算
  - `set_algorithm(algorithm_name)` - 设置布局算法
  - `get_available_algorithms()` - 获取可用的布局算法列表
- [ ] **布局配置**：
  - `algorithm: str` - 布局算法（force_directed / hierarchical）
  - `grid_size: float` - 网格大小（默认 50）
  - `min_spacing: float` - 元件最小间距（默认 100）
  - `max_iterations: int` - 最大迭代次数（默认 500）
  - `optimize: bool` - 是否进行布局优化（默认 True）
- [ ] **布局流程**：
  1. 根据配置选择布局算法
  2. 调用布局算法计算初始位置
  3. 若启用优化，调用 `LayoutOptimizer` 进行后处理
  4. 计算连线路径
  5. 返回 `SchematicLayout` 结果
- [ ] **被调用方**：`schematic_service.py`

##### 4.8.3.2 `force_directed.py` - 力导向布局算法

- [ ] **文件路径**：`domain/simulation/schematic/layout/force_directed.py`
- [ ] **职责**：使用力导向算法计算元件位置
- [ ] **核心功能**：
  - `compute(elements, connections, config) -> List[Tuple[str, float, float]]` - 计算布局
  - `initialize_positions(elements)` - 初始化元件位置
  - `compute_forces(positions, connections)` - 计算作用力
  - `update_positions(positions, forces, damping)` - 更新位置
- [ ] **力模型**：
  - **斥力**：所有元件之间存在斥力，防止重叠
    - 公式：F_repel = k_r / d²（d 为距离）
  - **引力**：有连接的元件之间存在引力，使相连元件靠近
    - 公式：F_attract = k_a * d（d 为距离）
  - **边界力**：防止元件超出画布边界
- [ ] **算法参数**：
  - `k_repel: float` - 斥力系数（默认 10000）
  - `k_attract: float` - 引力系数（默认 0.1）
  - `damping: float` - 阻尼系数（默认 0.9）
  - `convergence_threshold: float` - 收敛阈值（默认 0.1）
- [ ] **收敛判断**：
  - 所有元件位移小于阈值
  - 或达到最大迭代次数
- [ ] **被调用方**：`layout_engine.py`

##### 4.8.3.3 `hierarchical_layout.py` - 层次化布局算法

- [ ] **文件路径**：`domain/simulation/schematic/layout/hierarchical_layout.py`
- [ ] **职责**：使用层次化算法计算元件位置，适合有明确信号流向的电路
- [ ] **核心功能**：
  - `compute(elements, connections, config) -> List[Tuple[str, float, float]]` - 计算布局
  - `assign_layers(elements, connections)` - 分配层级
  - `order_within_layers(layers, connections)` - 层内排序
  - `assign_coordinates(layers)` - 分配坐标
- [ ] **层级分配规则**：
  - 输入源（电压源、电流源）→ 第一层
  - 地节点 → 最后一层
  - 其他元件根据信号流向分配层级
- [ ] **层内排序**：
  - 最小化层间连线交叉
  - 使用重心法（barycenter method）排序
- [ ] **适用场景**：
  - 放大器电路（输入→放大级→输出）
  - 滤波器电路（信号流向明确）
  - 电源电路（输入→调节→输出）
- [ ] **被调用方**：`layout_engine.py`

##### 4.8.3.4 `layout_optimizer.py` - 布局优化器

- [ ] **文件路径**：`domain/simulation/schematic/layout/layout_optimizer.py`
- [ ] **职责**：对初始布局进行后处理优化，提高可读性
- [ ] **核心功能**：
  - `optimize(layout: SchematicLayout) -> SchematicLayout` - 优化布局
  - `snap_to_grid(layout, grid_size)` - 对齐到网格
  - `minimize_wire_crossings(layout)` - 最小化连线交叉
  - `align_elements(layout)` - 对齐相关元件
  - `route_wires(layout)` - 计算连线路径
- [ ] **网格对齐**：
  - 将元件位置对齐到最近的网格点
  - 保持元件间的相对位置关系
- [ ] **连线交叉最小化**：
  - 检测连线交叉点
  - 尝试调整元件位置减少交叉
  - 必要时添加跳线标记
- [ ] **元件对齐**：
  - 串联元件水平或垂直对齐
  - 并联元件等间距排列
  - 电源和地节点放置在合适位置
- [ ] **连线路由**：
  - 使用正交路由（仅水平和垂直线段）
  - 避免连线穿过元件
  - 合并共享路径的连线
- [ ] **被调用方**：`layout_engine.py`

#### 4.8.4 渲染器 (`domain/simulation/schematic/renderer/`)

> **设计原则**：统一使用 QGraphicsScene 作为唯一渲染引擎，静态导出和交互式查看共享同一套图形项和符号库，避免维护两套绘图逻辑

##### 4.8.4.1 `symbol_library.py` - 元件符号库

> **设计说明**：元件符号使用 Qt 绘图指令（QPainter）定义，而非 SVG 文件。这是因为：
> - 电路符号需要动态调整（如端子位置、标签位置）
> - Qt 绘图指令可直接在 QGraphicsScene 中渲染，无需额外解析
> - 静态导出时可直接复用 Scene 渲染结果
> - 符号定义以 Python 代码形式存储，便于版本控制和扩展

- [ ] **文件路径**：`domain/simulation/schematic/renderer/symbol_library.py`
- [ ] **职责**：管理电路元件的符号定义，供所有渲染场景共用
- [ ] **核心功能**：
  - `get_symbol(element_type: ElementType) -> SymbolDefinition` - 获取元件符号定义
  - `get_terminal_positions(element_type) -> List[Tuple[float, float]]` - 获取端子相对位置
  - `register_custom_symbol(name, definition)` - 注册自定义符号
  - `get_symbol_size(element_type) -> Tuple[float, float]` - 获取符号尺寸
- [ ] **符号定义数据结构**：
  - `SymbolDefinition` - 符号定义
    - `element_type: ElementType` - 元件类型
    - `width: float` - 符号宽度
    - `height: float` - 符号高度
    - `terminals: List[TerminalDef]` - 端子定义列表
    - `draw_commands: List[DrawCommand]` - Qt 绘图指令列表
  - `TerminalDef` - 端子定义
    - `name: str` - 端子名称
    - `position: Tuple[float, float]` - 相对位置
    - `direction: str` - 方向（left/right/top/bottom）
  - `DrawCommand` - 绘图指令（用于 QPainter 绑定）
    - `type: str` - 指令类型（line/rect/ellipse/path/text）
    - `params: Dict` - 指令参数
- [ ] **绘图指令示例**（电阻符号）：
  ```python
  RESISTOR_SYMBOL = SymbolDefinition(
      element_type=ElementType.RESISTOR,
      width=60, height=20,
      terminals=[
          TerminalDef(name="1", position=(-30, 0), direction="left"),
          TerminalDef(name="2", position=(30, 0), direction="right"),
      ],
      draw_commands=[
          DrawCommand(type="line", params={"x1": -30, "y1": 0, "x2": -20, "y2": 0}),
          DrawCommand(type="rect", params={"x": -20, "y": -8, "w": 40, "h": 16}),
          DrawCommand(type="line", params={"x1": 20, "y1": 0, "x2": 30, "y2": 0}),
      ]
  )
  ```
- [ ] **内置符号**：
  - 基本无源元件（电阻、电容、电感）
  - 电源（电压源、电流源、地）
  - 半导体（二极管、BJT、MOSFET）
  - 集成电路（运放、比较器）
- [ ] **被调用方**：`element_items.py`、`schematic_exporter.py`

##### 4.8.4.2 `schematic_scene.py` - 电路图场景

> **核心组件**：作为统一渲染入口，静态导出和交互式查看都基于此 Scene

- [ ] **文件路径**：`domain/simulation/schematic/renderer/schematic_scene.py`
- [ ] **职责**：管理电路图的所有图形项，作为 QGraphicsScene 的子类
- [ ] **核心类**：`SchematicScene(QGraphicsScene)`
- [ ] **核心功能**：
  - `load_layout(layout: SchematicLayout)` - 从布局结果加载电路图
  - `clear_schematic()` - 清空当前电路图
  - `get_element_item(name: str) -> ElementItem` - 按名称获取元件图形项
  - `get_all_element_items() -> List[ElementItem]` - 获取所有元件图形项
  - `get_wire_items() -> List[WireItem]` - 获取所有连线图形项
  - `highlight_element(name: str)` - 高亮指定元件
  - `highlight_node(node_name: str)` - 高亮指定节点的所有连接
  - `clear_highlights()` - 清除所有高亮
  - `get_bounding_rect() -> QRectF` - 获取电路图边界矩形
- [ ] **加载流程**：
  1. 清空现有图形项
  2. 遍历 `layout.elements`，为每个元件创建 `ElementItem`
  3. 遍历 `layout.connections`，为每个连接创建 `WireItem`
  4. 设置场景边界矩形
  5. 发射 `schematic_loaded` 信号
- [ ] **信号定义**：
  - `schematic_loaded()` - 电路图加载完成
  - `element_clicked(name: str)` - 元件被点击
  - `element_hovered(name: str)` - 元件被悬停
  - `node_clicked(node_name: str)` - 节点被点击
- [ ] **图形项管理**：
  - 使用字典维护元件名到图形项的映射
  - 使用字典维护节点名到连线图形项的映射
  - 支持按名称快速查找图形项
- [ ] **被调用方**：`schematic_view.py`、`schematic_exporter.py`、`schematic_viewer_panel.py`

##### 4.8.4.3 `schematic_view.py` - 电路图视图

- [ ] **文件路径**：`domain/simulation/schematic/renderer/schematic_view.py`
- [ ] **职责**：提供电路图的可视化视图，处理缩放、平移等视图变换
- [ ] **核心类**：`SchematicView(QGraphicsView)`
- [ ] **核心功能**：
  - `set_schematic_scene(scene: SchematicScene)` - 设置电路图场景
  - `zoom_in()` - 放大视图（默认 1.25 倍）
  - `zoom_out()` - 缩小视图（默认 0.8 倍）
  - `zoom_to_fit()` - 自适应缩放以显示完整电路图
  - `reset_view()` - 重置视图到初始状态
  - `set_zoom_level(level: float)` - 设置缩放级别
  - `get_zoom_level() -> float` - 获取当前缩放级别
  - `center_on_element(name: str)` - 将视图中心移动到指定元件
- [ ] **缩放控制**：
  - 最小缩放级别：0.1（10%）
  - 最大缩放级别：10.0（1000%）
  - 缩放步进：1.25 倍
  - 缩放中心：鼠标位置或视图中心
- [ ] **鼠标交互**：
  - 滚轮缩放：Ctrl + 滚轮 或 单独滚轮
  - 拖拽平移：鼠标中键拖拽 或 空格 + 左键拖拽
  - 双击重置：双击空白区域重置视图
- [ ] **视图配置**：
  - 抗锯齿渲染：`setRenderHint(QPainter.Antialiasing)`
  - 平滑变换：`setTransformationAnchor(AnchorUnderMouse)`
  - 拖拽模式：`setDragMode(ScrollHandDrag)` 或 `NoDrag`
- [ ] **信号定义**：
  - `zoom_changed(level: float)` - 缩放级别变化
  - `view_changed()` - 视图变换变化
- [ ] **被调用方**：`schematic_viewer_panel.py`

##### 4.8.4.4 `element_items.py` - 元件图形项

- [ ] **文件路径**：`domain/simulation/schematic/renderer/element_items.py`
- [ ] **职责**：定义各类电路元件的图形项，负责元件的绘制和交互
- [ ] **基类**：`ElementItem(QGraphicsItem)`
- [ ] **基类核心功能**：
  - `__init__(element: SchematicElement, symbol: SymbolDefinition)` - 初始化
  - `boundingRect() -> QRectF` - 返回边界矩形
  - `paint(painter, option, widget)` - 绘制元件
  - `set_highlighted(enabled: bool)` - 设置高亮状态
  - `set_selected_style(enabled: bool)` - 设置选中样式
  - `get_terminal_positions() -> List[QPointF]` - 获取端子的场景坐标
  - `get_element_data() -> SchematicElement` - 获取元件数据
- [ ] **元件类型子类**：
  - `ResistorItem` - 电阻图形项（锯齿形或矩形）
  - `CapacitorItem` - 电容图形项（双平行线）
  - `InductorItem` - 电感图形项（螺旋线）
  - `VoltageSourceItem` - 电压源图形项（圆形带正负号）
  - `CurrentSourceItem` - 电流源图形项（圆形带箭头）
  - `DiodeItem` - 二极管图形项（三角形带横线）
  - `BjtItem` - BJT 图形项（带箭头的三端器件）
  - `MosfetItem` - MOSFET 图形项（带栅极的三端器件）
  - `OpampItem` - 运放图形项（三角形）
  - `GroundItem` - 地符号图形项
  - `SubcircuitItem` - 子电路图形项（矩形框）
- [ ] **绘制样式**：
  - 默认颜色：黑色 `#333333`
  - 高亮颜色：蓝色 `#2196F3`
  - 选中颜色：橙色 `#FF9800`
  - 线宽：2px（默认）、3px（高亮/选中）
  - 标签字体：10pt，元件名在上方，元件值在下方
- [ ] **交互支持**：
  - 设置 `ItemIsSelectable` 标志
  - 设置 `ItemSendsGeometryChanges` 标志
  - 重写 `hoverEnterEvent` / `hoverLeaveEvent` 处理悬停
  - 重写 `mousePressEvent` 处理点击
- [ ] **工厂方法**：
  - `create_element_item(element: SchematicElement, symbol: SymbolDefinition) -> ElementItem` - 根据元件类型创建对应的图形项
- [ ] **依赖**：`symbol_library.py`（获取符号定义）
- [ ] **被调用方**：`schematic_scene.py`

##### 4.8.4.5 `wire_item.py` - 连线图形项

- [ ] **文件路径**：`domain/simulation/schematic/renderer/wire_item.py`
- [ ] **职责**：绘制元件之间的电气连线
- [ ] **核心类**：`WireItem(QGraphicsPathItem)`
- [ ] **核心功能**：
  - `__init__(connection: SchematicConnection)` - 初始化
  - `set_path_from_segments(segments: List[WireSegment])` - 从线段列表设置路径
  - `set_highlighted(enabled: bool)` - 设置高亮状态
  - `get_node_name() -> str` - 获取节点名称
  - `get_connected_elements() -> List[str]` - 获取连接的元件名列表
- [ ] **绘制样式**：
  - 默认颜色：深灰色 `#666666`
  - 高亮颜色：蓝色 `#2196F3`
  - 电源节点颜色：红色 `#F44336`
  - 地节点颜色：绿色 `#4CAF50`
  - 线宽：1.5px（默认）、2.5px（高亮）
- [ ] **连接点绘制**：
  - 三条及以上连线交汇处绘制实心圆点（直径 6px）
  - 两条连线交汇处不绘制圆点
- [ ] **路径生成**：
  - 从 `WireSegment` 列表生成 `QPainterPath`
  - 支持正交路由（仅水平和垂直线段）
  - 支持斜线连接（可选）
- [ ] **被调用方**：`schematic_scene.py`

##### 4.8.4.6 `interaction_handler.py` - 交互处理器

- [ ] **文件路径**：`domain/simulation/schematic/renderer/interaction_handler.py`
- [ ] **职责**：协调电路图的交互逻辑，处理元件选择、高亮、信息显示等
- [ ] **核心类**：`InteractionHandler`
- [ ] **核心功能**：
  - `__init__(scene: SchematicScene, view: SchematicView)` - 初始化
  - `on_element_clicked(name: str)` - 处理元件点击事件
  - `on_element_hovered(name: str)` - 处理元件悬停事件
  - `on_node_clicked(node_name: str)` - 处理节点点击事件
  - `highlight_related_elements(name: str)` - 高亮与指定元件相连的所有元件和连线
  - `show_element_info(name: str)` - 显示元件详细信息
  - `clear_selection()` - 清除当前选择
  - `get_selected_element() -> Optional[str]` - 获取当前选中的元件名
- [ ] **高亮策略**：
  - 点击元件：高亮该元件及其所有连接的节点和连线
  - 悬停元件：临时高亮该元件（鼠标离开后恢复）
  - 点击连线：高亮该节点连接的所有元件
- [ ] **信息显示**：
  - 元件名称和类型
  - 元件值和单位
  - 连接的节点列表
  - 在网表中的行号（支持跳转到代码编辑器）
- [ ] **信号定义**：
  - `element_selected(name: str, info: dict)` - 元件被选中，携带详细信息
  - `selection_cleared()` - 选择被清除
  - `jump_to_source_requested(line: int)` - 请求跳转到源代码
- [ ] **被调用方**：`schematic_viewer_panel.py`

##### 4.8.4.7 `schematic_exporter.py` - 静态导出器

> **设计原则**：复用 SchematicScene 的渲染结果，通过 Qt 原生 API 导出为静态图片，避免维护两套绘图逻辑

- [ ] **文件路径**：`domain/simulation/schematic/renderer/schematic_exporter.py`
- [ ] **职责**：将 SchematicScene 导出为静态图片文件（PNG/SVG/PDF）
- [ ] **核心功能**：
  - `export(scene: SchematicScene, output_path: str, format: str, config: ExportConfig)` - 导出图片
  - `export_to_bytes(scene: SchematicScene, format: str, config: ExportConfig) -> bytes` - 导出为字节流
  - `get_supported_formats() -> List[str]` - 获取支持的格式列表
- [ ] **支持的输出格式**：
  - PNG - 位图格式，使用 `QImage` + `QPainter`
  - SVG - 矢量格式，使用 `QSvgGenerator` + `QPainter`
  - PDF - 打印格式，使用 `QPdfWriter` + `QPainter`
- [ ] **导出配置 `ExportConfig`**：
  - `width: int` - 输出宽度（像素，PNG）或点（SVG/PDF）
  - `height: int` - 输出高度
  - `dpi: int` - 分辨率（默认 150，仅 PNG）
  - `background_color: QColor` - 背景颜色（默认白色）
  - `margin: int` - 边距（默认 20）
  - `scale: float` - 缩放比例（默认 1.0）
- [ ] **导出流程**：
  1. 计算 Scene 边界矩形
  2. 根据配置创建目标设备（QImage/QSvgGenerator/QPdfWriter）
  3. 创建 QPainter 绑定到目标设备
  4. 调用 `scene.render(painter, target_rect, source_rect)`
  5. 保存或返回结果
- [ ] **依赖**：`PyQt6.QtSvg`（SVG 导出）、`PyQt6.QtGui`（PNG/PDF 导出）
- [ ] **被调用方**：`schematic_service.py`、`report_generator.py`

#### 4.8.5 `schematic_service.py` - 电路图服务门面类

- [ ] **文件路径**：`domain/simulation/schematic/schematic_service.py`
- [ ] **职责**：作为电路图生成功能的统一入口，协调解析、布局、渲染
- [ ] **核心功能**：
  - `generate_schematic(file_path, output_path, format, config) -> str` - 生成静态电路图
  - `get_layout(file_path, config) -> SchematicLayout` - 获取布局结果（供交互式查看器使用）
  - `create_scene(file_path, config) -> SchematicScene` - 创建已加载的 Scene（供交互式查看和静态导出共用）
  - `validate_netlist(file_path) -> List[str]` - 校验网表
  - `get_supported_formats() -> List[str]` - 获取支持的输出格式
- [ ] **生成流程**：
  1. 调用 `NetlistParser.parse()` 解析网表
  2. 调用 `LayoutEngine.layout()` 计算布局
  3. 创建 `SchematicScene` 并调用 `load_layout()` 加载图形项
  4. 调用 `SchematicExporter.export()` 导出图片
  5. 返回输出文件路径
- [ ] **缓存机制**：
  - 缓存解析结果，文件未变更时复用
  - 缓存布局结果，配置未变更时复用
  - 使用文件哈希判断是否变更
- [ ] **错误处理**：
  - 网表解析失败 → 返回详细错误信息
  - 布局计算超时 → 返回部分结果并警告
  - 导出失败 → 返回错误信息
- [ ] **被调用方**：`schematic_worker.py`、`tool_executor.py`、`report_generator.py`

---

### 4.9 仿真执行上下文 (`domain/simulation/executor/`)

> **⚠️ 核心架构决策**：仿真任务在**子进程**中执行，与主进程完全隔离。这是因为：
> - ngspice 是外部 C 程序，可能崩溃或内存泄漏，隔离后不影响主程序
> - Python 沙箱执行需要进程级隔离以确保安全
> - 仿真可能长时间运行，子进程可被安全终止

#### 4.9.0 仿真执行上下文设计

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        主进程 (Main Process)                             │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │              融合事件循环 (qasync: Qt + asyncio)                    │  │
│  │                                                                   │  │
│  │  SimulationService                                                │  │
│  │       │                                                           │  │
│  │       ├──► SpiceExecutor (PySpice NgSpiceShared 共享库模式)        │  │
│  │       │         └──► ngspice 在同一进程内执行                      │  │
│  │       │                                                           │  │
│  │       ├──► PythonExecutor (subprocess 子进程模式)  ──────────┐    │  │
│  │       │                                                      │    │  │
│  │       ├──► 等待进度事件 (EventBus)                            │    │  │
│  │       │                                                      │    │  │
│  │       └──► 读取结果文件                                       │    │  │
│  │                                                               │    │  │
│  └───────────────────────────────────────────────────────────────│────┘  │
│                                                                   │      │
└───────────────────────────────────────────────────────────────────│──────┘
                                                                    │
                                                                    │ subprocess (仅 PythonExecutor)
                                                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                   Python 脚本子进程 (仅 PythonExecutor 使用)              │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  用户自定义 Python 脚本                                           │   │
│  │                                                                   │   │
│  │  - 定义 run_simulation(config) -> dict 函数                       │   │
│  │  - 执行自定义仿真逻辑                                              │   │
│  │  - 通过 stdout 输出 JSON 格式结果                                  │   │
│  │  - 退出码：0=成功，非0=失败                                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

> **⚠️ 架构说明**：
> - **SpiceExecutor**：使用 PySpice 的 NgSpiceShared 共享库模式，ngspice 在主进程内执行，无需子进程
> - **PythonExecutor**：使用 subprocess 在子进程中执行用户脚本，提供基础进程隔离

#### 4.9.1 `simulation_task.py` - 仿真任务封装

> **执行上下文**：主进程，协程

- [ ] **文件路径**：`domain/simulation/executor/simulation_task.py`
- [ ] **职责**：封装仿真任务的启动、监控和结果收集逻辑
- [ ] **核心功能**：
  - `run_simulation_async(file_path, config) -> SimulationResult` - 异步执行仿真
    - 根据文件类型选择执行器（SpiceExecutor 或 PythonExecutor）
    - SpiceExecutor：直接调用 PySpice，同进程执行
    - PythonExecutor：通过 subprocess 启动子进程
    - 通过 `EventBus` 发布进度事件（使用 `EventThrottler` 聚合）
    - 返回仿真结果
  - `cancel()` - 取消仿真（终止子进程，仅对 PythonExecutor 有效）
- [ ] **进度事件发布**：
  ```python
  # 使用 EventThrottler 聚合高频进度更新
  throttler = EventThrottler(interval_ms=100)
  throttler.emit(SimulationEvents.SIMULATION_PROGRESS, {
      "percent": percent,
      "message": message
  })
  ```
- [ ] **超时处理**：
  - 默认超时 300 秒，可通过配置调整
  - SpiceExecutor：PySpice 内部超时机制
  - PythonExecutor：subprocess.run(timeout=...) 参数
- [ ] **被调用方**：`SimulationService`、`simulation_node.py`

#### 4.9.2 电路图生成任务

> **执行上下文**：主进程，QThreadPool（CPU 密集型）

- [ ] **文件路径**：`domain/simulation/schematic/schematic_task.py`
- [ ] **职责**：在 QThreadPool 中执行电路图布局计算和渲染
- [ ] **设计说明**：
  - 电路图生成是 CPU 密集型任务（布局算法、图形渲染）
  - 使用 `CpuTaskExecutor` 提交到 QThreadPool
  - 结果通过信号返回主线程
- [ ] **核心功能**：
  - `generate_schematic_async(file_path, config) -> SchematicResult` - 异步生成电路图
  - `cancel()` - 取消生成任务
- [ ] **被调用方**：`SchematicService`、`schematic_viewer_panel.py`

---

> **注意**：知识检索域（RAG）相关内容已移至阶段五，详见 `阶段5：RAG知识检索与代码索引.md`

### 4.10 设计管理域 (`domain/design/`)

#### 4.10.1 `design_goals.py` - 设计目标实体
- [ ] **职责**：结构化存储和管理从用户需求中提取的电路设计指标
- [ ] **数据结构 `DesignGoal`**：包含指标英文标识符（如 gain、bandwidth）、显示名称（如增益、带宽）、期望值（使用基本单位）、单位（如 dB、Hz、Ω）、约束类型（minimum/maximum/exact/range/minimize/maximize）、权重（0-1，用于综合评分）、容差百分比（可选，默认 5%）、当前实际值（仿真后填充）、是否达标标记。
- [ ] **数据结构 `DesignGoalsCollection`**：包含设计目标列表、电路类型（如 amplifier、filter）、设计需求描述、创建和更新时间、来源标识（llm 或 user）。
- [ ] **支持的指标类别**：
  - **放大器指标**：增益（gain）、带宽（bandwidth）、增益带宽积（gbw）、相位裕度（phase_margin）、增益裕度（gain_margin）、输入阻抗（input_impedance）、输出阻抗（output_impedance）、CMRR、PSRR、压摆率（slew_rate）、整定时间（settling_time）、过冲量（overshoot）、失调电压（offset_voltage）
  - **噪声指标**：输入噪声（input_noise）、积分噪声（integrated_noise）、噪声系数（noise_figure）、信噪比（snr）
  - **失真指标**：总谐波失真（thd）、THD+N、互调失真（imd）、无杂散动态范围（sfdr）、信噪失真比（sndr）、有效位数（enob）
  - **电源指标**：静态电流（quiescent_current）、功耗（power_consumption）、效率（efficiency）、负载调整率（load_regulation）、线性调整率（line_regulation）、压差（dropout_voltage）
  - **时域指标**：上升时间（rise_time）、下降时间（fall_time）、传播延迟（propagation_delay）、占空比（duty_cycle）、振荡频率（frequency）
  - **可靠性指标**：良率目标（yield_target）、温度范围（temperature_range）、电源电压范围（supply_range）
- [ ] **核心功能**：
  - `DesignGoals` 类 - 管理多个设计目标的集合
  - `add_goal(goal)` - 添加设计目标
  - `update_goal(identifier, updates)` - 更新指定目标
  - `remove_goal(identifier)` - 删除指定目标
  - `validate()` - 校验目标完整性（必填字段、值范围、权重之和）
  - `is_satisfied(actual_value, identifier)` - 判断单个指标是否达标
  - `calculate_score(actual_values)` - 计算综合达标评分（加权）
  - `update_current_values(actual_values)` - 更新所有目标的当前值和达标状态
  - `to_dict()` / `from_dict()` - 序列化/反序列化
  - `from_llm_output(llm_json)` - 从 LLM 输出的 JSON 创建实例
- [ ] **LLM 输出映射规则**：
  - LLM 输出的 `name` → `identifier`
  - LLM 输出的 `display_name` → `name`
  - 其他字段直接映射
- [ ] **持久化**：存储到 `.circuit_ai/design_goals.json`
- [ ] **被调用方**：`design_goals_node.py`（创建）、`analysis_node.py`（比对）、`termination_checker.py`（判断）、`DesignGoalsEditDialog`（编辑）

#### 4.10.2 `termination_checker.py` - 停止判断器
- [ ] **职责**：决定设计迭代循环是否应该终止
- [ ] **核心功能**：
  - `check_termination(state)` - 综合判断，返回终止原因或继续信号
  - `is_goals_satisfied(metrics, goals)` - 检查所有必需指标是否达标
  - `is_max_checkpoints_reached(count, limit)` - 检查是否达到最大检查点次数
  - `is_stagnated(history, threshold)` - 检查是否连续N次无性能提升
- [ ] **终止条件（任一满足即终止）**：
  1. 所有必需指标满足目标 → 返回 `"success"`
  2. 达到最大检查点次数（默认20次）→ 返回 `"max_checkpoints"`
  3. 连续3次无性能提升 → 返回 `"stagnated"`
  4. 用户手动停止 → 返回 `"user_stopped"`
- [ ] **停滞检测算法**：
  - 通过 `iteration_history_service.get_iteration_history()` 从 SqliteSaver 查询历史
  - 比较最近N次迭代的综合评分
  - 若评分变化小于阈值（如1%），计为停滞
  - 连续达到停滞阈值次数则判定为停滞
- [ ] **被调用方**：`edges.py`（条件边 `should_continue`）

#### 4.10.3 `undo_manager.py` - 迭代级别撤回管理器

> **撤销机制区分**：本系统存在两种不同层级的撤销机制，需明确区分：
> - **编辑器级别撤销**（Ctrl+Z）：由 `QPlainTextEdit` 内置撤销栈实现，撤销单次编辑操作，仅影响当前编辑器内容
> - **迭代级别撤回**（本模块）：恢复到之前的迭代检查点，会覆盖用户的手动编辑，将所有文件状态回滚到指定迭代时的快照

- [ ] **职责**：管理设计状态的快照，支持用户撤回到之前的迭代版本，确保多文件项目的版本一致性
- [ ] **核心功能**：
  - `create_snapshot(state, iteration_id)` - 创建完整状态快照
  - `restore_snapshot(iteration_id)` - 恢复到指定迭代的状态（**[新写法提醒]**：使用 `graph.update_state(config, values)` 来更新图状态）
  - `list_snapshots()` - 列出所有可用快照
  - `delete_snapshot(iteration_id)` - 删除指定快照
  - `get_snapshot_info(iteration_id)` - 获取快照元信息
  - `verify_snapshot_integrity(iteration_id)` - 校验快照完整性
- [ ] **快照内容（完整目录快照）**：
  ```
  .circuit_ai/undo_snapshots/{iteration_id}/
  ├── manifest.json                    # 快照元信息
  │   ├── iteration_id: int            # 迭代序号
  │   ├── timestamp: str               # 创建时间（ISO格式）
  │   ├── description: str             # 快照描述（自动生成或用户输入）
  │   ├── file_hashes: dict            # 所有文件的 SHA256 哈希
  │   └── checkpointer_thread_id: str  # 对应的 Checkpointer thread_id
  ├── state/                           # GraphState 序列化
  │   └── graph_state.json             # 完整 GraphState 导出
  ├── project_files/                   # 项目文件快照
  │   ├── main.cir                     # 主电路文件
  │   ├── parameters/                  # 参数文件目录
  │   │   └── current.cir
  │   └── subcircuits/                 # 子电路目录
  │       └── *.cir
  ├── system_files/                    # 系统文件快照
  │   └── design_goals.json            # 设计目标
  └── checkpointer_backup.sqlite3      # Checkpointer 数据库备份（可选，含迭代历史）
  ```
- [ ] **快照创建流程**（含原子性保证）：
  1. 暂停所有 Worker（防止并发写入）
  2. 创建临时快照目录 `.circuit_ai/undo_snapshots/{iteration_id}.tmp/`
  3. 导出 GraphState 到 `state/graph_state.json`
  4. 复制项目文件到 `project_files/`（保持目录结构）
  5. 复制系统文件到 `system_files/`
  6. 计算所有文件的 SHA256 哈希
  7. 生成 `manifest.json`
  8. **原子性提交**：将 `.tmp` 目录重命名为正式目录
  9. 恢复 Worker 运行
  - **失败回滚**：步骤 3-7 任一失败时，删除 `.tmp` 目录，记录日志，不影响当前状态
- [ ] **快照恢复流程**（含原子性保证）：
  1. 校验快照完整性（比对文件哈希），失败则中止并提示
  2. **用户确认**：若检测到用户有未保存的编辑，弹窗提示"恢复将覆盖当前所有修改，是否继续？"
  3. 暂停所有 Worker
  4. **创建回滚点**：备份当前状态到 `.circuit_ai/undo_snapshots/_rollback/`
  5. 从 `project_files/` 恢复项目文件（**覆盖用户的手动编辑**）
  6. 从 `system_files/` 恢复系统文件
  7. 从 `state/graph_state.json` 恢复 GraphState
  8. 同步更新 `checkpoints.sqlite3` 中的当前状态
  9. **校验恢复结果**：比对恢复后的文件哈希与 `manifest.json`
  10. 若校验通过：删除回滚点，发布 `EVENT_STATE_ITERATION_UPDATED` 事件
  11. 若校验失败：从回滚点恢复，提示用户"恢复失败，已回滚到操作前状态"
  12. 恢复 Worker 运行
  13. 刷新所有 UI 面板（编辑器重新加载文件内容，撤销栈清空）
- [ ] **与Checkpointer协同**：
  - 快照存储在 `.circuit_ai/undo_snapshots/`
  - 同时利用 LangGraph Checkpointer 的状态恢复能力
  - 恢复时同步更新 `checkpoints.sqlite3` 中的当前状态
  - 可选：备份整个 `checkpoints.sqlite3` 到快照目录
- [ ] **快照清理策略**：
  - 默认保留最近 10 个快照
  - 超过限制时删除最旧的快照
  - 用户可手动删除指定快照
  - 快照总大小超过 500MB 时提示清理
- [ ] **策略**：
  - 仅响应用户明确的撤回操作
  - 仿真失败时不自动回滚，保留当前改动继续优化
  - 每次迭代完成后自动创建快照（可配置）
- [ ] **并发安全机制**：
  - **全局操作锁**：
    - 使用 `threading.RLock` 实现可重入锁
    - 快照创建和恢复操作互斥
    - 同一时刻只能有一个快照操作在执行
    - 锁获取超时：30 秒，超时后返回错误
  - **任务协调**：
    - 快照操作前通过 `AsyncTaskRegistry.pause_all_tasks()` 暂停所有异步任务
    - 等待所有任务进入安全点（最多等待 10 秒）
    - 快照操作完成后通过 `AsyncTaskRegistry.resume_all_tasks()` 恢复
    - 若任务无法暂停，记录警告但继续执行（可能导致数据不一致）
  - **文件锁定**：
    - 快照操作期间锁定所有项目文件
    - 使用 `FileManager.acquire_project_lock()` 获取项目级锁
    - 其他模块尝试写入时会等待或失败
    - 锁定超时：60 秒
  - **状态一致性保证**：
    - 快照创建时记录 GraphState 版本号
    - 恢复时校验版本号，防止恢复到过期状态
    - 使用乐观锁机制检测并发修改
  - **并发操作检测**：UndoManager 类使用可重入锁和操作状态标志实现并发控制。创建快照时先尝试获取锁（30秒超时），获取成功后设置当前操作状态为"creating"并记录开始时间，操作完成后清除状态并释放锁。提供 is_operation_in_progress() 方法供外部查询当前是否有操作正在进行。
  - **死锁预防**：
    - 锁获取顺序固定：operation_lock → project_lock → file_locks
    - 所有锁都设置超时，避免无限等待
    - 检测到潜在死锁时记录日志并强制释放
  - **异常恢复**：
    - 快照操作异常中断时，自动清理临时文件
    - 恢复操作异常中断时，从回滚点恢复
    - 记录详细的异常日志，便于问题排查
  - **UI 状态同步**：
    - 快照操作期间禁用撤回按钮
    - 显示操作进度提示
    - 操作完成后刷新 UI 状态
- [ ] **被调用方**：`design_workflow.py`（撤回操作）、`main_window.py`（撤回按钮）

---

### 4.10.5 仿真配置对话框 (`presentation/dialogs/simulation_config/`)

> **⚠️ 核心设计原则**：仿真参数由用户通过此对话框手动设置，软件不提供"一键预设"，所有参数对用户透明可见

> **目录结构**：
> ```
> presentation/dialogs/simulation_config/
> ├── __init__.py
> ├── simulation_config_dialog.py     # 对话框主类
> ├── simulation_config_view_model.py # ViewModel 层
> ├── ac_config_tab.py                # AC 分析配置标签页
> ├── dc_config_tab.py                # DC 分析配置标签页
> ├── transient_config_tab.py         # 瞬态分析配置标签页
> ├── noise_config_tab.py             # 噪声分析配置标签页
> └── convergence_config_tab.py       # 收敛参数配置标签页
> ```

#### 4.10.5.1 `simulation_config_view_model.py` - ViewModel 层

- [ ] **文件路径**：`presentation/dialogs/simulation_config/simulation_config_view_model.py`
- [ ] **职责**：作为 UI 与 SimulationConfigService 之间的中间层，管理配置编辑状态
- [ ] **继承**：`BaseViewModel`（阶段一 1.7.2 节定义）
- [ ] **核心属性**（Qt Property）：
  - `ac_config: ACAnalysisConfig` - AC 分析配置
  - `dc_config: DCAnalysisConfig` - DC 分析配置
  - `transient_config: TransientConfig` - 瞬态分析配置
  - `noise_config: NoiseConfig` - 噪声分析配置
  - `convergence_config: ConvergenceConfig` - 收敛参数配置
  - `global_config: GlobalSimulationConfig` - 全局配置
  - `validation_errors: list[str]` - 校验错误列表
  - `is_dirty: bool` - 是否有未保存的修改
- [ ] **核心方法**：
  - `load_config()` - 从 SimulationConfigService 加载配置
  - `save_config()` - 保存配置到 SimulationConfigService
  - `validate_all() -> bool` - 校验所有配置
  - `reset_to_default()` - 重置为默认值
  - `update_ac_config(field, value)` - 更新 AC 配置字段
  - `update_dc_config(field, value)` - 更新 DC 配置字段
  - `update_transient_config(field, value)` - 更新瞬态配置字段
  - `update_noise_config(field, value)` - 更新噪声配置字段
  - `update_convergence_config(field, value)` - 更新收敛配置字段
- [ ] **信号**：
  - `config_changed` - 配置变更时发射
  - `validation_failed(errors: list[str])` - 校验失败时发射
  - `save_completed` - 保存完成时发射
- [ ] **被调用方**：`simulation_config_dialog.py`

#### 4.10.5.2 `simulation_config_dialog.py` - 对话框主类

- [ ] **文件路径**：`presentation/dialogs/simulation_config/simulation_config_dialog.py`
- [ ] **职责**：协调各配置标签页，管理对话框整体布局和按钮行为
- [ ] **核心类**：`SimulationConfigDialog(QDialog)`
- [ ] **UI 布局**：
  - 顶部：标题栏
  - 中部：QTabWidget 包含各分析类型的配置标签页
  - 底部：按钮栏（保存、重置、取消）
- [ ] **标签页组织**：
  - "AC 分析" - AC 分析参数配置
  - "DC 分析" - DC 分析参数配置
  - "瞬态分析" - 瞬态分析参数配置
  - "噪声分析" - 噪声分析参数配置
  - "收敛参数" - 全局收敛参数配置
- [ ] **核心方法**：
  - `_setup_ui()` - 初始化 UI 布局
  - `_connect_signals()` - 连接信号槽
  - `_on_save_clicked()` - 保存按钮点击处理
  - `_on_reset_clicked()` - 重置按钮点击处理
  - `_on_validation_failed(errors)` - 校验失败处理，显示错误提示
  - `retranslate_ui()` - 国际化支持
- [ ] **被调用方**：`main_window.py`（菜单项触发）

#### 4.10.5.3 `ac_config_tab.py` - AC 分析配置标签页

- [ ] **文件路径**：`presentation/dialogs/simulation_config/ac_config_tab.py`
- [ ] **职责**：提供 AC 分析参数的编辑界面
- [ ] **核心类**：`ACConfigTab(QWidget)`
- [ ] **UI 组件**：
  - 起始频率输入框（QDoubleSpinBox，支持科学计数法）
  - 终止频率输入框（QDoubleSpinBox，支持科学计数法）
  - 每十倍频程点数输入框（QSpinBox）
  - 扫描类型下拉框（QComboBox：dec/oct/lin）
  - 参数说明标签（解释各参数含义）
- [ ] **被调用方**：`simulation_config_dialog.py`

#### 4.10.5.4 `dc_config_tab.py` - DC 分析配置标签页

- [ ] **文件路径**：`presentation/dialogs/simulation_config/dc_config_tab.py`
- [ ] **职责**：提供 DC 分析参数的编辑界面
- [ ] **核心类**：`DCConfigTab(QWidget)`
- [ ] **UI 组件**：
  - 扫描源名称输入框（QLineEdit）
  - 起始值输入框（QDoubleSpinBox）
  - 终止值输入框（QDoubleSpinBox）
  - 步进值输入框（QDoubleSpinBox）
  - 参数说明标签
- [ ] **被调用方**：`simulation_config_dialog.py`

#### 4.10.5.5 `transient_config_tab.py` - 瞬态分析配置标签页

- [ ] **文件路径**：`presentation/dialogs/simulation_config/transient_config_tab.py`
- [ ] **职责**：提供瞬态分析参数的编辑界面
- [ ] **核心类**：`TransientConfigTab(QWidget)`
- [ ] **UI 组件**：
  - 时间步长输入框（QDoubleSpinBox，支持科学计数法）
  - 终止时间输入框（QDoubleSpinBox，支持科学计数法）
  - 起始时间输入框（QDoubleSpinBox）
  - 最大步长输入框（QDoubleSpinBox，可选）
  - 使用初始条件复选框（QCheckBox）
  - 参数说明标签
- [ ] **被调用方**：`simulation_config_dialog.py`

#### 4.10.5.6 `noise_config_tab.py` - 噪声分析配置标签页

- [ ] **文件路径**：`presentation/dialogs/simulation_config/noise_config_tab.py`
- [ ] **职责**：提供噪声分析参数的编辑界面
- [ ] **核心类**：`NoiseConfigTab(QWidget)`
- [ ] **UI 组件**：
  - 输出节点输入框（QLineEdit）
  - 输入源输入框（QLineEdit）
  - 起始频率输入框（QDoubleSpinBox）
  - 终止频率输入框（QDoubleSpinBox）
  - 参数说明标签
- [ ] **被调用方**：`simulation_config_dialog.py`

#### 4.10.5.7 `convergence_config_tab.py` - 收敛参数配置标签页

- [ ] **文件路径**：`presentation/dialogs/simulation_config/convergence_config_tab.py`
- [ ] **职责**：提供全局收敛参数的编辑界面
- [ ] **核心类**：`ConvergenceConfigTab(QWidget)`
- [ ] **UI 组件**：
  - gmin 输入框（QDoubleSpinBox，科学计数法，默认 1e-12）
  - abstol 输入框（QDoubleSpinBox，科学计数法，默认 1e-12）
  - reltol 输入框（QDoubleSpinBox，默认 1e-3）
  - vntol 输入框（QDoubleSpinBox，科学计数法，默认 1e-6）
  - itl1 输入框（QSpinBox，DC 迭代限制，默认 100）
  - itl4 输入框（QSpinBox，瞬态迭代限制，默认 10）
  - 超时时间输入框（QSpinBox，秒）
  - 仿真温度输入框（QDoubleSpinBox，摄氏度）
  - 参数说明标签（解释各收敛参数的作用）
- [ ] **参数说明文本**：
  - gmin：最小电导，用于避免零电导导致的矩阵奇异
  - abstol：绝对电流容差，电流误差小于此值视为收敛
  - reltol：相对容差，相对误差小于此值视为收敛
  - vntol：电压容差，电压误差小于此值视为收敛
  - itl1：DC 分析最大迭代次数
  - itl4：瞬态分析每个时间点最大迭代次数
- [ ] **被调用方**：`simulation_config_dialog.py`

---

### 4.10.6 电路图查看器面板 (`presentation/panels/schematic/`)

> **设计目标**：提供交互式电路图查看功能，支持缩放、平移、元件点击高亮，与代码编辑器联动
>
> **目录结构**：
> ```
> presentation/panels/
> ├── schematic_viewer_panel.py       # 面板主类
> └── schematic/                      # 电路图面板子模块
>     ├── __init__.py
>     ├── toolbar.py                  # 工具栏组件
>     ├── info_panel.py               # 元件信息面板
>     └── zoom_control.py             # 缩放控制组件
> ```

#### 4.10.6.1 电路图查看器面板模块组

##### 4.10.6.1.1 `presentation/panels/schematic_viewer_panel.py` - 面板主类

- [ ] **文件路径**：`presentation/panels/schematic_viewer_panel.py`
- [ ] **职责**：协调电路图查看器的各子组件，管理面板整体布局
- [ ] **核心类**：`SchematicViewerPanel(QWidget)`
- [ ] **核心功能**：
  - `load_schematic(file_path: str)` - 加载并显示电路图
  - `refresh()` - 刷新当前电路图
  - `clear()` - 清空电路图显示
  - `zoom_in()` / `zoom_out()` / `zoom_to_fit()` - 缩放控制
  - `export_image(path: str, format: str)` - 导出电路图为图片
  - `highlight_element(name: str)` - 高亮指定元件
  - `jump_to_element(name: str)` - 跳转到指定元件并居中显示
- [ ] **布局结构**：
  - 顶部工具栏：缩放按钮、适应窗口、导出、刷新
  - 中央区域：SchematicView（电路图视图）
  - 右侧信息面板（可折叠）：显示选中元件的详细信息
  - 底部状态栏：显示缩放级别、元件数量、当前文件名
- [ ] **与 schematic_service 集成**：
  - 调用 `schematic_service.get_layout()` 获取布局结果
  - 将布局结果传递给 `SchematicScene.load_layout()`
  - 使用 `schematic_worker` 异步执行布局计算
- [ ] **与代码编辑器联动**：
  - 订阅 `InteractionHandler.jump_to_source_requested` 信号
  - 发布 `EVENT_JUMP_TO_LINE` 事件，携带文件路径和行号
  - 代码编辑器订阅事件后跳转到对应行
- [ ] **事件订阅**：
  - `EVENT_FILE_OPENED` - 文件打开时检查是否为 SPICE 文件，自动加载电路图
  - `EVENT_FILE_SAVED` - 文件保存时刷新电路图
  - `EVENT_SIMULATION_COMPLETE` - 仿真完成时可选刷新电路图
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件
- [ ] **被调用方**：`main_window.py`

##### 4.10.6.1.2 `presentation/panels/schematic/toolbar.py` - 工具栏组件

- [ ] **文件路径**：`presentation/panels/schematic/toolbar.py`
- [ ] **职责**：提供电路图查看器的工具栏按钮
- [ ] **核心类**：`SchematicToolbar(QToolBar)`
- [ ] **工具栏按钮**（使用 SVG 图标，路径：`resources/icons/schematic/`）：
  - `zoom_in.svg` 放大 - 调用 `zoom_in()`
  - `zoom_out.svg` 缩小 - 调用 `zoom_out()`
  - `fit_to_window.svg` 适应窗口 - 调用 `zoom_to_fit()`
  - `reset_view.svg` 重置视图 - 调用 `reset_view()`
  - `export_image.svg` 导出图片 - 弹出保存对话框
  - `refresh.svg` 刷新 - 重新加载电路图
  - 分隔符
  - `info_panel.svg` 信息面板开关 - 切换右侧信息面板显示
- [ ] **信号定义**：
  - `zoom_in_clicked()`
  - `zoom_out_clicked()`
  - `fit_clicked()`
  - `reset_clicked()`
  - `export_clicked()`
  - `refresh_clicked()`
  - `info_panel_toggled(visible: bool)`
- [ ] **被调用方**：`schematic_viewer_panel.py`

##### 4.10.6.1.3 `presentation/panels/schematic/info_panel.py` - 元件信息面板

- [ ] **文件路径**：`presentation/panels/schematic/info_panel.py`
- [ ] **职责**：显示选中元件的详细信息
- [ ] **核心类**：`ElementInfoPanel(QWidget)`
- [ ] **核心功能**：
  - `show_element_info(element: SchematicElement)` - 显示元件信息
  - `clear()` - 清空信息显示
  - `set_collapsed(collapsed: bool)` - 设置折叠状态
- [ ] **显示内容**：
  - 元件名称（如 R1、C2、Q3）
  - 元件类型（如 电阻、电容、NPN 三极管）
  - 元件值（如 10kΩ、100nF）
  - 模型名称（如 2N2222，仅晶体管等）
  - 连接节点列表
  - 在网表中的位置（行号，可点击跳转）
  - 附加参数（如有）
- [ ] **布局**：
  - 标题：选中元件名称
  - 属性列表：使用 QFormLayout 显示键值对
  - 跳转按钮：点击跳转到代码编辑器对应行
- [ ] **视觉设计**：
  - 面板宽度：200px（可拖拽调整）
  - 背景色：`#f8f9fa`
  - 分隔线：`#e0e0e0`
- [ ] **信号定义**：
  - `jump_to_source_clicked(file_path: str, line: int)` - 跳转到源代码
- [ ] **被调用方**：`schematic_viewer_panel.py`

##### 4.10.6.1.4 `presentation/panels/schematic/zoom_control.py` - 缩放控制组件

- [ ] **文件路径**：`presentation/panels/schematic/zoom_control.py`
- [ ] **职责**：提供缩放级别显示和快速缩放控制
- [ ] **核心类**：`ZoomControl(QWidget)`
- [ ] **核心功能**：
  - `set_zoom_level(level: float)` - 设置当前缩放级别
  - `get_zoom_level() -> float` - 获取当前缩放级别
- [ ] **UI 组件**：
  - 缩放滑块：范围 10%-1000%
  - 缩放百分比显示：如 "100%"
  - 预设缩放按钮：50%、100%、200%
- [ ] **信号定义**：
  - `zoom_level_changed(level: float)` - 缩放级别变化
- [ ] **被调用方**：`schematic_viewer_panel.py`

---

### 4.11 下栏面板 (`presentation/panels/`)

> **⚠️ UI架构对齐**：本节设计遵循阶段一 1.7 节定义的 UI 层架构规范：
> - 各 ViewModel 继承自 `BaseViewModel`，遵循统一的 ViewModel 模式
> - 面板通过 `PanelManager` 注册到 BOTTOM 区域
> - 事件通过 `UIEventBridge` 桥接到 UI 层，确保主线程执行
> - 与对话面板的通信通过 EventBus，禁止直接调用

> **下栏标签页设计**：下栏面板使用 `QTabWidget` 管理多个功能标签页：
> - **仿真结果标签页**：显示仿真指标、图表、调参面板
> - **报告生成标签页**：信息收集、提示输入、报告生成控制
>
> 两个标签页功能独立，互不干扰，用户可随时切换。

> **单一职责拆分**：为避免单个文件职责过重，将下栏面板拆分为多个协作组件：
> - `bottom_panel.py` - 下栏面板主类，管理标签页切换
> - `simulation/` - 仿真结果标签页子模块
> - `report/` - 报告生成标签页子模块
>
> **目录结构**：
> ```
> presentation/panels/
> ├── bottom_panel.py                 # 下栏面板主类（QTabWidget）
> ├── simulation/                     # 仿真结果标签页子模块
> │   ├── __init__.py
> │   ├── simulation_tab.py           # 仿真结果标签页主类
> │   ├── simulation_view_model.py    # ViewModel 层
> │   ├── metrics_panel.py            # 指标显示面板
> │   ├── metric_card.py              # 单个指标卡片组件
> │   ├── chart_viewer.py             # 图表查看器
> │   ├── tuning_panel.py             # 快速调参面板
> │   └── status_indicator.py         # 状态指示器组件
> └── report/                         # 报告生成标签页子模块
>     ├── __init__.py
>     ├── report_tab.py               # 报告标签页主类
>     ├── report_view_model.py        # ViewModel 层
>     ├── info_collector_widget.py    # 信息收集区组件
>     ├── prompt_input_widget.py      # 提示输入区组件
>     ├── current_info_dialog.py      # 选择当前信息对话框
>     └── report_progress_widget.py   # 生成进度显示组件
> ```
>
> 此设计与阶段二的 `code_editor_panel` 模块组和阶段三的 `conversation_panel` 模块组保持一致的颗粒度，便于测试和维护。

#### 4.11.0 下栏面板主类 (`bottom_panel.py`)

- [ ] **文件路径**：`presentation/panels/bottom_panel.py`
- [ ] **职责**：管理下栏的标签页切换，协调仿真结果和报告生成两个功能模块
- [ ] **核心类**：`BottomPanel(QWidget)`
- [ ] **UI 结构**：
  - 使用 `QTabWidget` 管理标签页
  - 标签页1：仿真结果（`SimulationTab`）
  - 标签页2：报告生成（`ReportTab`）
- [ ] **核心功能**：
  - `switch_to_simulation()` - 切换到仿真结果标签页
  - `switch_to_report()` - 切换到报告生成标签页
  - `get_current_tab()` - 获取当前标签页类型
- [ ] **事件订阅**：
  - 订阅 `EVENT_SIMULATION_COMPLETE` 自动切换到仿真结果标签页
  - 订阅 `EVENT_REPORT_GENERATION_STARTED` 自动切换到报告标签页
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法
  - 标签页标题支持中英文切换（"仿真结果"/"Simulation Results"、"报告生成"/"Report"）
- [ ] **被调用方**：`main_window.py`

#### 4.11.1 仿真结果标签页模块组

##### 4.11.1.0 `presentation/panels/simulation/simulation_view_model.py` - ViewModel 层

- [ ] **文件路径**：`presentation/panels/simulation/simulation_view_model.py`
- [ ] **职责**：作为 UI 与仿真服务之间的中间层，隔离 simulation_tab 与 SimulationService 的直接依赖
- [ ] **继承**：`BaseViewModel`（阶段一 1.7.2 节定义）
- [ ] **核心属性**（供 UI 绑定）：
  - `current_result` - 当前仿真结果（`SimulationResult` 类型）
  - `metrics_list` - 格式化后的指标列表（`DisplayMetric` 类型）
  - `chart_paths` - 图表文件路径列表
  - `overall_score` - 综合评分（0-100）
  - `simulation_status` - 仿真状态（idle/running/complete/error）
  - `progress` - 仿真进度（0-100）
  - `error_message` - 错误信息（若有）
  - `tuning_parameters` - 可调参数列表
- [ ] **核心方法**：
  - `load_result(result)` - 加载仿真结果并转换为显示格式
  - `format_metric(metric)` - 将原始指标转换为 `DisplayMetric`
  - `request_simulation()` - 请求执行仿真
  - `cancel_simulation()` - 取消仿真
  - `export_result(format, path)` - 导出仿真结果
  - `update_tuning_parameter(name, value)` - 更新调参参数
  - `apply_tuning()` - 应用调参并重新仿真
- [ ] **事件订阅**：
  - 订阅 `EVENT_SIMULATION_STARTED` 更新状态为 running
  - 订阅 `EVENT_SIMULATION_PROGRESS` 更新进度
  - 订阅 `EVENT_SIMULATION_COMPLETE` 加载结果
  - 订阅 `EVENT_SIMULATION_ERROR` 显示错误
  - 订阅 `EVENT_SIMULATION_CANCELLED` 重置状态
- [ ] **DisplayMetric 数据结构**（UI 友好格式）：
  - `name` - 指标名称（已国际化）
  - `value` - 格式化后的数值字符串
  - `unit` - 单位
  - `target` - 目标值描述
  - `is_met` - 是否达标
  - `trend` - 趋势（up/down/stable）
  - `category` - 指标类别（gain/bandwidth/noise 等）
- [ ] **被调用方**：`simulation_tab.py`

##### 4.11.1.1 `presentation/panels/simulation/metric_card.py` - 指标卡片组件

- [ ] **文件路径**：`presentation/panels/simulation/metric_card.py`
- [ ] **职责**：专注于单个性能指标的卡片式渲染
- [ ] **核心类**：`MetricCard(QFrame)`
- [ ] **核心功能**：
  - `set_metric(name, value, unit, target, is_met)` - 设置指标数据
  - `set_highlight(enabled)` - 设置高亮状态
  - `update_status(is_met)` - 更新达标状态
- [ ] **视觉设计**：
  - 卡片背景：略深于面板背景 `#f0f4f8`
  - 圆角边框：`border-radius: 8px`
  - 指标名称：小字灰色 `#666666`
  - 指标值：大字主色 `#333333`
  - 目标值：小字显示目标范围 `#888888`
  - 达标图标：右上角，绿色勾选 `#4caf50` / 红色叉号 `#f44336`
- [ ] **被调用方**：`metrics_panel.py`

##### 4.11.1.2 `presentation/panels/simulation/metrics_panel.py` - 指标显示面板

- [ ] **文件路径**：`presentation/panels/simulation/metrics_panel.py`
- [ ] **职责**：专注于指标网格布局和综合评分显示
- [ ] **核心类**：`MetricsPanel(QWidget)`
- [ ] **核心功能**：
  - `update_metrics(metrics_list)` - 更新所有指标卡片
  - `set_overall_score(score)` - 设置综合评分
  - `clear()` - 清空所有指标
- [ ] **布局**：
  - 指标网格：2-3 列卡片布局，自适应宽度
  - 综合评分：进度条 + 百分比
- [ ] **被调用方**：`simulation_tab.py`

##### 4.11.1.3 `presentation/panels/simulation/chart_viewer.py` - 图表查看器

- [ ] **文件路径**：`presentation/panels/simulation/chart_viewer.py`
- [ ] **职责**：专注于仿真图表的显示和交互，支持双光标测量和波形运算
- [ ] **核心类**：`ChartViewer(QWidget)`
- [ ] **核心功能**：
  - `load_chart(chart_path)` - 加载图表图片
  - `set_chart_tabs(chart_types)` - 设置图表类型标签
  - `zoom_in()` / `zoom_out()` / `reset_zoom()` - 缩放控制
  - `export_chart(path)` - 导出图表
  - `export_data(format)` - 导出波形数据
- [ ] **UI组件**：
  - 图表标签栏：类似浏览器标签，显示图表类型（Bode/瞬态/噪声/频谱等）
  - 图表显示区：深色背景，图表居中显示
  - 图表工具栏：缩放、平移、重置、导出、测量、运算按钮
  - 测量信息栏：显示光标位置和测量结果
- [ ] **图表交互**：
  - 鼠标滚轮缩放
  - 拖拽平移
  - 双击重置视图
  - 右键菜单：保存图片、复制到剪贴板、导出数据
- [ ] **双光标测量功能**（借鉴 LTspice）：
  - 点击"测量"按钮进入测量模式
  - 左键点击放置第一个光标，再次点击放置第二个光标
  - 光标可拖拽调整位置
  - 自动吸附到最近的数据点
  - 测量信息栏显示：光标1坐标、光标2坐标、Δx、Δy、斜率、频率
  - 按 ESC 退出测量模式
- [ ] **波形数学运算功能**（借鉴 LTspice）：
  - 点击"运算"按钮打开运算对话框
  - 支持选择两个波形进行加减乘除运算
  - 支持单波形的微分、积分、绝对值运算
  - 支持自定义表达式输入
  - 运算结果作为新波形显示在图表中
  - 运算波形可导出
- [ ] **数据导出功能**（借鉴 LTspice）：
  - 支持导出为 CSV 格式
  - 支持导出为 MATLAB .mat 格式
  - 支持选择导出的信号子集
  - 支持设置导出的时间/频率范围
- [ ] **被调用方**：`simulation_tab.py`

##### 4.11.1.4 `presentation/panels/simulation/tuning_panel.py` - 快速调参面板

> **设计参考**：借鉴 LTspice 的实时参数调整（Tuning）功能

- [ ] **文件路径**：`presentation/panels/simulation/tuning_panel.py`
- [ ] **职责**：提供可视化的参数调整界面，支持滑块调参和实时仿真更新
- [ ] **核心类**：`TuningPanel(QWidget)`
- [ ] **核心功能**：
  - `load_parameters(param_list)` - 加载可调参数列表
  - `add_parameter_slider(param_name, min_val, max_val, current_val)` - 添加参数滑块
  - `on_parameter_changed(param_name, new_value)` - 参数变化回调
  - `apply_changes()` - 应用参数修改到电路文件
  - `reset_to_original()` - 重置为原始值
- [ ] **UI 组件**：
  - 参数列表区：显示所有可调参数，每个参数一行
  - 参数滑块：水平滑块 + 数值输入框 + 单位标签
  - 范围设置：可调整滑块的最小/最大范围
  - 步进设置：可设置调整步进值
  - 操作按钮：应用、重置、自动仿真开关
- [ ] **参数提取规则**：
  - 从 `.param` 语句中提取参数名和当前值
  - 从电阻、电容、电感元件中提取数值
  - 自动识别参数单位和合理范围
  - 支持用户自定义参数范围
- [ ] **实时仿真模式**：
  - 开启"自动仿真"开关后，参数变化自动触发仿真
  - 使用防抖动机制，参数停止变化 500ms 后触发仿真
  - 仿真完成后自动更新图表显示
  - 显示仿真进度指示器
- [ ] **参数变化记录**：
  - 记录每次参数调整的历史
  - 支持撤销/重做参数调整
  - 显示参数变化对性能指标的影响
- [ ] **与 LLM 优化的协同**：
  - 用户手动调参后，可选择"让 AI 继续优化"
  - 将用户调整作为新的起点，LLM 在此基础上继续优化
  - 记录用户调参意图，帮助 LLM 理解优化方向
- [ ] **被调用方**：`simulation_tab.py`

##### 4.11.1.5 `presentation/panels/simulation/status_indicator.py` - 状态指示器组件

- [ ] **文件路径**：`presentation/panels/simulation/status_indicator.py`
- [ ] **职责**：专注于工作流状态的可视化提示
- [ ] **核心类**：`StatusIndicator(QWidget)`
- [ ] **核心功能**：
  - `show_awaiting_confirmation(message)` - 显示等待确认状态
  - `show_running(message)` - 显示运行中状态
  - `hide()` - 隐藏状态指示器
- [ ] **状态类型**：
  - 等待确认：提示文本 + 图标，如"迭代完成，请在对话面板中选择下一步操作"
  - 运行中：进度指示器 + 提示文本，如"优化进行中，请等待本轮完成..."
- [ ] **视觉设计**：
  - 提示区背景：略深于面板背景，顶部有分隔线
  - 提示文本：居中显示，图标 + 文字
- [ ] **被调用方**：`simulation_tab.py`

##### 4.11.1.6 `presentation/panels/simulation/simulation_tab.py` - 仿真结果标签页主类

- [ ] **文件路径**：`presentation/panels/simulation/simulation_tab.py`
- [ ] **职责**：协调各子组件，管理仿真结果标签页整体布局
- [ ] **核心类**：`SimulationTab(QWidget)`
- [ ] **视觉设计**（与其他面板统一风格）：
  - 面板背景：`#f8f9fa`（浅灰白）
  - 左右分栏使用细分隔线 `#e0e0e0`
  - 指标卡片式布局：每个指标独立卡片，圆角边框
  - 达标状态：绿色勾选图标（`#4caf50`）/ 红色叉号图标（`#f44336`）
  - 图表区域：背景 `#ffffff`，图表自适应缩放
- [ ] **指标卡片样式**：
  - 卡片背景略深于面板背景
  - 指标名称：小字灰色
  - 指标值：大字主色
  - 目标值：小字显示目标范围
  - 达标图标：右上角
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法，刷新指标标签、按钮文本、图表切换标签等
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件
  - 指标名称和单位通过 `i18n_manager` 获取（如"增益"/"Gain"、"带宽"/"Bandwidth"）
- [ ] **项目切换响应**：
  - 订阅 `EVENT_STATE_PROJECT_OPENED` 事件：从新项目的 GraphState 加载仿真结果并刷新显示
  - 订阅 `EVENT_STATE_PROJECT_CLOSED` 事件：清空指标显示、图表区域、重置状态
  - 切换项目时不保留旧项目的仿真数据，确保状态隔离
- [ ] **布局结构**：面板分为左右两栏。左栏（40%宽度）显示指标卡片网格（如增益、带宽等，带达标状态图标）、综合评分进度条和查看历史按钮。右栏（60%宽度）显示图表标签栏（Bode图/瞬态图等）、图表显示区域和图表工具栏（缩放、导出等）。
- [ ] **左栏（指标与控制）**：
  - 指标网格：2-3列卡片布局，自适应宽度
  - 综合评分：进度条 + 百分比
  - `[查看历史]` 按钮 → 弹出历史记录对话框（查看优化历史，支持恢复到指定检查点）
- [ ] **高级仿真结果显示**：
  - **PVT 角点结果标签页**：显示各角点的指标对比，高亮最差角点，显示通过/失败状态
  - **蒙特卡洛结果标签页**：显示统计摘要（均值、标准差、3σ范围）、良率百分比、直方图缩略图
  - **参数扫描结果标签页**：显示扫描曲线缩略图、最优参数点标识
  - **最坏情况分析标签页**：显示最坏情况值、设计裕度、关键参数列表
  - **敏感度分析标签页**：显示龙卷风图缩略图、敏感度排名、优化建议
  - **频谱分析标签页**（借鉴 LTspice FFT 功能）：显示 FFT 频谱图、谐波分量柱状图、THD 数值
  - 标签页切换时更新右栏图表显示
  - 支持展开查看详细结果
- [ ] **迭代状态提示区**（等待用户确认时显示）：
  - 提示区背景：略深于面板背景，顶部有分隔线
  - 提示文本：居中显示，图标 + 文字，如"迭代完成，请在对话面板中选择下一步操作"
  - 订阅 `ITERATION_AWAITING_CONFIRMATION` 事件，显示提示区
  - 用户操作后隐藏提示区
  - **说明**：建议选项按钮在对话面板中以消息形式显示，此处仅显示状态提示
- [ ] **运行中状态提示**（工作流运行中显示）：
  - 进度指示器：旋转动画或进度条
  - 提示文本："优化进行中，请等待本轮完成..."
  - 所有操作按钮灰显
- [ ] **右栏（分析图像）**：
  - 图表标签栏：类似浏览器标签，显示图表类型（Bode/瞬态/噪声等）
  - 图表显示区：深色背景，图表居中显示
  - 图表工具栏：缩放、平移、重置、导出按钮
  - 无图表时显示占位提示
  - 加载 `{work_folder}/simulation_results/session_{timestamp}/charts/` 中的图表
  - 每次检查点后自动刷新显示最新仿真结果
- [ ] **图表交互**：
  - 鼠标滚轮缩放
  - 拖拽平移
  - 双击重置视图
  - 右键菜单：保存图片、复制到剪贴板
- [ ] **核心功能**：
  - `update_metrics(metrics)` - 更新指标显示
  - `load_chart(chart_path)` - 加载图表图片
  - `refresh()` - 刷新显示
  - `show_history_dialog()` - 显示历史记录对话框
- [ ] **选择性展示**：
  - 仅加载用户在工具栏勾选的图表类型
  - 基于 `GraphState.requested_charts`
- [ ] **联动**：
  - `simulation_node` 完成时自动刷新指标
  - `chart_generator` 完成时自动加载图表
  - 检查点到达时显示状态提示
- [ ] **被调用方**：`main_window.py`、`design_workflow.py`

#### 4.11.2 `history_dialog.py` - 历史记录对话框
- [ ] **职责**：展示完整的优化历史记录，支持查看详情和恢复
- [ ] **触发方式**：点击仿真结果标签页的 `[查看历史]` 按钮
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件
- [ ] **UI组件**：
  - **历史列表**：`QTableWidget`
    - 列：检查点序号、时间、综合评分、状态（完成/已撤回）
    - 行选中高亮
  - **详情区**：
    - 参数变化对比（与上一检查点）
    - 性能指标对比
    - LLM 分析反馈摘要
  - **操作按钮**：
    - `[恢复到此检查点]` - 调用 `undo_manager.restore_snapshot()`
    - `[关闭]`
- [ ] **核心功能**：
  - `load_history()` - 从 `iteration_history_service` 查询迭代历史
  - `on_checkpoint_selected(checkpoint_id)` - 选中检查点时更新详情区
  - `restore_to_checkpoint(checkpoint_id)` - 恢复到指定检查点
- [ ] **被调用方**：`simulation_tab.py`

#### 4.11.3 `select_simulation_file_dialog.py` - 选择仿真文件对话框
- [ ] **职责**：让用户从工作路径中选择要运行仿真的文件
- [ ] **触发方式**：
  - 点击工具栏 `[📂 选择运行]` 按钮（显示所有可仿真文件）
  - 自动检测到多个主电路时自动弹出（仅显示候选主电路）
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件
- [ ] **UI组件**：
  - **对话框标题**："选择仿真文件" / "Select Simulation File"
  - **文件列表**：`QListWidget`
    - 显示当前工作路径中所有可仿真文件
    - 支持的文件扩展名：从 `executor_registry.get_all_supported_extensions()` 获取
    - 默认包含：`.cir`、`.sp`、`.spice`、`.net`、`.ckt`、`.py`
    - 每项显示：文件图标 + 文件名 + 相对路径 + 执行器类型标签
    - 单选模式，点击选中
  - **文件类型过滤**（可选）：
    - 下拉框选择文件类型：全部 / SPICE 文件 / Python 脚本
    - 过滤后刷新文件列表
  - **文件预览区**（可选）：
    - 显示选中文件的前 20 行内容
    - 帮助用户确认选择正确的文件
  - **提示文本**：
    - 正常模式："请选择要运行仿真的文件"
    - 多主电路降级模式："检测到多个可能的主电路，请选择一个"
  - **操作按钮**：
    - `[运行]` - 使用选中文件执行仿真
    - `[取消]` - 关闭对话框
- [ ] **核心功能**：
  - `load_simulatable_files()` - 扫描工作路径，加载所有可仿真文件
  - `set_candidates(file_list)` - 设置候选文件列表（多主电路降级时使用）
  - `get_selected_file()` - 获取用户选中的文件路径
  - `on_file_selected(file_path)` - 文件选中时更新预览
  - `filter_by_type(file_type)` - 按文件类型过滤列表
- [ ] **多主电路降级模式**：
  - 通过 `set_candidates()` 传入候选列表时进入降级模式
  - 降级模式下仅显示候选文件，不显示全部电路文件
  - 提示文本切换为降级模式提示
- [ ] **用户引导增强**：
  - **候选文件说明**：每个候选文件显示"为什么被识别为主电路"的简要说明
    - 包含仿真控制语句（.ac/.dc/.tran）
    - 不被其他文件引用
    - 文件大小和修改时间
  - **推荐标记**：置信度最高的候选文件显示"推荐"标签
  - **帮助提示**：对话框底部显示"什么是主电路？"的帮助链接或提示文字
  - **记住选择**：可选"记住此项目的选择"复选框，下次自动使用
- [ ] **与 UI 仿真按钮集成**：
  - `[▶ 自动运行]` 按钮检测到多个主电路时，调用 `set_candidates()` 并弹出对话框
  - 用户选择后执行仿真
  - 用户取消则不执行仿真
- [ ] **被调用方**：`main_window.py`（工具栏按钮）、`design_workflow.py`（多主电路降级事件）

---

### 4.12 主窗口更新 (`presentation/`)

#### 4.12.1 `main_window.py` - 集成下栏面板与电路图查看器
- [ ] **本阶段新增**：
  - 将下栏占位替换为 `bottom_panel`（包含仿真结果和报告生成两个标签页）
  - 在中栏添加 `schematic_viewer_panel` 作为可切换的标签页（与代码编辑器并列）
  - 连接 `simulation_worker` 的信号到仿真结果标签页
  - 连接 `schematic_worker` 的信号到电路图查看器面板
  - 连接 `rag_worker` 的信号到状态栏
  - 连接报告生成相关事件到报告标签页
- [ ] **电路图查看器集成**：
  - 中栏使用 `QTabWidget` 管理代码编辑器和电路图查看器
  - 标签页：`[代码编辑器]` `[电路图]`
  - 打开 SPICE 文件时自动切换到电路图标签页（可配置）
  - 支持拖拽分离为独立窗口
- [ ] **电路图与代码编辑器联动**：
  - 订阅 `EVENT_JUMP_TO_LINE` 事件，跳转到代码编辑器对应行
  - 代码编辑器中选中元件定义行时，电路图中高亮对应元件
  - 双向同步选中状态
- [ ] **菜单栏更新**：
  - **文件菜单**：新增"导出对话记录"、"生成设计报告"、"导出波形数据"、"导出电路图"
  - **编辑菜单**：启用"撤回本次迭代"（调用 `undo_manager`，恢复到上一迭代检查点，会覆盖用户的手动编辑）
  - **视图菜单**（新增）：显示/隐藏电路图面板、显示/隐藏元件信息面板、电路图缩放（子菜单：放大、缩小、适应窗口、100%）
  - **仿真菜单**（启用）：运行仿真、停止仿真、暂停仿真、选择分析类型（子菜单）、选择图表类型（子菜单）、数据检查、快速调参模式
  - **高级分析菜单**（新增）：PVT 角点仿真、蒙特卡洛分析、参数扫描、最坏情况分析、敏感度分析
  - **知识库菜单**（启用）：索引论文文件夹、刷新代码索引、启用/禁用 RAG 检索、查看索引状态
  - **库管理菜单**（新增）：打开库管理器、导入库文件、搜索元件、管理收藏
  - **国际化**：新增菜单项文本需添加到 `i18n_manager` 文本字典
- [ ] **工具栏更新（全部启用）**：
  - `[仿真]` - 运行仿真，图标 `play.svg`
  - `[暂停]` - 暂停/恢复仿真，图标 `pause.svg`
  - `[撤回]` - 撤回本次开发，图标 `undo.svg`
  - `[图表]` - 图表选择下拉（多选），图标 `chart.svg`
  - `[电路图]` - 切换到电路图查看器，图标 `schematic.svg`
  - `[检查]` - 数据检查下拉，图标 `inspect.svg`
  - `[调参]` - 快速调参模式开关，图标 `tuning.svg`
  - `[测量]` - 波形测量模式开关，图标 `measure.svg`
  - `[导出]` - 数据导出下拉（CSV/MATLAB/PNG），图标 `export.svg`
  - `[报告]` - 生成设计报告（调用 `report_generator`），图标 `report.svg`
  - `[RAG索引]` - 触发论文索引，图标 `index.svg`
  - `[RAG模式]` - RAG检索开关（功能启用），图标 `search.svg`
  - `[库管理]` - 打开子电路库管理器，图标 `library.svg`
  - **国际化**：新增工具栏按钮和下拉菜单文本需添加到 `i18n_manager` 文本字典
- [ ] **图标规范**：
  - **存放位置**：`resources/icons/toolbar/` 目录
  - **文件格式**：SVG 矢量格式，确保高 DPI 显示清晰
  - **命名规范**：小写字母 + 下划线，如 `play.svg`、`pause.svg`
  - **尺寸规范**：设计尺寸 24x24，viewBox 设置为 `0 0 24 24`
  - **颜色规范**：使用 `currentColor` 以支持主题切换
  - **图标来源**：优先使用 Material Design Icons 或 Feather Icons
  - **图标清单**：
    ```
    resources/icons/toolbar/
    ├── play.svg          # 运行仿真
    ├── pause.svg         # 暂停仿真
    ├── stop.svg          # 停止仿真
    ├── undo.svg          # 撤回
    ├── chart.svg         # 图表
    ├── schematic.svg     # 电路图
    ├── inspect.svg       # 检查
    ├── tuning.svg        # 调参
    ├── measure.svg       # 测量
    ├── export.svg        # 导出
    ├── report.svg        # 报告
    ├── index.svg         # 索引
    ├── search.svg        # 搜索
    └── library.svg       # 库管理
    ```
- [ ] **状态栏更新**：
  - 任务状态：`仿真进行中...` / `RAG索引中...`
  - 代码索引状态：`代码索引: 同步中/完成`
  - **国际化**：状态栏文本通过 `i18n_manager.get_text()` 获取
- [ ] **异步信号处理**：
  - 统一接收 `simulation_worker`/`rag_worker` 的信号
  - `progress` → 更新状态栏进度
  - `result` → 更新仿真结果标签页
  - `error` → 显示错误提示
- [ ] **按钮忙碌态管理**：
  - 仿真期间禁用仿真按钮
  - RAG索引期间禁用索引按钮
  - 其他按钮保持可点击

---

### 4.13 代码编辑器增强 (`presentation/panels/editor/`)

> **设计参考**：借鉴 LTspice 的 SPICE 语法支持功能，增强代码编辑体验

#### 4.13.1 `spice_completer.py` - SPICE 自动补全器

- [ ] **文件路径**：`presentation/panels/editor/spice_completer.py`
- [ ] **职责**：为 SPICE 文件提供智能自动补全功能
- [ ] **核心类**：`SpiceCompleter(QCompleter)`
- [ ] **核心功能**：
  - `update_completions(text, cursor_pos)` - 根据当前输入更新补全列表
  - `get_keyword_completions(prefix)` - 获取关键词补全
  - `get_component_completions(prefix)` - 获取元件名补全
  - `get_node_completions(prefix)` - 获取节点名补全
  - `get_parameter_completions(prefix)` - 获取参数名补全
- [ ] **补全类型**：
  - SPICE 指令补全：`.ac`、`.dc`、`.tran`、`.param`、`.subckt`、`.include`、`.lib`、`.model`、`.ends`、`.end` 等
  - 分析类型补全：`dec`、`oct`、`lin`（AC 分析）、`uic`（瞬态分析）等
  - 元件前缀补全：`R`（电阻）、`C`（电容）、`L`（电感）、`Q`（BJT）、`M`（MOSFET）、`D`（二极管）、`V`（电压源）、`I`（电流源）等
  - 单位后缀补全：`k`、`meg`、`g`、`t`、`m`、`u`、`n`、`p`、`f` 等
- [ ] **上下文感知补全**：
  - 在 `.ac` 后补全分析参数（dec/oct/lin、频率范围）
  - 在 `.tran` 后补全时间参数
  - 在元件定义后补全节点名（基于当前文件已使用的节点）
  - 在 `.param` 后补全已定义的参数名
  - 在 `.include` 后补全项目中的文件路径
- [ ] **元件名和节点名提取**：
  - 解析当前文件，提取所有已定义的元件名
  - 解析当前文件，提取所有已使用的节点名
  - 解析 `.include` 引用的文件，提取子电路名
  - 缓存解析结果，文件变更时更新
- [ ] **补全触发条件**：
  - 输入 `.` 后自动触发指令补全
  - 输入字母后延迟 300ms 触发元件/节点补全
  - 按 Ctrl+Space 手动触发补全
- [ ] **被调用方**：`code_editor.py`

#### 4.13.2 `spice_linter.py` - SPICE 实时语法检查器

- [ ] **文件路径**：`presentation/panels/editor/spice_linter.py`
- [ ] **职责**：在用户输入时实时检测 SPICE 语法错误
- [ ] **核心类**：`SpiceLinter`
- [ ] **核心功能**：
  - `lint(text)` - 检查文本中的语法错误
  - `get_errors()` - 获取错误列表
  - `get_warnings()` - 获取警告列表
- [ ] **检测规则**：
  - 指令拼写错误（如 `.tarn` 应为 `.tran`）
  - 元件定义格式错误（如缺少节点、参数格式错误）
  - 未闭合的 `.subckt` / `.ends` 对
  - 未闭合的 `.control` / `.endc` 对
  - 引用的 `.include` 文件不存在
  - 未定义的参数引用
  - 节点名使用保留字（如 `0`、`gnd`）
  - 重复的元件名
- [ ] **错误信息结构**：错误信息包含行号、列号、错误类型（error/warning）、错误消息，以及修复建议（可选）。
- [ ] **错误显示方式**：
  - 错误行左侧显示红色标记
  - 警告行左侧显示黄色标记
  - 鼠标悬停显示错误详情
  - 错误列表可在底部面板显示
- [ ] **检查触发时机**：
  - 用户停止输入 500ms 后触发
  - 文件保存时触发
  - 手动触发（菜单或快捷键）
- [ ] **被调用方**：`code_editor.py`

#### 4.13.3 代码编辑器核心组件增强

- [ ] **文件路径**：`presentation/panels/editor/code_editor.py`（在阶段二基础上增强）
- [ ] **新增功能**：
  - `set_completer(completer)` - 设置自动补全器
  - `set_linter(linter)` - 设置语法检查器
  - `show_error_markers(errors)` - 显示错误标记
  - `goto_error(error_index)` - 跳转到指定错误
- [ ] **自动补全集成**：
  - 检测到 SPICE 文件时自动启用 `SpiceCompleter`
  - 补全列表以弹出菜单形式显示
  - 支持键盘导航和回车确认
  - 支持 Tab 键快速补全
- [ ] **语法检查集成**：
  - 检测到 SPICE 文件时自动启用 `SpiceLinter`
  - 错误标记显示在行号区域
  - 状态栏显示错误/警告数量
  - 支持快捷键跳转到下一个错误

---

### 4.19 跨阶段集成点说明

> **设计目标**：明确阶段四与其他阶段的接口和依赖关系，确保集成顺畅

#### 4.19.1 与阶段三（LLM 集成）的接口

- [ ] **simulation_node 与 LLM 工作流的协作**：
  - `simulation_node` 是 LangGraph 工作流中的一个节点
  - 接收 `GraphState.circuit_file_path` 作为输入
  - 调用 `SimulationService.run_simulation()` 执行仿真
  - 将结果写入 `GraphState.simulation_results` 和 `GraphState.last_metrics`
  - 仿真失败时写入 `GraphState.error_context`
- [ ] **仿真工具定义**：
  - 在 `domain/llm/tools/simulation_tools.py` 中定义仿真相关工具
  - `run_simulation` - 执行仿真
  - `run_pvt_analysis` - PVT 角点分析
  - `run_monte_carlo` - 蒙特卡洛分析
  - `generate_chart` - 生成图表
  - 工具通过 `ToolExecutor` 调用 `SimulationService`
- [ ] **仿真结果注入 Prompt**：
  - `SimulationContextCollector` 从 `GraphState.simulation_results` 收集仿真结果
  - 格式化为 LLM 可理解的文本，注入到 Prompt 中
  - 包含：分析类型、关键指标、达标状态、图表路径

#### 4.19.2 与阶段五（RAG 知识检索）的集成点

- [ ] **RAG 检索结果影响仿真配置**：
  - 当用户询问特定电路类型时，RAG 检索相关论文和设计指南
  - 检索结果中的推荐参数可作为仿真配置的参考
  - 通过 `GraphState.rag_context` 传递检索结果
- [ ] **仿真结果增强 RAG 检索**：
  - 仿真失败时，可触发 RAG 检索相关错误解决方案
  - 检索关键词：错误类型、电路拓扑、收敛问题等
  - 检索结果注入到 `fix_error_action` 的 Prompt 中

#### 4.19.3 与阶段九（统一信息展示面板）的集成细节

- [ ] **事件数据格式规范**：
  - 领域层事件只携带结构化业务数据，不包含展示文本
  - `SIMULATION_COMPLETE` 事件数据：`SimulationResult` 对象、指标字典、图表路径列表
  - `SIMULATION_ERROR` 事件数据：`SimulationError` 对象、文件路径、行号
- [ ] **格式化职责划分**：
  - 阶段四：定义数据结构和事件
  - 阶段九：`SimulationFormatter` 负责将数据格式化为展示文本
  - 阶段九：`MetricsFormatter` 负责将指标格式化为卡片内容
- [ ] **信息卡片生成流程**：
  1. 仿真完成 → 发布 `SIMULATION_COMPLETE` 事件
  2. `SimulationInfoCollector`（阶段九）订阅事件
  3. 调用 `SimulationFormatter.format_result()` 生成展示文本
  4. 创建 `InfoCard` 并添加到信息展示面板

#### 4.19.4 与阶段一（基础设施）的依赖

- [ ] **复用的基础设施模块**：
  - `EventBus` - 事件发布订阅
  - `EventThrottler` - 事件节流（仿真进度）
  - `AsyncTaskRegistry` - 异步任务注册
  - `ServiceLocator` - 服务定位
  - `ErrorHandler` - 错误处理
- [ ] **初始化顺序依赖**：
  - 阶段一基础设施必须先初始化
  - `ExecutorRegistry` 在 Phase 3.10 初始化
  - `SimulationService` 在 Phase 3.11 初始化

---

**阶段四检查点：**
- [ ] **三层分离架构**：
  - `executor_registry` 正确注册 `SpiceExecutor` 和 `PythonExecutor`
  - `simulation_service` 根据文件扩展名自动选择执行器
  - `AutoScanStrategy` 和 `ManualSelectStrategy` 正常工作
  - 两层（执行方式、文件选择）可自由组合
- [ ] **内嵌仿真引擎**：`SpiceExecutor` 可自动加载内嵌 ngspice，无需用户手动安装
- [ ] `SpiceExecutor` 可执行AC/DC/TRAN/NOISE分析
- [ ] `PythonExecutor` 可执行用户自定义 Python 仿真脚本
- [ ] `MetricsExtractor` 指标提取准确
- [ ] `chart_generator` 可生成各类图表
- [ ] `report_generator` 可生成PDF报告
- [ ] `simulation_worker` 后台仿真正常
- [ ] PDF文本提取正常
- [ ] 向量检索Top-K结果相关性高
- [ ] `rag_worker` 索引/检索正常
- [ ] 仿真结果标签页可显示指标和图表
- [ ] 报告生成标签页可收集信息并生成报告
- [ ] 检查点状态提示正常显示
- [ ] 撤回功能可用
- [ ] **历史记录对话框**：可查看完整优化历史，支持恢复到指定检查点
- [ ] **生成报告按钮**：可生成PDF设计报告
- [ ] **检查点确认功能**：每次优化完成后系统暂停，在对话面板显示建议选项，用户确认后才继续
- [ ] 设计管理域：`DesignGoals` 序列化/反序列化正常，`TerminationChecker` 判断逻辑正确
- [ ] **状态同步协调**：
  - 迭代历史从 SqliteSaver 查询，无独立 JSON 文件
  - 设计目标通过 `design_service` 读写
  - GraphState 是唯一的迭代状态源
- [ ] **仿真进程管理**：超时强制终止正常，资源清理无泄漏
- [ ] **仿真按钮功能**：
  - `[▶ 自动运行]` 按钮使用 `AutoScanStrategy` 自动检测后执行仿真
  - `[📂 选择运行]` 按钮使用 `ManualSelectStrategy` 弹出对话框选择文件
  - 检测到多个主电路时自动弹出选择对话框
  - 文件浏览器右键"运行此文件仿真"正确运行指定文件
  - 选择仿真文件对话框显示所有支持的文件类型（.cir/.sp/.spice/.py 等）
  - 根据选中文件扩展名自动选择对应执行器
- [ ] **启动流程**：仿真/RAG服务注册，所有Worker就绪
- [ ] **事件机制**：`SIM_*`/`RAG_*` 事件正常流转
- [ ] **数据流**：仿真结果 → GraphState 更新 → SessionState 投影 → 面板自动刷新
- [ ] **国际化**：下栏面板各标签页实现 `retranslate_ui()` 方法，指标名称和单位支持中英文切换
- [ ] **冷启动测试**：删除缓存后从零启动，阶段一至四的所有服务正确初始化，无循环依赖报错
- [ ] **统一信息面板集成验收**：
  - 仿真完成后 `SIMULATION_COMPLETE` 事件正确发布
  - 仿真错误时 `SIMULATION_ERROR` 事件正确发布
  - 事件数据结构符合规范（包含 result、metrics、charts 等字段）
  - 阶段九的 `SimulationInfoCollector` 能正确订阅并处理事件
- [ ] **高级仿真功能验收**：
  - PVT 角点仿真：可执行 5 个默认角点（TT/FF/SS/FS/SF），结果正确汇总，最差角点正确标识
  - 蒙特卡洛分析：可执行指定次数的随机仿真，统计结果（均值、标准差、良率）正确计算
  - 参数扫描：可执行单参数和嵌套扫描，结果数据正确组织
  - 收敛辅助：仿真失败时可诊断问题类型，提供修复建议
  - 拓扑识别：可正确识别常见电路类型（放大器、滤波器等），推荐合适的分析类型
- [ ] **扩展指标提取验收**：
  - 放大器指标：增益、带宽、GBW、相位裕度、增益裕度、CMRR、PSRR、压摆率正确提取
  - 噪声指标：输入噪声密度、积分噪声、信噪比正确计算
  - 失真指标：THD、SFDR、SNDR 正确计算
  - 功率分析指标：元件功耗、效率曲线、功耗分布正确计算
- [ ] **高级图表生成验收**：
  - 蒙特卡洛直方图、良率曲线正确生成
  - PVT 角点对比图正确生成
  - 参数扫描曲线、等高线图正确生成
  - FFT 频谱图、谐波分量柱状图正确生成
  - 功耗分布饼图、效率曲线图正确生成
  - 龙卷风图（敏感度分析）正确生成
- [ ] **最坏情况分析验收**：
  - RSS 方法计算正确
  - EVA 方法计算正确
  - 设计裕度计算正确
  - 关键参数识别正确
- [ ] **敏感度分析验收**：
  - 敏感度系数计算正确
  - 参数排名正确
  - 优化建议生成合理
- [ ] **波形测量功能验收**：
  - 双光标放置和拖拽正常
  - 测量值（Δx、Δy、斜率、频率）计算正确
  - 关键点自动检测正确（-3dB 点、过零点、峰值等）
- [ ] **波形数学运算验收**：
  - 加减乘除运算正确
  - 微分积分运算正确
  - 自定义表达式解析正确
- [ ] **数据导出功能验收**：
  - CSV 导出格式正确
  - MATLAB .mat 导出格式正确
  - 信号选择和范围设置正常
- [ ] **快速调参功能验收**：
  - 可调参数提取正确
  - 滑块调参响应正常
  - 自动仿真模式正常工作
  - 参数变化记录正确
- [ ] **子电路库管理验收**：
  - 库文件导入正常
  - 元件搜索功能正常
  - 预置库内容完整
- [ ] **SPICE 编辑器增强验收**：
  - 自动补全功能正常（指令、元件、节点、参数）
  - 实时语法检查正常
  - 错误标记显示正确

### 4.14 核心流程预集成

> **目的**：在阶段五之前验证"LLM → 仿真 → 分析"主线流程，降低最终集成风险

#### 4.14.1 主线流程集成验证
- [ ] **验证目标**：确认核心业务流程可通过 LangGraph 串联
- [ ] **验证内容**：
  - 创建包含 3-4 个业务节点的状态图
  - 节点：`llm_node`（调用 llm_worker）→ `simulation_node`（调用 simulation_worker）→ `analysis_node`（提取指标）
  - 验证 Worker 调度与状态更新的协同
  - 验证事件流转（`LLM_COMPLETE` → `SIM_STARTED` → `SIM_COMPLETE`）
- [ ] **验证范围**：
  - 使用简化的 Prompt（不含完整模板）
  - 使用简单的测试电路（如单级放大器）
  - 可作为集成测试用例保留
- [ ] **验证检查项**：
  - [ ] LLM 输出可正确解析为电路代码
  - [ ] 电路代码可触发仿真执行
  - [ ] 仿真结果可传递到分析节点
  - [ ] 分析结果可更新 GraphState
  - [ ] 整个流程的状态可通过 Checkpointer 持久化
  - [ ] UI 面板可响应状态变更事件

#### 4.14.2 迭代确认机制验证

- [ ] **验证目标**：
  - 验证 `interrupt()` 和 `Command(resume=value)` 机制可正常工作
  - 验证迭代暂停和恢复流程
- [ ] **设计**：
  - 每轮迭代完成后暂停等待用户确认
  - 用户点击"下一轮优化"后继续
- [ ] **停止条件**：
  - 所有设计目标达成
  - 达到最大检查点次数
  - 连续多次无性能提升（停滞）
  - 发生需要用户处理的错误

#### 4.14.3 工作流锁定机制
- [ ] **设计原则**：工作流运行中锁定危险操作，仅在安全检查点解锁，避免状态不一致
- [ ] **锁定状态管理**：
  - 通过 `SessionState.workflow_locked` 统一管理（由 GraphStateProjector 从 GraphState.current_node 派生）
  - 工作流启动时 → `current_node` 变为执行节点 → `workflow_locked = True`，发布 `WORKFLOW_LOCKED` 事件
  - 到达用户确认检查点时 → `current_node` 变为 "user_checkpoint" → `workflow_locked = False`，发布 `WORKFLOW_UNLOCKED` 事件
  - 用户点击"下一轮优化"时 → `current_node` 变为执行节点 → `workflow_locked = True`
  - 工作流结束时 → `current_node` 变为 "end" → `workflow_locked = False`
- [ ] **锁定时禁用的操作**：
  - 项目操作：关闭工作文件夹、切换项目（会清空当前状态，中断工作流）
  - 文件操作：手动保存文件、删除文件（可能与 LLM 的文件操作冲突）
  - 编辑操作：代码编辑器输入（可能与 LLM 修改同一文件冲突）
  - 对话操作：发送按钮禁用（但输入框可编辑，用户可预先输入内容）
  - 工作流操作：停止按钮、撤回按钮（仅在检查点可用）
  - 配置操作：修改 API 配置、切换模型（运行中切换可能导致不一致）
- [ ] **检查点时可用的操作**（`workflow_locked = False` 时）：
  - 发送消息：发送按钮启用，用户可以发送消息与 AI 对话
  - 点击建议按钮：选择系统推荐的下一步行动
  - 停止设计、撤回操作：终止或回退工作流
- [ ] **输入框特殊处理**：
  - 输入框始终可编辑，用户可随时输入和修改文本内容
  - 仅发送按钮根据锁定状态启用/禁用
  - 这样用户可以在等待 LLM 响应时预先准备下一条消息
- [ ] **始终可用的操作**：
  - 查看文件（只读模式）
  - 切换图表显示、查看优化历史
  - 缩放、滚动等 UI 交互
  - 退出程序（需确认对话框）
- [ ] **UI 响应**：
  - 各组件订阅 `WORKFLOW_LOCKED` / `WORKFLOW_UNLOCKED` 事件
  - 锁定时：按钮灰显、菜单项禁用、编辑器切换为只读模式
  - 解锁时：恢复正常操作
  - 状态栏提示："优化进行中，部分操作已暂时禁用"
  - 用户尝试被锁定操作时提示："请等待当前优化轮次完成"
- [ ] **锁定状态持久化与恢复**：
  - **持久化**：`workflow_locked` 状态由 `GraphState.current_node` 派生，随 Checkpointer 持久化
  - **启动时恢复策略**：
    ```
    1. 从 Checkpointer 加载上次的 GraphState
    2. 检查 workflow_locked 字段：
       - 若为 True → 说明上次运行中异常退出
       - 自动重置为 False（安全默认）
       - 记录日志："检测到上次运行中断，已重置锁定状态"
       - 在状态栏提示用户
    3. 检查 awaiting_user_confirmation 字段：
       - 若为 True → 恢复到等待确认状态
       - 在对话历史区追加建议选项消息
    ```
  - **强制关闭处理**：
    - 用户强制关闭程序时，锁定状态可能未正确清理
    - 下次启动时通过上述恢复策略自动修复
    - 不会导致死锁或功能不可用
  - **`interrupt()` 失败处理**：
    - 若 `user_checkpoint_node` 的 `interrupt()` 调用失败
    - 捕获异常，记录日志
    - 强制设置 `workflow_locked = False`
    - 发布 `WORKFLOW_UNLOCKED` 事件
    - 提示用户"迭代暂停失败，请手动检查状态"
- [ ] **设计优点**：
  - 统一管理，避免遗漏
  - 状态始终一致，不会出现"操作执行一半"的情况
  - 异常退出后可自动恢复，不会导致功能锁死

---



---

### 4.15 与统一信息展示面板集成

> **⚠️ 架构说明**：仿真模块的信息展示、日志查看、复制导出等功能统一由阶段九的"统一信息展示面板"（Unified Info Panel）负责。本阶段仅定义仿真事件和数据结构，不实现独立的日志服务、导出服务或日志查看器面板。

> **设计原则**：
> - 职责单一：仿真模块专注于仿真执行，信息展示由统一面板负责
> - 事件驱动：仿真模块发布结构化事件，统一面板订阅并处理
> - 格式化分离：领域层事件只携带结构化业务数据，格式化逻辑由阶段九的格式化器负责

#### 4.15.1 仿真进度数据模型

##### `simulation_progress.py` - 仿真进度数据类

- [ ] **文件路径**：`domain/simulation/models/simulation_progress.py`
- [ ] **职责**：定义仿真进度的详细数据结构
- [ ] **数据类定义**：
  - `SimulationProgressDetail` - 仿真进度详情
    - `phase: str` - 当前阶段（preparing/running/analyzing/charting）
    - `phase_progress: float` - 阶段内进度（0-100）
    - `overall_progress: float` - 总体进度（0-100）
    - `current_operation: str` - 当前操作描述
    - `elapsed_time_ms: float` - 已用时间
    - `estimated_remaining_ms: Optional[float]` - 预计剩余时间
    - `analysis_points_completed: Optional[int]` - 已完成分析点数
    - `analysis_points_total: Optional[int]` - 总分析点数
- [ ] **阶段定义**：
  - `preparing` - 准备阶段（加载文件、初始化执行器）
  - `running` - 仿真运行阶段
  - `analyzing` - 结果分析阶段（指标提取）
  - `charting` - 图表生成阶段
- [ ] **被调用方**：`SimulationService`、`SimulationInfoCollector`（阶段九）

#### 4.15.2 仿真事件数据规范

> **说明**：仿真事件已在 4.0.3 节定义，此处补充事件携带的数据规范

##### `SIMULATION_COMPLETE` 事件数据

- [ ] **事件名**：`SimulationEvents.SIMULATION_COMPLETE`
- [ ] **数据结构**：
  ```python
  {
    "result": SimulationResult,      # 仿真结果对象
    "metrics": Dict[str, Any],       # 性能指标字典（结构化数据）
    "charts": List[str],             # 图表文件路径列表
    "duration_seconds": float,       # 仿真耗时
    "analysis_type": str,            # 分析类型
    "file_path": str,                # 仿真文件路径
  }
  ```

##### `SIMULATION_ERROR` 事件数据

- [ ] **事件名**：`SimulationEvents.SIMULATION_ERROR`
- [ ] **数据结构**：
  ```python
  {
    "error": SimulationError,        # 错误对象（包含 type、message、recovery_suggestion）
    "file_path": str,                # 出错文件路径
    "line_number": int,              # 出错行号
    "context": str,                  # 错误上下文代码
  }
  ```

##### `SIMULATION_PROGRESS` 事件数据

- [ ] **事件名**：`SimulationEvents.SIMULATION_PROGRESS`
- [ ] **数据结构**：
  ```python
  {
    "progress": SimulationProgressDetail,  # 进度详情对象
  }
  ```

#### 4.15.3 统一信息面板集成点

> **集成说明**：仿真模块的输出信息将自动推送到统一信息展示面板（阶段九 9.0 节），便于用户集中查看和管理

- [ ] **仿真结果卡片**：`SimulationInfoCollector`（阶段九）订阅 `SIMULATION_COMPLETE` 事件，创建 `InfoCard`
- [ ] **性能指标卡片**：`SimulationInfoCollector` 从 `metrics` 字典创建 `InfoCard`
- [ ] **仿真错误卡片**：`SimulationInfoCollector` 订阅 `SIMULATION_ERROR` 事件，创建 `InfoCard`
- [ ] **格式化职责**：由阶段九的 `SimulationFormatter` 和 `MetricsFormatter` 负责生成展示文本
- [ ] **复制导出功能**：由统一信息面板的 `export_dialog.py` 统一提供

---

### 4.16 报告生成标签页模块组 (`presentation/panels/report/`)

> **功能概述**：报告生成功能允许用户收集项目中的各类信息（仿真结果、RAG 检索结果、文件内容等），配合自定义提示词，由 LLM 以 Agentic Loop 模式自主撰写报告。

> **与对话系统的关系**：
> - 报告生成是独立功能，不通过对话面板输入
> - 复用 `AgenticLoopController`（阶段三 3.3.2 节）执行 LLM 调用和工具执行
> - 复用 qasync 融合事件循环（阶段三 3.0 节）确保不阻塞 UI
> - 通过 `EventBus` 发布进度事件，与其他模块解耦

> **架构解耦设计**：
> - **UI 层**：`presentation/panels/report/` - 负责用户交互和显示
> - **领域层**：`domain/report/` - 负责报告生成业务逻辑
> - **应用层**：复用现有的 `AgenticLoopController` 和 `ToolExecutor`
> - 三层分离，职责清晰，便于测试和维护

#### 4.16.1 报告生成事件定义

- [ ] **文件路径**：`shared/events/report_events.py`
- [ ] **事件常量定义**：
  ```python
  class ReportEvents:
      """报告生成相关事件定义"""
      
      # 报告生成生命周期事件
      REPORT_GENERATION_STARTED = "report.generation_started"
      REPORT_GENERATION_PROGRESS = "report.generation_progress"
      REPORT_GENERATION_COMPLETE = "report.generation_complete"
      REPORT_GENERATION_ERROR = "report.generation_error"
      REPORT_GENERATION_CANCELLED = "report.generation_cancelled"
      
      # 信息收集事件
      REPORT_INFO_ADDED = "report.info_added"
      REPORT_INFO_REMOVED = "report.info_removed"
      REPORT_INFO_CLEARED = "report.info_cleared"
      
      # 工具执行事件（Agentic Loop 中）
      REPORT_TOOL_EXECUTING = "report.tool_executing"
      REPORT_TOOL_COMPLETE = "report.tool_complete"
      REPORT_FILE_CREATED = "report.file_created"
  ```
- [ ] **被调用方**：报告生成相关模块通过导入此常量类使用事件名

#### 4.16.2 报告生成 ViewModel (`report_view_model.py`)

- [ ] **文件路径**：`presentation/panels/report/report_view_model.py`
- [ ] **职责**：作为 UI 与报告生成服务之间的中间层，管理报告生成状态
- [ ] **继承**：`BaseViewModel`（阶段一 1.7.2 节定义）
- [ ] **核心属性**（供 UI 绑定）：
  - `collected_info_items` - 已收集的信息项列表（`List[InfoItem]`）
  - `user_prompt` - 用户输入的提示词
  - `generation_status` - 生成状态（idle/generating/complete/error）
  - `progress` - 生成进度（0-100）
  - `progress_message` - 当前进度描述
  - `output_dir` - 输出目录路径
  - `generated_files` - 已生成的文件列表
  - `error_message` - 错误信息（若有）
- [ ] **核心方法**：
  - `add_info_item(item)` - 添加信息项
  - `remove_info_item(item_id)` - 移除信息项
  - `clear_info_items()` - 清空所有信息项
  - `set_prompt(prompt)` - 设置用户提示词
  - `start_generation()` - 开始生成报告
  - `cancel_generation()` - 取消生成
  - `open_output_dir()` - 打开输出目录
  - `get_available_current_info()` - 获取当前可选择的信息列表
- [ ] **事件订阅**：
  - 订阅 `EVENT_REPORT_GENERATION_PROGRESS` 更新进度
  - 订阅 `EVENT_REPORT_GENERATION_COMPLETE` 更新状态
  - 订阅 `EVENT_REPORT_GENERATION_ERROR` 显示错误
  - 订阅 `EVENT_REPORT_FILE_CREATED` 更新文件列表
- [ ] **被调用方**：`report_tab.py`

#### 4.16.3 报告标签页主类 (`report_tab.py`)

- [ ] **文件路径**：`presentation/panels/report/report_tab.py`
- [ ] **职责**：协调报告生成标签页的各子组件，管理整体布局
- [ ] **核心类**：`ReportTab(QWidget)`
- [ ] **布局结构**：
  - 上半部分（60%高度）：信息收集区（`InfoCollectorWidget`）
  - 下半部分（40%高度）：提示输入区（`PromptInputWidget`）+ 操作按钮
  - 生成中时：显示进度面板（`ReportProgressWidget`）覆盖输入区域
- [ ] **核心功能**：
  - `_setup_ui()` - 初始化 UI 布局
  - `_connect_signals()` - 连接子组件信号
  - `on_generate_clicked()` - 处理生成按钮点击
  - `on_cancel_clicked()` - 处理取消按钮点击
  - `show_progress_view()` - 切换到进度显示视图
  - `show_input_view()` - 切换到输入视图
- [ ] **国际化支持**：
  - 实现 `retranslate_ui()` 方法
  - 订阅 `EVENT_LANGUAGE_CHANGED` 事件
- [ ] **被调用方**：`bottom_panel.py`

#### 4.16.4 信息收集区组件 (`info_collector_widget.py`)

- [ ] **文件路径**：`presentation/panels/report/info_collector_widget.py`
- [ ] **职责**：管理报告素材的收集，支持文件上传和当前信息选择
- [ ] **核心类**：`InfoCollectorWidget(QWidget)`
- [ ] **UI 结构**：
  - 标题栏："信息收集" / "Information Collection"
  - 操作按钮区：
    - `[上传文件]` 按钮 - 打开文件选择对话框
    - `[选择当前信息]` 按钮 - 打开当前信息选择对话框
    - `[清空]` 按钮 - 清空所有已收集信息
  - 已收集信息列表：`QListWidget`
    - 每项显示：图标 + 信息类型 + 名称/描述 + 删除按钮
    - 支持拖拽排序
    - 支持多选删除
  - 拖拽区域：支持拖拽文件到此区域上传
- [ ] **信息项类型**：
  - 上传文件：显示文件图标 + 文件名 + 文件大小
  - 仿真结果：显示图表图标 + "仿真结果" + 时间戳
  - RAG 检索结果：显示搜索图标 + "知识检索" + 查询关键词
  - 设计目标：显示目标图标 + "设计目标" + 目标摘要
  - 项目文件：显示代码图标 + 文件名 + 相对路径
- [ ] **核心功能**：
  - `add_uploaded_file(file_path)` - 添加上传的文件
  - `add_info_item(item)` - 添加信息项
  - `remove_item(item_id)` - 移除指定信息项
  - `clear_all()` - 清空所有信息项
  - `get_all_items()` - 获取所有已收集的信息项
  - `on_drop_files(file_paths)` - 处理拖拽文件
- [ ] **信号定义**：
  - `info_added(InfoItem)` - 信息项添加时发出
  - `info_removed(str)` - 信息项移除时发出（参数为 item_id）
  - `info_cleared()` - 信息清空时发出
- [ ] **被调用方**：`report_tab.py`

#### 4.16.5 选择当前信息对话框 (`current_info_dialog.py`)

- [ ] **文件路径**：`presentation/panels/report/current_info_dialog.py`
- [ ] **职责**：展示当前可用的信息（从 GraphState 和信息展示面板获取），供用户选择添加到报告素材
- [ ] **核心类**：`CurrentInfoDialog(QDialog)`
- [ ] **UI 结构**：
  - 对话框标题："选择当前信息" / "Select Current Information"
  - 信息分类标签页（`QTabWidget`）：
    - 仿真结果：显示当前仿真结果摘要，可选择添加
    - RAG 检索：显示最近的 RAG 检索结果列表
    - 设计目标：显示当前设计目标
    - 项目文件：显示项目文件树，可多选
    - 迭代历史：显示迭代历史记录列表
  - 每个标签页内：
    - 信息列表（`QListWidget` 或 `QTreeWidget`）
    - 支持多选（复选框）
    - 显示信息预览
  - 操作按钮：
    - `[添加选中]` - 将选中项添加到信息收集区
    - `[取消]` - 关闭对话框
- [ ] **信息来源**：
  - 仿真结果：从 `GraphState.simulation_results` 获取
  - RAG 检索结果：从 `GraphState.rag_context` 获取
  - 设计目标：从 `GraphState.design_goals` 获取
  - 项目文件：从 `SessionState.project_root` 扫描
  - 迭代历史：从 `iteration_history_service` 查询 SqliteSaver
- [ ] **核心功能**：
  - `load_available_info()` - 加载当前可用的信息
  - `get_selected_items()` - 获取用户选中的信息项
  - `on_tab_changed(index)` - 标签页切换时刷新内容
  - `on_item_double_clicked(item)` - 双击预览信息详情
- [ ] **国际化支持**：实现 `retranslate_ui()` 方法
- [ ] **被调用方**：`info_collector_widget.py`

#### 4.16.6 提示输入区组件 (`prompt_input_widget.py`)

- [ ] **文件路径**：`presentation/panels/report/prompt_input_widget.py`
- [ ] **职责**：提供用户输入报告生成提示词的界面
- [ ] **核心类**：`PromptInputWidget(QWidget)`
- [ ] **UI 结构**：
  - 标题栏："生成提示" / "Generation Prompt"
  - 提示词输入框：`QPlainTextEdit`
    - 占位符文本："请输入报告生成指导，如报告结构、风格、重点内容等..."
    - 支持多行输入
    - 显示字符计数
  - 预设模板下拉框（可选）：
    - "技术报告模板"
    - "设计文档模板"
    - "仿真分析报告模板"
    - "自定义"
  - 操作按钮：
    - `[生成报告]` 按钮 - 主操作按钮，醒目样式
    - `[清空]` 按钮 - 清空输入框
- [ ] **核心功能**：
  - `get_prompt()` - 获取用户输入的提示词
  - `set_prompt(text)` - 设置提示词内容
  - `clear()` - 清空输入框
  - `apply_template(template_name)` - 应用预设模板
  - `set_enabled(enabled)` - 设置输入区启用/禁用状态
- [ ] **信号定义**：
  - `prompt_changed(str)` - 提示词变化时发出
  - `generate_requested()` - 点击生成按钮时发出
- [ ] **被调用方**：`report_tab.py`

#### 4.16.7 生成进度显示组件 (`report_progress_widget.py`)

- [ ] **文件路径**：`presentation/panels/report/report_progress_widget.py`
- [ ] **职责**：显示报告生成的进度和状态
- [ ] **核心类**：`ReportProgressWidget(QWidget)`
- [ ] **UI 结构**：
  - 状态图标：旋转动画（生成中）/ 勾选（完成）/ 叉号（错误）
  - 状态文本："正在生成报告..." / "报告生成完成" / "生成失败"
  - 进度条：显示总体进度
  - 当前操作标签：显示 LLM 正在执行的操作
    - "正在分析素材..."
    - "正在撰写章节：xxx"
    - "正在创建文件：xxx.md"
  - 已生成文件列表：
    - 显示已创建的文件名
    - 点击可预览文件内容
  - 操作按钮：
    - `[取消]` 按钮 - 生成中显示
    - `[打开报告目录]` 按钮 - 完成后显示
    - `[返回]` 按钮 - 完成/错误后显示
- [ ] **核心功能**：
  - `update_progress(percent, message)` - 更新进度
  - `add_generated_file(file_path)` - 添加已生成文件
  - `show_complete()` - 显示完成状态
  - `show_error(message)` - 显示错误状态
  - `reset()` - 重置为初始状态
- [ ] **被调用方**：`report_tab.py`

---

### 4.17 报告生成领域模块 (`domain/report/`)

> **职责边界**：领域层负责报告生成的核心业务逻辑，与 UI 层解耦。

> **目录结构**：
> ```
> domain/report/
> ├── __init__.py
> ├── report_types.py              # 报告相关类型定义
> ├── report_context_builder.py    # 报告上下文构建器
> └── report_generator.py          # 报告生成控制器
> ```

#### 4.17.1 报告类型定义 (`report_types.py`)

- [ ] **文件路径**：`domain/report/report_types.py`
- [ ] **职责**：定义报告生成相关的数据类型
- [ ] **信息项类型枚举**：
  ```python
  class InfoItemType(Enum):
      UPLOADED_FILE = "uploaded_file"       # 用户上传的文件
      SIMULATION_RESULT = "simulation"      # 仿真结果
      RAG_CONTEXT = "rag"                   # RAG 检索结果
      DESIGN_GOALS = "design_goals"         # 设计目标
      PROJECT_FILE = "project_file"         # 项目文件
      ITERATION_HISTORY = "iteration"       # 迭代历史
  ```
- [ ] **信息项数据类**：
  ```python
  @dataclass
  class InfoItem:
      id: str                               # 唯一标识
      type: InfoItemType                    # 信息类型
      name: str                             # 显示名称
      description: str                      # 描述
      content: Optional[str]                # 文本内容（若可直接读取）
      file_path: Optional[str]              # 文件路径（若为文件）
      metadata: Dict[str, Any]              # 元数据
      created_at: str                       # 添加时间（ISO 格式）
  ```
- [ ] **报告上下文数据类**：
  ```python
  @dataclass
  class ReportContext:
      info_items: List[InfoItem]            # 收集的信息项列表
      user_prompt: str                      # 用户提示词
      output_dir: Path                      # 输出目录
      project_path: Path                    # 项目路径
      session_id: str                       # 会话标识
  ```
- [ ] **报告生成结果数据类**：
  ```python
  @dataclass
  class ReportGenerationResult:
      success: bool                         # 是否成功
      output_dir: Path                      # 输出目录
      generated_files: List[str]            # 生成的文件列表
      error_message: Optional[str]          # 错误信息
      duration_seconds: float               # 耗时
  ```
- [ ] **被调用方**：`report_context_builder.py`、`report_generator.py`、`report_view_model.py`

#### 4.17.2 报告上下文构建器 (`report_context_builder.py`)

- [ ] **文件路径**：`domain/report/report_context_builder.py`
- [ ] **职责**：将收集的信息项转换为 LLM 可理解的上下文格式
- [ ] **核心类**：`ReportContextBuilder`
- [ ] **核心方法**：
  - `build_context(info_items, user_prompt)` - 构建完整的报告上下文
  - `format_info_item(item)` - 格式化单个信息项为文本
  - `build_system_prompt(context)` - 构建报告生成的系统提示词
  - `estimate_token_count(context)` - 估算上下文 Token 数量
- [ ] **信息项格式化规则**：
  - 上传文件：读取文件内容，添加文件名标注
  - 仿真结果：格式化为结构化文本（指标列表、图表描述）
  - RAG 检索结果：保留原始检索片段，添加来源标注
  - 设计目标：格式化为目标列表
  - 项目文件：读取文件内容，添加路径标注
  - 迭代历史：格式化为时间线描述
- [ ] **系统提示词模板**：
  - 角色定义：专业的技术报告撰写助手
  - 任务说明：根据提供的素材撰写报告
  - 输出要求：使用 Markdown 格式，结构清晰
  - 工具使用指导：使用 `create_file` 工具创建报告文件
  - 用户提示词注入位置
- [ ] **被调用方**：`report_generator.py`

#### 4.17.3 报告生成控制器 (`report_generator.py`)

- [ ] **文件路径**：`domain/report/report_generator.py`
- [ ] **职责**：控制报告生成流程，协调 LLM 调用和工具执行
- [ ] **核心类**：`ReportGenerator`
- [ ] **依赖模块**：
  - `AgenticLoopController`（阶段三 3.3.2 节）- 执行 LLM 调用和工具循环
  - `AsyncTaskManager`（阶段三 3.0.2 节）- 异步任务管理
  - `ToolExecutor`（阶段六）- 工具执行
  - `ReportContextBuilder` - 上下文构建
  - `EventBus` - 事件发布
- [ ] **核心方法**：
  - `generate(context, callbacks)` - 异步生成报告
  - `cancel()` - 取消生成
  - `_prepare_output_dir(project_path)` - 准备输出目录
  - `_get_available_tools()` - 获取报告生成可用的工具列表
  - `_on_loop_progress(progress)` - 处理 Agentic Loop 进度回调
  - `_on_tool_executed(tool_name, result)` - 处理工具执行回调
- [ ] **可用工具**（报告生成专用，限制范围）：
  - `create_file` - 创建文件（限制在 Report 目录内）
  - `read_file` - 读取文件（用于引用项目文件内容）
  - `list_project_files` - 列出项目文件（用于了解项目结构）
  - 不提供仿真工具、修改工具，确保报告生成不会意外修改项目
- [ ] **输出目录规则**：
  - 默认目录：`{project_path}/Report/`
  - 若目录已存在，自动创建：`{project_path}/Report_{timestamp}/`
  - 所有生成的文件必须在输出目录内
- [ ] **进度事件发布**：
  - 开始时发布 `EVENT_REPORT_GENERATION_STARTED`
  - 每次工具执行后发布 `EVENT_REPORT_GENERATION_PROGRESS`
  - 每创建一个文件发布 `EVENT_REPORT_FILE_CREATED`
  - 完成时发布 `EVENT_REPORT_GENERATION_COMPLETE`
  - 错误时发布 `EVENT_REPORT_GENERATION_ERROR`
- [ ] **被调用方**：`report_view_model.py`

#### 4.17.4 报告生成 Prompt 模板

- [ ] **文件路径**：`resources/prompts/report_prompts.json`
- [ ] **模板定义**：
  - `REPORT_SYSTEM_PROMPT` - 报告生成系统提示词
  - `REPORT_TECHNICAL_TEMPLATE` - 技术报告模板提示
  - `REPORT_DESIGN_DOC_TEMPLATE` - 设计文档模板提示
  - `REPORT_SIMULATION_ANALYSIS_TEMPLATE` - 仿真分析报告模板提示
- [ ] **系统提示词要点**：
  - 角色：专业的电路设计技术报告撰写助手
  - 能力：根据提供的素材撰写结构化报告
  - 输出格式：Markdown 格式，支持标题、列表、表格、代码块
  - 工具使用：使用 `create_file` 创建报告文件，文件名应有意义
  - 报告结构建议：摘要、背景、方法、结果、结论
  - 图表引用：可引用仿真结果中的图表路径
- [ ] **模板变量**：
  - `{collected_info}` - 格式化后的收集信息
  - `{user_prompt}` - 用户的指导提示
  - `{project_name}` - 项目名称
  - `{output_dir}` - 输出目录路径
- [ ] **被调用方**：`report_context_builder.py`

---

### 4.18 阶段检查点 - 报告生成功能

#### 4.18.1 功能验证检查项

- [ ] 下栏面板标签页切换正常（仿真结果 ↔ 报告生成）
- [ ] 信息收集区可上传本地文件
- [ ] 信息收集区可拖拽文件上传
- [ ] "选择当前信息"对话框正确显示当前可用信息
- [ ] 可从对话框选择仿真结果、RAG 结果、设计目标等添加到收集区
- [ ] 已收集信息列表显示正确，支持删除
- [ ] 提示输入区可输入自定义提示词
- [ ] 预设模板可正确应用
- [ ] 点击"生成报告"后进入进度显示视图
- [ ] 进度显示正确更新
- [ ] 报告生成完成后可打开输出目录
- [ ] 取消功能可正确中断生成

#### 4.18.2 集成验证检查项

- [ ] `ReportGenerator` 正确使用 `AgenticLoopController`
- [ ] LLM 调用通过 qasync 融合循环执行，不阻塞 UI
- [ ] 工具执行限制在 Report 目录内
- [ ] 事件发布和订阅正常工作
- [ ] 报告生成不影响主对话流程
- [ ] 报告生成不影响仿真功能

#### 4.18.3 国际化验证

- [ ] 报告标签页标题支持中英文切换
- [ ] 信息收集区所有文本支持中英文
- [ ] 选择当前信息对话框支持中英文
- [ ] 提示输入区支持中英文
- [ ] 进度显示支持中英文
