## 阶段六：工具系统与执行框架 (1周)

> **目标**：实现精简的 LLM 工具定义、工具执行框架，为工作流编排提供可靠的工具调用基础

> **⚠️ 设计原则**：
> - **工具精简**：文件修改只保留 `rewrite_file` 和 `patch_file` 两个工具，不做自动降级
> - **错误反馈**：工具执行失败时返回详细错误信息，由 LLM 自行决定下一步操作
> - **职责分离**：工具层只负责执行操作并返回结果，历史对比分析由图节点层（`analysis_node`）负责

> **⚠️ 本阶段统一管理提示**：
> - 工具执行器中的文件操作必须通过 FileManager
> - 工具执行器中的仿真调用必须通过 `ProcessManager` 在子进程中执行
> - 智能搜索工具通过 FileSearchService 执行
> - 仿真结果直接返回给 LLM，历史对比由 `analysis_node` 调用 `IterationHistoryService` 完成
> - 所有错误通过 ErrorHandler 统一处理和用户提示

> **⚠️ 跨阶段依赖检查**：
> - 开始本阶段前，必须确认以下模块已正确实现并读取其源码：
>   - `infrastructure/persistence/file_manager.py` - 文件操作接口
>   - `infrastructure/file_intelligence/search/file_search_service.py` - 智能搜索接口
>   - `domain/search/unified_search_service.py` - 项目级统一搜索服务
>   - `domain/search/in_file_search_service.py` - 单文件搜索服务（分层降级策略）
>   - `domain/search/token_budget_allocator.py` - Token 预算分配器
>   - `domain/simulation/simulation_service.py` - 仿真服务接口
>   - `application/workers/simulation_worker.py` - 仿真 Worker 信号定义

---

### 6.1 工具定义模块组 (`domain/llm/tools/`)

> **目录结构**：
> ```
> domain/llm/tools/
> ├── __init__.py
> ├── tool_registry.py           # 工具注册表（Schema 定义）
> ├── tool_schemas.py            # 工具 Schema 常量定义
> └── response_parser.py         # LLM 响应解析器
> ```

#### 6.1.1 `tool_registry.py` - 工具注册表

- [ ] **文件路径**：`domain/llm/tools/tool_registry.py`
- [ ] **职责**：定义LLM可调用的工具Schema，供ToolNode使用
- [ ] **Schema格式**：遵循 OpenAI Function Calling 规范，包含 `name`、`description`、`parameters`
- [ ] **核心功能**：
  - `get_all_tools()` - 获取所有工具 Schema 列表
  - `get_tool_schema(tool_name)` - 获取指定工具的 Schema
  - `get_tools_by_category(category)` - 按类别获取工具（file/search/simulation/report）
  - `register_tool(schema)` - 动态注册新工具
- [ ] **被调用方**：`tool_node.py`（LangGraph 工具节点）、`free_work_node.py`（自由工作模式）
- [ ] **工具清单**：

##### 文件操作工具（精简为 4 个）
- [ ] `list_project_files` - 列出项目文件结构
  - 参数：`path`（相对路径）、`pattern`（过滤模式）、`include_preview`（是否包含预览）
- [ ] `read_file` - 读取文件内容（支持行号定位和语义定位）
  - 参数：
    - `path`（文件路径，必填）
    - `start_line`（起始行，可选，与 query 互斥）
    - `end_line`（结束行，可选，与 query 互斥）
    - `query`（语义查询，可选，用于在大文件中定位相关内容）
    - `max_tokens`（最大返回 Token 数，默认 2000）
  - 返回：
    - `content` - 文件内容（可能被截断）
    - `file_info` - 文件元信息（总行数、总字节数、返回 Token 数、是否截断）
    - `location` - 定位信息（使用 query 时返回匹配的行号范围）
    - `hint` - 提示信息（大文件时附加，引导 LLM 使用分段读取或 analyze_file）
  - 说明：详见 6.1.5 节 read_file 工具分层防护机制，6.1.7 节语义定位读取机制
- [ ] `rewrite_file` - 整体重写文件（≤150行时优先使用）
  - 参数：`path`（文件路径）、`content`（完整的新文件内容）
  - 说明：文件不存在时自动创建，适用于小文件或需要大幅修改的场景
- [ ] `patch_file` - 局部修改文件（大文件优先使用）
  - 参数：`path`、`search`（要查找的内容）、`replace`（替换内容）、`occurrence`（匹配第几处，默认1）、`fuzzy`（是否模糊匹配，默认False）
  - 说明：失败时返回详细错误信息，由 LLM 决定是否改用 `rewrite_file` 或重新 `read_file`

##### 智能搜索工具（统一入口）

> **⚠️ 设计原则**：对 LLM 只暴露一个统一搜索工具 `search_project`，内部自动融合精确搜索和语义搜索结果。
> 消除 LLM 在多个搜索工具之间的选择困惑。

- [ ] `search_project` - 统一项目搜索（主推工具）
  - 参数：
    - `query`（查询字符串，必填）
    - `scope`（搜索范围：code/docs/all，默认 all）
    - `max_results`（最大结果数，默认 10）
    - `token_budget`（Token 预算，默认 4000）
  - 返回：
    - `exact_matches` - 精确匹配结果列表（正则/模糊/符号匹配）
    - `semantic_matches` - 语义匹配结果列表（向量检索）
    - `token_usage` - Token 使用统计
  - 说明：内部并行调用 `FileSearchService` 和 `RetrievalService`，融合去重后返回
  - 后端实现：调用 `UnifiedSearchService.search()`（阶段五 5.0.4）
- [ ] `search_exact` - 精确搜索（快捷入口，可选）
  - 参数：`query`、`search_type`（name/content/regex/symbol）、`file_types`、`case_sensitive`
  - 说明：仅执行精确搜索，适用于 LLM 明确知道要做正则或符号搜索的场景
  - 后端实现：直接调用 `FileSearchService`（阶段二 2.2.1.1）
- [ ] `find_references` - 查找符号引用
  - 参数：`symbol_name`、`definition_file`（定义文件路径，可选）、`include_definition`（是否包含定义位置）
  - 后端实现：调用 `LocationService.find_references()`（阶段二 2.2.3.1）

##### 文件分析工具
- [ ] `analyze_file` - 分析文件结构
  - 参数：`file_path`
  - 返回：符号列表、依赖关系、结构大纲
- [ ] `get_file_summary` - 获取文件摘要
  - 参数：`file_path`、`max_tokens`
  - 返回：适合 LLM 理解的文件概述
- [ ] `get_dependencies` - 获取文件依赖
  - 参数：`file_path`、`recursive`（是否递归）
  - 返回：依赖文件列表和依赖图

##### 基础仿真工具
- [ ] `run_simulation` - 执行 SPICE 仿真
  - 参数：`file_path`（可选，未指定时自动检测）、`analysis_type`（ac/dc/tran/noise）、`parameters`（仿真参数）
- [ ] `generate_chart` - 生成分析图表
  - 参数：`chart_types`（图表类型列表）、`data_source`、`iteration`（迭代号）
- [ ] `inspect_data` - 数据检查分析
  - 参数：`analysis_type`、`observation_points`、`range`、`options`

##### 高级仿真工具
- [ ] `run_pvt_analysis` - 执行 PVT 角点仿真
  - 参数：`corners`（角点列表，默认 TT/FF/SS/FS/SF）、`analysis_type`、`generate_report`
- [ ] `run_monte_carlo` - 执行蒙特卡洛分析
  - 参数：`runs`（运行次数）、`variation_config`（参数变化配置）、`yield_target`（良率目标）
- [ ] `run_parametric_sweep` - 执行参数扫描
  - 参数：`sweep_params`（扫描参数定义）、`sweep_range`、`nested_levels`（嵌套层数）
- [ ] `run_worst_case` - 执行最坏情况分析
  - 参数：`tolerance_config`、`method`（RSS/EVA）、`target_metrics`
- [ ] `run_sensitivity` - 执行敏感度分析
  - 参数：`parameters`（参数列表）、`target_metrics`、`perturbation_ratio`
- [ ] `analyze_convergence` - 分析收敛问题
  - 参数：`error_output`、`auto_fix`（是否自动修复）

##### 数据导出工具
- [ ] `export_waveform_data` - 导出波形数据
  - 参数：`format`（csv/mat/json）、`signals`（信号列表）、`range`

##### 报告工具
- [ ] `generate_design_report` - 生成设计报告 PDF
  - 参数：`include_history`（是否包含迭代历史）、`include_charts`、`include_pvt`

##### 元器件工具（阶段十实现，此处预留接口）
- [ ] `search_component` - 搜索元器件
- [ ] `get_component_detail` - 获取元器件详情
- [ ] `check_availability` - 检查元器件可用性
- [ ] `analyze_bom` - 分析电路 BOM
- [ ] `get_spice_model` - 获取 SPICE 模型
- [ ] `recommend_component` - 推荐元器件

#### 6.1.2 `tool_schemas.py` - 工具 Schema 常量定义

- [ ] **文件路径**：`domain/llm/tools/tool_schemas.py`
- [ ] **职责**：集中定义所有工具的 Schema 常量，便于维护和复用
- [ ] **常量定义**：
  - `FILE_TOOLS` - 文件操作工具 Schema 列表
  - `SEARCH_TOOLS` - 搜索工具 Schema 列表
  - `SIMULATION_TOOLS` - 仿真工具 Schema 列表
  - `REPORT_TOOLS` - 报告工具 Schema 列表
  - `ALL_TOOLS` - 所有工具 Schema 合集
- [ ] **Schema 结构示例**：
  ```python
  PATCH_FILE_SCHEMA = {
      "name": "patch_file",
      "description": "通过搜索旧内容并替换为新内容的方式修改文件",
      "parameters": {
          "type": "object",
          "properties": {
              "path": {"type": "string", "description": "文件路径"},
              "search": {"type": "string", "description": "要查找的内容"},
              "replace": {"type": "string", "description": "替换后的内容"},
              "occurrence": {"type": "integer", "default": 1},
              "fuzzy": {"type": "boolean", "default": False}
          },
          "required": ["path", "search", "replace"]
      }
  }
  ```
- [ ] **被调用方**：`tool_registry.py`

#### 6.1.3 文件修改工具设计（双工具体系）

> **设计原则**：不做自动降级，工具执行失败时返回详细错误信息，由 LLM 自行决策下一步

##### `rewrite_file` 工具（小文件优先）
- [ ] **功能**：用新内容完全替换整个文件，文件不存在时自动创建
- [ ] **适用场景**：
  - 文件行数 ≤150 行时优先使用
  - 需要大幅修改文件结构时
  - 创建新文件时
- [ ] **参数说明**：
  - `path`：文件路径（必填）
  - `content`：完整的新文件内容（必填）
- [ ] **执行逻辑**：确保父目录存在 → 幂等性检查 → 原子性写入
- [ ] **行数阈值建议**：SPICE 文件 200 行、Python 文件 150 行、配置文件 100 行

##### `patch_file` 工具（大文件优先）
- [ ] **功能**：通过"搜索旧内容 → 替换为新内容"的方式进行局部修改
- [ ] **适用场景**：
  - 文件行数 >150 行时优先使用
  - 只需修改少量内容时（如修改参数值）
- [ ] **参数说明**：
  - `path`：文件路径（必填）
  - `search`：要查找的内容（必填，支持多行）
  - `replace`：替换后的内容（必填，支持多行）
  - `occurrence`：匹配第几处（可选，默认 1，0 表示全部替换）
  - `fuzzy`：是否启用模糊匹配（可选，默认 False）
- [ ] **执行逻辑**：读取文件 → 查找 search 内容 → 替换为 replace → 写回文件
- [ ] **模糊匹配模式**：忽略空白字符差异，使用相似度匹配（阈值 0.9）

##### 错误反馈机制（替代自动降级）
- [ ] **设计理念**：不自动降级，而是返回详细错误信息让 LLM 自行决策
- [ ] **`patch_file` 失败时的错误反馈**：
  - 搜索内容不存在 → 返回错误信息 + 文件中最相似的内容片段 + 建议"可尝试 fuzzy=True 或使用 read_file 查看文件"
  - 匹配多处但未指定 occurrence → 返回错误信息 + 所有匹配位置的行号 + 建议"请指定 occurrence 参数"
  - 文件不存在 → 返回错误信息 + 建议"请使用 rewrite_file 创建文件"
  - **文件被外部修改** → 返回错误信息 + 建议"请使用 read_file 重新读取文件内容"
- [ ] **文件外部修改冲突错误**（TOCTOU 竞态条件检测）：
  ```python
  {
    "success": False,
    "error_type": "file_modified_externally",
    "error_message": "文件在读取后被外部修改",
    "file_path": "amplifier.cir",
    "suggestions": [
      "请使用 read_file 重新读取文件内容",
      "然后基于最新内容重新生成修改方案"
    ]
  }
  ```
- [ ] **搜索内容未找到错误**：
  ```python
  {
    "success": False,
    "error_type": "search_not_found",
    "error_message": "搜索内容未找到",
    "file_path": "amplifier.cir",
    "context": {
      "searched_for": "R1 10K",
      "similar_content": "R1 10k  ; 输入电阻",  # 最相似的内容
      "similar_line": 15
    },
    "suggestions": [
      "尝试使用 fuzzy=True 进行模糊匹配",
      "使用 read_file 查看文件当前内容"
    ]
  }
  ```
- [ ] **LLM 决策流程**：LLM 根据错误信息自行选择：
  1. 使用 `patch_file(fuzzy=True)` 重试
  2. 使用 `read_file` 查看文件内容后重新构造 search
  3. 使用 `rewrite_file` 整体重写
  4. **文件被外部修改时**：使用 `read_file` 重新读取最新内容，基于新内容调整修改方案

#### 6.1.5 `read_file` 工具分层防护机制

> **设计背景**：LLM 可能尝试读取大文件（如 10MB 的网表文件），导致 Context Window 爆炸。
> 本节定义 read_file 工具的分层防护机制，确保返回给 LLM 的内容始终在可控范围内。

##### 第一层：硬性字节限制
- [ ] **检查时机**：在读取文件内容之前
- [ ] **限制阈值**：`READ_FILE_MAX_BYTES`（200KB，来自 `infrastructure/config/settings.py`）
- [ ] **超限处理**：直接拒绝读取，返回错误信息
- [ ] **错误响应结构**：
  ```python
  {
    "success": False,
    "error_type": "file_too_large",
    "error_message": "文件大小 {size}KB 超过限制（200KB）",
    "file_path": "large_netlist.cir",
    "file_info": {
      "total_bytes": 10485760,
      "total_lines": 25000  # 若可快速获取
    },
    "suggestions": [
      "使用 read_file(start_line=X, end_line=Y) 分段读取",
      "使用 analyze_file 获取文件结构概览"
    ]
  }
  ```

##### 第二层：Token 预算截断
- [ ] **检查时机**：读取文件内容之后
- [ ] **默认预算**：`max_tokens` 参数（默认 2000，来自 `READ_FILE_DEFAULT_TOKENS`）
- [ ] **截断实现**：复用 `TokenBudgetAllocator.truncate_text()` 方法
- [ ] **截断策略**：保留头部（60%）和尾部（30%），中间省略（10%用于省略标记）
- [ ] **性能保证**：使用字符数快速估算，O(1) 截断，不调用 tokenizer

##### 第三层：大文件智能提示
- [ ] **检查时机**：返回结果之前
- [ ] **提示阈值**：`LARGE_FILE_WARNING_LINES`（500 行）或 `LARGE_FILE_WARNING_BYTES`（50KB）
- [ ] **提示内容**：在返回结果中附加 `hint` 字段，引导 LLM 使用正确的工作流
- [ ] **成功响应结构**（大文件被截断时）：
  ```python
  {
    "success": True,
    "content": "...(截断后的内容)...",
    "file_info": {
      "total_lines": 2500,
      "total_bytes": 102400,
      "returned_tokens": 2000,
      "truncated": True
    },
    "hint": "文件较大（2500行），已截断。可使用 read_file(start_line=X, end_line=Y) 分段读取，或使用 analyze_file 获取文件结构概览后精准定位。"
  }
  ```

##### 第四层：与 analyze_file 工具联动
- [ ] **工作流引导**：通过 `hint` 字段引导 LLM 先调用 `analyze_file` 获取文件结构
- [ ] **analyze_file 返回信息**：符号列表（子电路、参数、模型）、各符号的行号范围
- [ ] **精准读取**：LLM 根据 `analyze_file` 返回的行号范围，使用 `read_file(start_line, end_line)` 精准读取
- [ ] **analyze_file 大文件保护**：超过 `ANALYZE_FILE_MAX_BYTES`（5MB）时拒绝分析，返回错误信息

##### read_file 工具 Schema 定义
- [ ] **Schema 结构**：
  ```python
  READ_FILE_SCHEMA = {
      "name": "read_file",
      "description": "读取文件内容。支持三种模式：1)整体读取（小文件）2)行号范围读取 3)语义查询定位读取（大文件推荐）",
      "parameters": {
          "type": "object",
          "properties": {
              "path": {"type": "string", "description": "文件路径"},
              "start_line": {"type": "integer", "description": "起始行（可选，从1开始，与query互斥）"},
              "end_line": {"type": "integer", "description": "结束行（可选，包含该行，与query互斥）"},
              "query": {"type": "string", "description": "语义查询（可选，用于在大文件中定位相关内容，与start_line/end_line互斥）"},
              "max_tokens": {"type": "integer", "default": 2000, "description": "最大返回 Token 数"}
          },
          "required": ["path"]
      }
  }
  ```

#### 6.1.7 语义定位读取机制

> **设计背景**：当 LLM 需要读取大文件中的特定内容（如"处理用户认证的逻辑"），但不知道具体行号时，
> 传统的 `analyze_file` + `read_file(start_line, end_line)` 两步操作效率较低。
> 语义定位读取允许 LLM 通过自然语言描述直接定位并读取相关内容。

> **⚠️ 分层降级策略**：
> - 精确搜索（关键词/正则匹配）：始终执行
> - 语义搜索（向量检索）：仅当文件已索引时执行
> - 用户不会因为索引未就绪而完全无法定位内容

##### 语义定位读取流程
- [ ] **触发条件**：`read_file` 工具调用时指定了 `query` 参数
- [ ] **执行流程**：
  1. 调用 `SmartFileReader.read_with_query(path, query, max_tokens)`
  2. `SmartFileReader` 调用 `FileContentLocator.locate(path, query)`
  3. `FileContentLocator` 调用 `InFileSearchService.search(path, query)`（阶段五 5.0.7）
  4. `InFileSearchService` 内部执行分层降级：
     - 精确搜索：始终执行
     - 语义搜索：仅当文件已索引时执行
  5. 获取匹配的行号范围列表（按相关性排序）
  6. 读取最相关的行号范围内容
  7. 应用 Token 预算截断
  8. 返回内容 + 行号范围信息 + `semantic_available` 状态

##### 语义定位返回结构
- [ ] **成功响应结构**：
  ```python
  {
    "success": True,
    "content": "...(定位到的内容)...",
    "file_info": {
      "total_lines": 2500,
      "total_bytes": 102400,
      "returned_tokens": 1800,
      "truncated": False
    },
    "location": {
      "start_line": 450,
      "end_line": 520,
      "match_score": 0.85,
      "match_type": "semantic"
    },
    "hint": "已通过语义查询定位到第450-520行。如需修改此区域，可使用 patch_file 或 read_file(start_line=450, end_line=520) 获取精确内容。"
  }
  ```
- [ ] **未找到匹配时的响应**：
  ```python
  {
    "success": True,
    "content": "...(文件开头内容，按默认截断)...",
    "file_info": {...},
    "location": None,
    "hint": "未找到与查询相关的内容。已返回文件开头部分。建议：1)调整查询关键词 2)使用 analyze_file 查看文件结构 3)使用 search_project 在整个项目中搜索"
  }
  ```

##### 参数互斥规则
- [ ] **优先级**：`start_line/end_line` > `query` > 默认（从头读取）
- [ ] **互斥检查**：若同时指定 `start_line/end_line` 和 `query`，忽略 `query`，使用行号范围
- [ ] **原因**：行号范围是精确定位，语义查询是模糊定位，精确优先

#### 6.1.6 `response_parser.py` - 响应解析器

- [ ] **文件路径**：`domain/llm/tools/response_parser.py`
- [ ] **职责**：解析LLM响应，提取结构化数据和工具调用
- [ ] **核心功能**：
  - `parse_response(response)` - 解析完整响应
  - `extract_tool_calls(response)` - 提取工具调用请求
  - `extract_json(text)` - 从文本中提取JSON块
  - `extract_code_blocks(text, language)` - 提取代码块
  - `validate_tool_call(tool_call, schema)` - 校验工具调用参数

##### 解析失败容错策略
- [ ] **JSON 格式错误**：尝试修复常见错误（尾逗号、单引号），仍失败则返回原始文本
- [ ] **代码块标记缺失**：使用启发式规则识别代码（缩进、关键词），提取可能的代码段
- [ ] **工具调用参数不完整**：记录警告，使用默认值填充可选参数，必填参数缺失则拒绝执行
- [ ] **响应格式与预期不符**：将整个响应作为纯文本处理，记录日志供调试

##### 重试机制
- [ ] 解析失败时，可选择请求 LLM 重新生成（通过 `RETRY_PARSE` 系统消息）
- [ ] 最多重试 1 次，避免无限循环
- [ ] 重试时在 Prompt 中明确指出格式要求

##### 多提供商兼容
- [ ] 不同 LLM 的工具调用格式可能有差异（OpenAI vs Gemini vs Claude）
- [ ] 内部统一转换为标准格式后处理
- [ ] 记录原始响应格式，便于调试
- [ ] **被调用方**：`tool_node.py`（解析工具调用）、各节点（解析LLM输出）

---

### 6.1-A 智能文件读取服务 (`domain/file_reader/`)

> **设计背景**：`read_file` 工具需要支持三种读取模式：整体读取、行号范围读取、语义定位读取。
> 为遵循单一职责原则，将智能读取逻辑从工具执行器中分离，形成独立的服务模块。

> **目录结构**：
> ```
> domain/file_reader/
> ├── __init__.py
> ├── smart_file_reader.py       # 智能文件读取器（门面类）
> ├── file_content_locator.py    # 文件内容定位器
> ├── read_result_builder.py     # 读取结果构建器
> └── models/
>     ├── __init__.py
>     └── read_result.py         # 读取结果数据类
> ```

#### 6.1-A.1 `read_result.py` - 读取结果数据类

- [ ] **文件路径**：`domain/file_reader/models/read_result.py`
- [ ] **职责**：定义文件读取结果的标准化数据结构
- [ ] **数据类定义**：
  - `FileReadResult` - 文件读取结果
    - `success: bool` - 是否成功
    - `content: str` - 文件内容
    - `file_info: FileInfo` - 文件元信息
    - `location: Optional[LocationInfo]` - 定位信息（语义定位时返回）
    - `hint: Optional[str]` - 提示信息
    - `error_type: Optional[str]` - 错误类型
    - `error_message: Optional[str]` - 错误信息
    - `suggestions: List[str]` - 建议列表
  - `FileInfo` - 文件元信息
    - `total_lines: int` - 总行数
    - `total_bytes: int` - 总字节数
    - `returned_tokens: int` - 返回的 Token 数
    - `truncated: bool` - 是否被截断
  - `LocationInfo` - 定位信息
    - `start_line: int` - 起始行号
    - `end_line: int` - 结束行号
    - `match_score: float` - 匹配分数（0-1）
    - `match_type: str` - 匹配类型（exact/semantic）
- [ ] **被调用方**：`SmartFileReader`、`ToolDispatcher`

#### 6.1-A.2 `smart_file_reader.py` - 智能文件读取器

> **初始化顺序**：Phase 3.28，依赖 FileManager、FileContentLocator、TokenBudgetAllocator，注册到 ServiceLocator

- [ ] **文件路径**：`domain/file_reader/smart_file_reader.py`
- [ ] **职责**：作为文件读取的统一入口，根据参数选择合适的读取策略
- [ ] **核心功能**：
  - `read(path, start_line, end_line, query, max_tokens) -> FileReadResult` - 主入口方法
  - `read_full(path, max_tokens) -> FileReadResult` - 整体读取（小文件）
  - `read_range(path, start_line, end_line, max_tokens) -> FileReadResult` - 行号范围读取
  - `read_with_query(path, query, max_tokens) -> FileReadResult` - 语义定位读取
- [ ] **读取策略选择**：
  1. 若指定了 `start_line` 或 `end_line` → 调用 `read_range()`
  2. 若指定了 `query` → 调用 `read_with_query()`
  3. 否则 → 调用 `read_full()`
- [ ] **大文件保护**：
  - 在读取前检查文件大小，超过 `READ_FILE_MAX_BYTES` 时返回错误
  - 读取后应用 Token 预算截断
- [ ] **依赖模块**：
  - `FileManager`（阶段二）- 底层文件读取
  - `FileContentLocator` - 语义定位
  - `TokenBudgetAllocator`（阶段五）- Token 预算截断
  - `ReadResultBuilder` - 结果构建
- [ ] **被调用方**：`ToolDispatcher`（read_file 工具执行）

#### 6.1-A.3 `file_content_locator.py` - 文件内容定位器

- [ ] **文件路径**：`domain/file_reader/file_content_locator.py`
- [ ] **职责**：在单个文件内执行搜索，定位与查询相关的内容区域
- [ ] **核心功能**：
  - `locate(path, query, max_results) -> List[LocationInfo]` - 定位相关内容
  - `locate_best(path, query) -> Optional[LocationInfo]` - 返回最相关的单个位置
- [ ] **定位流程**：
  1. 调用 `InFileSearchService.search(path, query)`（阶段五 5.0.7）
  2. 获取匹配结果列表（包含行号、分数、`semantic_available` 状态）
  3. 按相关性分数排序
  4. 扩展行号范围（向前后各扩展 5 行，确保上下文完整）
  5. 合并重叠的行号范围
  6. 返回 `LocationInfo` 列表
- [ ] **分层降级行为**：
  - `InFileSearchService` 内部实现分层降级策略
  - 精确搜索始终执行，语义搜索仅当文件已索引时执行
  - `FileContentLocator` 无需关心降级逻辑，只需处理返回结果
- [ ] **行号范围扩展规则**：
  - 默认向前后各扩展 5 行
  - 不超出文件边界
  - 相邻的匹配区域自动合并
- [ ] **依赖模块**：
  - `UnifiedSearchService`（阶段五）- 执行文件内搜索
- [ ] **被调用方**：`SmartFileReader`

#### 6.1-A.4 `read_result_builder.py` - 读取结果构建器

- [ ] **文件路径**：`domain/file_reader/read_result_builder.py`
- [ ] **职责**：构建标准化的文件读取结果，生成提示信息
- [ ] **核心功能**：
  - `build_success(content, file_info, location, hint) -> FileReadResult` - 构建成功结果
  - `build_error(error_type, error_message, suggestions) -> FileReadResult` - 构建错误结果
  - `generate_hint(file_info, location, truncated) -> str` - 生成提示信息
- [ ] **提示信息生成规则**：
  - 文件被截断时：提示使用分段读取或 analyze_file
  - 语义定位成功时：提示匹配的行号范围，便于后续精确操作
  - 语义定位失败时：提示调整查询或使用其他工具
- [ ] **被调用方**：`SmartFileReader`

---

### 6.2 工具执行模块组 (`application/tool_execution/`)

> **目录结构**：
> ```
> application/tool_execution/
> ├── __init__.py
> ├── tool_executor.py           # 门面类，协调各子模块
> ├── tool_validator.py          # 参数校验
> ├── tool_dispatcher.py         # 工具调度分发
> ├── operation_recorder.py      # 操作记录管理
> ├── idempotency_checker.py     # 幂等性检查
> └── adapter/                   # 工具执行适配层（隔离 LangGraph）
>     ├── __init__.py
>     ├── tool_call_types.py     # 统一工具调用类型定义
>     ├── tool_adapter.py        # 工具执行适配器基类
>     └── langgraph_adapter.py   # LangGraph 工具调用适配器
> ```

> **单一职责拆分**：为避免单个文件职责过重，将工具执行功能拆分为多个协作模块

> **初始化顺序**：Phase 3.30，依赖 FileManager、ProcessManager、各领域服务，注册到 ServiceLocator

#### 6.2.0 工具执行适配层 (`application/tool_execution/adapter/`)

> **设计背景**：当前 `ToolNode` 直接与 LangGraph 集成，工具调用的解析、执行、结果格式化都与 LangGraph 的数据结构紧密耦合。为实现框架无关性，需要引入工具执行适配层，隔离 LangGraph 的工具调用机制。

> **解耦目标**：
> - `ToolExecutor` 只依赖统一的工具调用类型（`UnifiedToolCall`、`UnifiedToolResult`）
> - LangGraph 的 `ToolNode` 通过适配器与 `ToolExecutor` 交互
> - 未来切换到其他工作流框架（如 LangChain LCEL、自定义框架）时，只需实现新的适配器
> - `AgenticLoopController` 也通过适配器调用工具，保持一致性

##### 6.2.0.1 `tool_call_types.py` - 统一工具调用类型

- [ ] **文件路径**：`application/tool_execution/adapter/tool_call_types.py`
- [ ] **职责**：定义与框架无关的统一工具调用和结果类型
- [ ] **核心数据类**：
  - `UnifiedToolCall` - 统一的工具调用请求，包含 `id`（调用ID）、`name`（工具名）、`arguments`（已解析字典）、`raw_arguments`（原始字符串）、`source`（来源标识）字段
  - `UnifiedToolResult` - 统一的工具执行结果，包含 `tool_call_id`、`tool_name`、`success`、`content`、`structured_result`、`error_type`、`error_message`、`suggestion`、`execution_time_ms` 字段
  - `ToolExecutionContext` - 工具执行上下文，包含 `project_path`、`current_file`、`graph_state`、`session_id`、`iteration`、`max_result_length`、`file_version_tracker` 字段
- [ ] **`ToolExecutionContext` 详细字段**：
  - `project_path: str` - 项目根目录路径
  - `current_file: Optional[str]` - 当前操作的文件路径
  - `graph_state: dict` - 当前 GraphState 快照
  - `session_id: str` - 会话标识
  - `iteration: int` - 当前迭代次数
  - `max_result_length: int` - 结果最大长度（默认 5000 字符）
  - `file_version_tracker: FileVersionTracker` - 文件版本追踪器实例
- [ ] **FileVersionTracker 生命周期**：
  - 每轮工具调用开始时创建新的 `FileVersionTracker` 实例
  - `read_file` 工具执行时自动调用 `tracker.record_read()`
  - `patch_file`/`rewrite_file` 工具执行前自动调用 `tracker.verify_before_write()`
  - 工具调用轮次结束后 tracker 实例被丢弃
- [ ] **类型转换方法**：
  - `UnifiedToolCall.from_langgraph(tool_call)` - 从 LangGraph ToolCall 转换
  - `UnifiedToolCall.from_openai_format(tool_call)` - 从 OpenAI 格式转换
  - `UnifiedToolResult.to_langgraph_message()` - 转换为 LangGraph ToolMessage
  - `UnifiedToolResult.to_openai_format()` - 转换为 OpenAI tool 消息格式
  - `UnifiedToolResult.to_dict()` - 转换为字典（通用）

##### 6.2.0.2 `tool_adapter.py` - 工具执行适配器基类

- [ ] **文件路径**：`application/tool_execution/adapter/tool_adapter.py`
- [ ] **职责**：定义工具执行适配器的抽象接口
- [ ] **抽象基类 `BaseToolAdapter`**：
  - 构造函数接收 `ToolExecutor` 实例
  - `parse_tool_calls(raw_input)` - 抽象方法，从框架特定格式解析工具调用列表
  - `format_results(results)` - 抽象方法，将执行结果格式化为框架特定格式
  - `get_adapter_name()` - 抽象方法，获取适配器名称
  - `execute_tool_calls(tool_calls, context)` - 通用实现，遍历调用 `ToolExecutor.execute_tool()`
  - `execute_and_format(raw_input, context)` - 通用实现，解析→执行→格式化的完整流程
- [ ] **适配器注册机制**：
  - `ToolAdapterRegistry` 管理所有已注册的适配器
  - 支持按名称获取适配器实例
  - 支持动态注册新适配器

##### 6.2.0.3 `langgraph_adapter.py` - LangGraph 工具调用适配器

- [ ] **文件路径**：`application/tool_execution/adapter/langgraph_adapter.py`
- [ ] **职责**：将 LangGraph 的工具调用机制适配到统一接口
- [ ] **解析逻辑**：
  - 支持从 `AIMessage.tool_calls` 直接解析
  - 支持从 `GraphState["messages"]` 中提取最后一条 AIMessage 的工具调用
  - 将 LangChain ToolCall 转换为 `UnifiedToolCall`，设置 `source="langgraph"`
- [ ] **格式化逻辑**：
  - 将 `UnifiedToolResult` 列表转换为 LangChain `ToolMessage` 列表
  - 在 `additional_kwargs` 中携带 `success`、`execution_time_ms` 等元数据
- [ ] **与 ToolNode 的集成**：
  - `ToolNode` 内部持有 `LangGraphToolAdapter` 实例
  - 调用 `execute_and_format(state, context)` 完成工具执行
  - 将返回的 `ToolMessage` 列表追加到 `state["messages"]`

##### 6.2.0.4 与 AgenticLoopController 的集成

- [ ] **设计说明**：`AgenticLoopController`（阶段三 3.3.2 节）也通过适配器调用工具
- [ ] **线程模型**：AgenticLoopController 在主线程的 qasync 融合事件循环中执行（详见阶段三 3.0 节），工具执行也在该循环中协作式进行
- [ ] **适配器选择**：
  - Agentic Loop 使用 OpenAI 格式的工具调用
  - 可复用 `LangGraphToolAdapter` 或创建专用的 `AgenticLoopAdapter`
- [ ] **集成方式**：
  - 在 `AgenticLoopController.__init__()` 中创建适配器实例
  - 在 `_execute_tools()` 方法中使用 `UnifiedToolCall.from_openai_format()` 转换工具调用
  - 创建 `ToolExecutionContext` 并调用 `execute_tool_calls()`
  - 使用 `to_openai_format()` 将结果转换回 OpenAI 格式

##### 6.2.0.5 扩展新框架的步骤

- [ ] **扩展步骤**：
  1. 在 `adapter/` 目录下创建新适配器文件（如 `lcel_adapter.py`）
  2. 继承 `BaseToolAdapter`，实现 `parse_tool_calls()` 和 `format_results()`
  3. 在新框架的工具节点中使用新适配器
  4. `ToolExecutor` 和各工具处理器无需任何修改

##### 6.2.0.6 适配层设计优势

- [ ] **框架无关性**：`ToolExecutor` 不依赖任何特定框架的类型
- [ ] **统一接口**：所有工具调用都通过 `UnifiedToolCall` 和 `UnifiedToolResult`
- [ ] **易于测试**：可以直接构造 `UnifiedToolCall` 进行单元测试，无需模拟框架
- [ ] **灵活扩展**：新增框架支持只需实现适配器，不影响核心逻辑
- [ ] **调试友好**：统一类型包含 `source` 和 `raw_arguments` 字段，便于追踪问题

---

#### 6.2.1 `tool_executor.py` - 工具执行门面类

- [ ] **文件路径**：`application/tool_execution/tool_executor.py`
- [ ] **职责**：作为工具执行的统一入口，协调参数校验、幂等性检查、调度执行、操作记录等子模块
- [ ] **核心功能**：
  - `execute_tool(tool_name, parameters, context)` - 执行工具调用（统一入口，返回 `UnifiedToolResult`）
  - `format_result(result)` - 格式化执行结果为字符串
  - `build_error_feedback(error, tool_name, context)` - 构建详细错误反馈信息

> **⚠️ 接口变更说明**：
> - `execute_tool()` 方法的 `state` 参数改为 `context: ToolExecutionContext`
> - 返回类型从 `dict` 改为 `UnifiedToolResult`
> - 调用方通过适配器（6.2.0 节）与 `ToolExecutor` 交互，无需直接处理框架特定类型

##### 与适配层的集成

> **设计说明**：`ToolExecutor` 不再直接被 `ToolNode` 或 `AgenticLoopController` 调用，而是通过适配器（6.2.0 节）间接调用。这样 `ToolExecutor` 只需关注工具执行逻辑，无需处理不同框架的消息格式。

- [ ] **输入类型**：
  - `tool_name: str` - 工具名称
  - `parameters: dict` - 工具参数（已解析为字典）
  - `context: ToolExecutionContext` - 执行上下文
- [ ] **输出类型**：
  - 返回 `UnifiedToolResult`，包含执行结果、错误信息等
  - 适配器负责将 `UnifiedToolResult` 转换为框架特定格式
- [ ] **结果长度控制**：
  - 工具结果可能很长（如文件内容、搜索结果）
  - 超过 `context.max_result_length`（默认 5000 字符）时自动截断
  - 截断时保留开头和结尾，中间显示"... [截断 N 字符] ..."
- [ ] **错误结果处理**：
  - 工具执行失败时，设置 `UnifiedToolResult.success = False`
  - 填充 `error_type`、`error_message`、`suggestion` 字段
  - 提供详细的上下文信息帮助 LLM 决策下一步
- [ ] **执行流程**：
  1. 接收适配器传入的工具调用请求（`tool_name`、`parameters`、`context`）
  2. 委托 `tool_validator` 校验参数完整性和安全性
  3. 委托 `idempotency_checker` 检查是否可跳过执行
  4. 委托 `operation_recorder` 记录操作开始
  5. 委托 `tool_dispatcher` 调用对应处理器
  6. 委托 `operation_recorder` 记录操作完成
  7. 构造并返回 `UnifiedToolResult`
- [ ] **依赖模块**：
  - `ToolValidator` - 参数校验
  - `ToolDispatcher` - 工具调度
  - `OperationRecorder` - 操作记录
  - `IdempotencyChecker` - 幂等性检查
- [ ] **被调用方**：`tool_node.py`（LangGraph工具节点）



#### 6.2.2 `tool_validator.py` - 参数校验器

- [ ] **文件路径**：`application/tool_execution/tool_validator.py`
- [ ] **职责**：专注于工具调用参数的校验，确保参数完整性和安全性
- [ ] **核心功能**：
  - `validate(tool_name, parameters)` - 校验参数完整性
  - `validate_file_path(path)` - 校验文件路径安全性
  - `validate_required_params(tool_name, parameters)` - 校验必填参数
  - `get_validation_rules(tool_name)` - 获取工具的校验规则
- [ ] **安全校验规则**：
  - 文件路径必须在工作目录内
  - 拒绝危险操作（如删除系统文件）
  - 路径不能包含 `..` 等目录遍历字符
  - 文件扩展名白名单校验
- [ ] **校验结果结构**：
  ```python
  {
    "valid": bool,           # 是否通过校验
    "errors": list[str],     # 错误信息列表
    "warnings": list[str],   # 警告信息列表
    "sanitized_params": dict # 清理后的参数
  }
  ```
- [ ] **被调用方**：`tool_executor.py`

#### 6.2.3 `tool_dispatcher.py` - 工具调度分发器

- [ ] **文件路径**：`application/tool_execution/tool_dispatcher.py`
- [ ] **职责**：专注于将工具调用分发到对应的领域服务或基础设施模块
- [ ] **核心功能**：
  - `dispatch(tool_name, parameters, context)` - 分发工具调用
  - `register_handler(tool_name, handler)` - 注册工具处理器
  - `get_handler(tool_name)` - 获取工具处理器
- [ ] **文件版本校验集成**：
  - `read_file` 工具执行后，自动调用 `context.file_version_tracker.record_read(path, content)`
  - `patch_file`/`rewrite_file` 工具执行前，自动调用 `context.file_version_tracker.verify_before_write(path)`
  - 版本校验失败时，抛出 `FileModifiedExternallyError` 异常
  - 异常被 `tool_executor.py` 捕获并转换为结构化错误反馈
- [ ] **工具与处理器映射**（精简后）：
  - **文件操作**：
    - `list_project_files` → `file_manager.list_directory()`
    - `read_file` → `file_manager.read_file()` + `tracker.record_read()`
    - `rewrite_file` → `tracker.verify_before_write()` + `file_manager.rewrite_file()`
    - `patch_file` → `tracker.verify_before_write()` + `file_manager.patch_file()`
  - **搜索工具**：
    - `search_project` → `unified_search_service.search()`（统一搜索门面，阶段五 5.0.4）
    - `search_exact` → `file_search_service.search_by_content()`（精确搜索快捷入口）
    - `find_references` → `location_service.find_references()`
  - **文件分析**：
    - `analyze_file` → `file_analyzer.analyze()`
    - `get_file_summary` → `file_analyzer.get_file_summary()`
    - `get_dependencies` → `file_analyzer.get_dependencies()`
  - **仿真工具**：
    - `run_simulation` → `simulation_service.run()`
    - `run_pvt_analysis` → `simulation_service.run_pvt_analysis()`
    - `run_monte_carlo` → `simulation_service.run_monte_carlo()`
    - `run_parametric_sweep` → `simulation_service.run_parametric_sweep()`
    - `run_worst_case` → `simulation_service.run_worst_case()`
    - `run_sensitivity` → `simulation_service.run_sensitivity()`
    - `generate_chart` → `chart_generator.generate_charts()`
    - `inspect_data` → `simulation_service` + `metrics_extractor`
    - `export_waveform_data` → `data_exporter.export_to_*()`
  - **报告工具**：
    - `generate_design_report` → `report_generator.generate_report()`
- [ ] **扩展机制**：新增工具只需注册对应的处理器，无需修改主类
- [ ] **被调用方**：`tool_executor.py`

#### 6.2.4 `operation_recorder.py` - 操作记录管理器

- [ ] **文件路径**：`application/tool_execution/operation_recorder.py`
- [ ] **职责**：专注于记录工具执行的操作，供 UI 展示操作摘要和 Diff 预览
- [ ] **核心功能**：
  - `record_start(op_type, details)` - 记录操作开始
  - `record_complete(op_id, status, result, diff_info)` - 记录操作完成（含 Diff 信息）
  - `record_skipped(op_type, reason)` - 记录跳过的操作（幂等性检查）
  - `get_pending_operations()` - 获取当前轮次的操作列表
  - `get_current_round_operations()` - 获取当前助手回复轮次的所有操作
  - `clear_operations()` - 清空操作列表（新一轮开始时）
  - `get_operation_by_id(op_id)` - 获取指定操作详情
  - `undo_operation(op_id)` - 撤销单个操作（恢复文件到操作前状态）
  - `get_operations_for_message(message_id)` - 获取某条消息关联的所有操作

##### 操作记录数据结构（扩展版）

- [ ] **基础操作记录结构**：
  ```python
  {
    "op_id": str,              # 操作唯一标识（UUID）
    "op_type": str,            # 操作类型（create_file/patch_file/run_simulation等）
    "op_category": str,        # 操作分类（file_create/file_modify/file_delete/simulation/search）
    "details": dict,           # 操作详情（文件路径、参数等）
    "status": str,             # 状态（pending/success/failed/skipped/undone）
    "start_time": float,       # 开始时间戳
    "end_time": float,         # 结束时间戳（可选）
    "result": dict,            # 执行结果（可选）
    "skipped_reason": str,     # 跳过原因（可选，幂等性检查时）
    "message_id": str,         # 关联的助手消息 ID（用于 UI 展示）
    "can_undo": bool,          # 是否支持撤销
    "diff_info": dict,         # Diff 信息（文件修改操作专用）
    "display_summary": str,    # 用于 UI 显示的操作摘要
  }
  ```

##### 文件操作 Diff 信息结构

- [ ] **Diff 信息结构**（`diff_info` 字段）：
  ```python
  {
    "file_path": str,          # 文件路径
    "operation": str,          # 操作类型（create/modify/delete）
    "before_content": str,     # 修改前内容（modify 时有值，create 时为 None）
    "after_content": str,      # 修改后内容（delete 时为 None）
    "before_lines": int,       # 修改前行数
    "after_lines": int,        # 修改后行数
    "changes": [               # 变更详情列表
      {
        "type": str,           # 变更类型（add/remove/modify）
        "line_start": int,     # 起始行号
        "line_end": int,       # 结束行号
        "old_text": str,       # 旧内容（remove/modify 时有值）
        "new_text": str,       # 新内容（add/modify 时有值）
      }
    ],
    "stats": {                 # 变更统计
      "additions": int,        # 新增行数
      "deletions": int,        # 删除行数
      "modifications": int,    # 修改行数
    },
    "backup_path": str,        # 备份文件路径（用于撤销）
  }
  ```

##### 操作摘要生成

- [ ] **`generate_display_summary(op_type, details, diff_info)`** - 生成用于 UI 显示的操作摘要
- [ ] **摘要格式示例**：
  - 创建文件：`"创建文件 inverter.cir（25 行）"`
  - 修改文件：`"修改 amplifier.cir（+3 行，-1 行）"`
  - 删除文件：`"删除文件 old_design.cir"`
  - 运行仿真：`"运行 AC 分析仿真"`
  - 搜索文件：`"搜索 'R1' 找到 3 个结果"`

##### 撤销支持

- [ ] **可撤销操作类型**：
  - `rewrite_file` - 撤销时恢复备份内容
  - `patch_file` - 撤销时恢复备份内容
- [ ] **不可撤销操作类型**：
  - `run_simulation` - 仿真结果可重新运行获取
  - `search_files` - 搜索操作无副作用
  - `generate_chart` - 图表可重新生成
- [ ] **备份机制**：
  - 文件修改操作执行前，自动备份原文件到 `.circuit_ai/undo_backups/`
  - 备份文件命名：`{op_id}_{filename}.bak`
  - 撤销时从备份恢复，撤销成功后删除备份
  - 会话结束时清理过期备份（超过 24 小时）

- [ ] **事件发布**：
  - 操作记录变更时发布 `EVENT_OPERATION_RECORDED` 事件
  - 事件携带数据：`{"op_id": str, "status": str, "op_type": str, "display_summary": str}`
  - 操作撤销时发布 `EVENT_OPERATION_UNDONE` 事件
  - 事件携带数据：`{"op_id": str, "file_path": str}`
- [ ] **被调用方**：`tool_executor.py`、`conversation_panel.py`（展示操作摘要）、`operation_card.py`（操作卡片组件）

#### 6.2.5 `idempotency_checker.py` - 幂等性检查器

- [ ] **文件路径**：`application/tool_execution/idempotency_checker.py`
- [ ] **职责**：专注于检查工具调用是否可以跳过执行（幂等性保证）
- [ ] **设计原则**：同一工具调用重复执行应产生相同结果，不产生副作用
- [ ] **核心功能**：
  - `check(tool_name, parameters, state)` - 检查是否可跳过执行
  - `compute_hash(tool_name, parameters)` - 计算参数哈希
  - `get_cached_result(hash_key)` - 获取缓存的执行结果

##### 各工具的幂等性检查逻辑

- [ ] **`rewrite_file` 幂等性**：
  1. 检查文件是否已存在
  2. 若存在，计算现有内容哈希与目标内容哈希
  3. 哈希相同 → 返回"文件内容已是目标状态"，可跳过
  4. 哈希不同 → 需要执行写入

- [ ] **`patch_file` 幂等性**：
  1. 读取现有文件内容
  2. 检查 search 内容是否存在（若 fuzzy=True，使用模糊匹配）
  3. 若不存在 → 检查 replace 内容是否已存在（可能已被替换过）
  4. 若 replace 已存在 → 返回"内容已是目标状态"，可跳过
  5. 若 search 和 replace 都不存在 → 返回错误"搜索内容未找到"
  6. 若 search 存在 → 需要执行替换

- [ ] **`run_simulation` 幂等性**：
  1. 计算仿真参数哈希（文件路径 + 分析类型 + 参数）
  2. 检查 GraphState.simulation_results 中是否有相同哈希的结果
  3. 若有且未过期 → 返回缓存结果，可跳过
  4. 若无或已过期 → 需要执行仿真

- [ ] **`generate_chart` 幂等性**：
  1. 计算图表参数哈希（类型 + 数据源 + 迭代号）
  2. 检查 simulation_results/session_{timestamp}/iteration_{N}/charts/ 目录是否已有对应图表文件
  3. 若有且数据源未变更 → 返回现有图表路径，可跳过
  4. 若无或数据源已变更 → 需要重新生成

- [ ] **检查结果结构**：
  ```python
  {
    "can_skip": bool,        # 是否可以跳过执行
    "reason": str,           # 原因说明
    "cached_result": dict,   # 缓存的结果（若可跳过）
  }
  ```
- [ ] **被调用方**：`tool_executor.py`



---

### 6.3 搜索工具使用场景

> **设计原则**：LLM 默认使用 `search_project` 统一搜索工具，无需判断应该用精确搜索还是语义搜索。
> 只有在明确需要正则匹配或符号定位时，才使用 `search_exact` 快捷入口。

- [ ] **`search_project` 工具使用场景**（主推）：
  - LLM 需要查找特定文件但不确定完整路径时
  - 用户描述"找到所有运放相关的文件"时
  - 需要在项目中搜索特定内容（如参数名、元件名）时
  - 需要查找相关设计文档或参考资料时
  - 不确定搜索目标是代码还是文档时
  - 返回结果分为 `exact_matches` 和 `semantic_matches` 两组，LLM 可根据需要选用
- [ ] **`search_exact` 工具使用场景**（可选快捷入口）：
  - LLM 明确知道要做正则表达式搜索时
  - 需要精确匹配特定字符串（如 `R1 10K`）时
  - 使用 `search_type=symbol` 搜索子电路、参数定义时
  - 不需要语义搜索结果，只需要精确匹配时
- [ ] **`find_references` 工具使用场景**：
  - 修改子电路前需要了解影响范围时
  - 重命名参数前需要找到所有使用位置时
  - 分析电路依赖关系时

### 6.4 操作结果的结构化反馈

> **实现位置**：`application/tool_execution/tool_executor.py` 的 `format_result()` 方法

- [ ] **文件操作结果结构**：
  ```python
  {
    "success": bool,
    "operation": str,           # 执行的操作类型
    "file_path": str,
    "changes_summary": str,     # 变更摘要
    "error_info": dict,         # 错误信息（失败时）
    "suggestions": list,        # 后续操作建议（失败时）
  }
  ```
- [ ] **搜索结果结构**（`search_project` 返回）：
  ```python
  {
    "success": bool,
    "query": str,
    "exact_matches": [         # 精确匹配结果
      {
        "content": str,        # 匹配内容（已截断）
        "source": str,         # 文件路径
        "line_number": int,
        "match_type": str,     # exact/fuzzy/regex/symbol
        "score": float,
        "truncated": bool,
      }
    ],
    "semantic_matches": [      # 语义匹配结果
      {
        "content": str,        # 匹配内容（已截断）
        "source": str,         # 文件路径或文档标题
        "section": str,        # 章节（文档）
        "score": float,
        "truncated": bool,
      }
    ],
    "token_usage": {
      "exact_tokens": int,
      "semantic_tokens": int,
      "total_tokens": int,
      "budget": int,
      "utilization": float,
    },
    "search_time_ms": float,
  }
  ```
- [ ] **符号定位结果结构**：
  ```python
  {
    "success": bool,
    "symbol_name": str,
    "definition": {
      "file_path": str,
      "line_start": int,
      "line_end": int,
      "preview": str,
    },
    "references": [
      {
        "file_path": str,
        "line_number": int,
        "usage_type": str,  # definition/read/write/call
      }
    ],
  }
  ```

---

### 6.5 事件类型定义

- [ ] **文件路径**：`shared/event_types.py`（新增事件常量）
- [ ] **新增事件常量**：
  ```python
  # 工具执行相关事件
  EVENT_OPERATION_RECORDED = "tool.operation_recorded"      # 操作记录变更
  EVENT_OPERATION_UNDONE = "tool.operation_undone"          # 操作已撤销
  EVENT_TOOL_EXECUTION_START = "tool.execution_start"       # 工具开始执行
  EVENT_TOOL_EXECUTION_COMPLETE = "tool.execution_complete" # 工具执行完成
  EVENT_TOOL_EXECUTION_ERROR = "tool.execution_error"       # 工具执行错误
  EVENT_FILE_CONFLICT_DETECTED = "tool.file_conflict"       # 文件外部修改冲突检测
  ```
- [ ] **事件数据结构**：
  - `EVENT_FILE_CONFLICT_DETECTED` 携带数据：
    ```python
    {
      "file_path": str,          # 冲突的文件路径
      "action": str,             # 后续动作（"retry" 表示 LLM 将重新读取）
    }
    ```
  - `EVENT_OPERATION_RECORDED` 携带数据：
    ```python
    {
      "op_id": str,              # 操作唯一标识
      "status": str,             # 状态（pending/success/failed/skipped）
      "op_type": str,            # 操作类型
      "display_summary": str,    # 显示摘要
      "message_id": str,         # 关联的消息 ID
    }
    ```
  - `EVENT_OPERATION_UNDONE` 携带数据：
    ```python
    {
      "op_id": str,              # 操作唯一标识
      "file_path": str,          # 被撤销的文件路径
      "restore_success": bool,   # 恢复是否成功
    }
    ```

---

### 6.6 阶段检查点

#### 6.6.1 功能验证检查项

- [ ] 工具注册表包含所有定义的工具 Schema
- [ ] 响应解析器能正确提取工具调用请求
- [ ] 工具执行器能正确分发到对应处理器
- [ ] 参数校验器能拦截非法参数
- [ ] 幂等性检查器能正确识别可跳过的操作
- [ ] 操作记录器能正确记录操作历史

#### 6.6.2 集成验证检查项

- [ ] 文件操作工具能正确调用 FileManager
- [ ] 搜索工具能正确调用 FileSearchService
- [ ] 仿真工具能正确调用 SimulationService
- [ ] 操作记录能正确发布事件供 UI 订阅

#### 6.6.3 工具执行模块组验证

- [ ] `ToolExecutor` 门面类正确委托给各子模块
- [ ] `ToolValidator` 参数校验和安全检查正常
- [ ] `ToolDispatcher` 工具调度分发正确
- [ ] `OperationRecorder` 操作记录和事件发布正常
- [ ] `IdempotencyChecker` 幂等性检查逻辑正确

#### 6.6.4 操作记录与 Diff 信息验证

- [ ] 文件创建操作正确记录 `diff_info`（`operation: "create"`）
- [ ] 文件修改操作正确记录 `diff_info`（包含 `before_content`、`after_content`、`changes`）
- [ ] Diff 变更统计正确计算（`additions`、`deletions`、`modifications`）
- [ ] 操作摘要正确生成（如"修改 amplifier.cir（+3 行，-1 行）"）
- [ ] 备份文件正确创建到 `.circuit_ai/undo_backups/` 目录
- [ ] `undo_operation()` 正确恢复文件内容
- [ ] 撤销后备份文件正确删除
- [ ] `EVENT_OPERATION_RECORDED` 事件正确发布
- [ ] `EVENT_OPERATION_UNDONE` 事件正确发布
- [ ] `get_operations_for_message()` 正确返回关联操作列表

#### 6.6.5 文件修改工具验证

- [ ] `rewrite_file` 整体重写正常工作
- [ ] `patch_file` 精确匹配模式正常工作
- [ ] `patch_file` 模糊匹配模式正常工作
- [ ] 错误反馈信息包含详细上下文和建议

#### 6.6.6 文件版本追踪验证（TOCTOU 竞态条件检测）

- [ ] `read_file` 工具执行后正确记录文件哈希到 `FileVersionTracker`
- [ ] `patch_file` 工具执行前正确校验文件版本
- [ ] `rewrite_file` 工具执行前正确校验文件版本
- [ ] 文件未被修改时版本校验通过，正常执行写入
- [ ] 文件被外部修改时版本校验失败，返回 `file_modified_externally` 错误
- [ ] 错误信息包含正确的建议（重新读取文件）
- [ ] 未读取过的文件（新文件）版本校验通过
- [ ] 内容哈希计算正确处理换行符差异（CRLF vs LF）
- [ ] `EVENT_FILE_CONFLICT_DETECTED` 事件正确发布
- [ ] 状态栏正确显示冲突提示

#### 6.6.7 工具执行适配层验证

- [ ] `UnifiedToolCall` 能正确从 LangGraph ToolCall 转换
- [ ] `UnifiedToolCall` 能正确从 OpenAI 格式转换
- [ ] `UnifiedToolResult` 能正确转换为 LangGraph ToolMessage
- [ ] `UnifiedToolResult` 能正确转换为 OpenAI tool 消息格式
- [ ] `LangGraphToolAdapter.parse_tool_calls()` 正确解析 AIMessage
- [ ] `LangGraphToolAdapter.format_results()` 正确生成 ToolMessage 列表
- [ ] `ToolExecutor` 返回的 `UnifiedToolResult` 包含完整信息
- [ ] 适配器与 `ToolNode` 集成正常
- [ ] 适配器与 `AgenticLoopController` 集成正常
- [ ] 工具执行错误能正确传递到适配层并格式化

---

### 6.7 与统一信息展示面板集成

> **集成说明**：工具执行模块的操作信息将自动推送到统一信息展示面板（阶段九 9.0 节），便于用户集中查看和管理

> **设计原则**：领域层事件只携带结构化业务数据，不包含展示文本。格式化逻辑由阶段九的 `OperationFormatter` 负责。

#### 6.7.1 事件数据规范

- [ ] **`EVENT_OPERATION_RECORDED` 事件数据**：
  ```python
  {
    "op_id": str,              # 操作唯一标识
    "status": str,             # 状态（pending/success/failed/skipped）
    "op_type": str,            # 操作类型
    "op_category": str,        # 操作分类
    "file_path": str,          # 文件路径（文件操作专用）
    "message_id": str,         # 关联的消息 ID
    "diff_info": dict,         # Diff 信息（文件操作专用）
    "can_undo": bool,          # 是否支持撤销
  }
  ```
- [ ] **`EVENT_TOOL_EXECUTION_COMPLETE` 事件数据**：
  ```python
  {
    "tool_name": str,          # 工具名称
    "success": bool,           # 是否成功
    "duration_ms": float,      # 执行耗时
    "result": dict,            # 执行结果（结构化数据）
    "error": str,              # 错误信息（失败时）
  }
  ```

#### 6.7.2 信息卡片生成

- [ ] **文件操作卡片**：`OperationInfoCollector` 订阅 `EVENT_OPERATION_RECORDED` 事件，创建 `InfoCard`
- [ ] **工具执行卡片**：`OperationInfoCollector` 订阅 `EVENT_TOOL_EXECUTION_COMPLETE` 事件，创建 `InfoCard`
- [ ] **格式化职责**：由阶段九的 `OperationFormatter` 负责生成展示文本

#### 6.7.3 被调用方

- [ ] `OperationInfoCollector`（阶段九）订阅操作事件并生成信息卡片
